[{"title":"2020CCPC网络选拔赛","url":"/2020/09/20/CCPC2020online/","content":"\n\n\n2020CCPC网络选拔赛等\n\n<!--more-->\n\n## 01\n\n第一眼看上去是扫描线，但是直接做复杂度是 $O(n^2\\log n)$ 的，显然会T。\n\n后来听说好像是吉如一线段树？以后去了解一下。\n\n## 02\n\n画图模拟了一下大概可以得到这样的结论：$\\large S_n=\\sum_{i=3}^{n+1}i + Sp_{[3,n+1]}$\n\n其中 $Sp$ 表示区间中的质数之和。\n\n前面的求和显然可以直接用等差数列公式 $O(1)$ 求出，但是后面的就很难办，$n$ 的范围达到了 $1\\times 10^{10}$，线性筛都用不了，只能用神奇的Min-25筛。\n\n用Min-25筛求出 $[1,n+1]$ 的质数和再去掉 $2$ 即可，时间复杂度似乎是 $\\large \\dfrac{n^{\\frac 3 4}}{\\log n}$，反正跑的很快。\n\n不得不说Min-25牛逼。\n\n这题其实分段打表说不定也能过。\n\n## 03\n\n水题\n\n## 04\n\n不会\n\n## 05\n\n博弈论，想了很久一直很混乱，最后也没做出来。\n\nSG函数以后还要去看看。\n\n## 06\n\n好像是挺复杂的题，但是数据很弱，可以乱搞过去？\n\n## 07\n\n签到题\n\n## 08\n\n不会\n\n## 09\n\n不会\n\n## 10\n\n签到题\n\n## 11\n\n看起来很恐怖，但是仔细想想只有两种情况。\n\n## 12\n\n不会\n\n## 13\n\n不知道怎么优化，以后可以看一下。\n\n## PTA天梯赛选拔\n\n昨晚的比赛顺便写一下。\n\n前面一堆模拟的水题，但是有两三个题拿不到全分，可能是边界数据之类的问题。\n\nT9-T11题也不难，但是T10没有好的思路，后来想想应该是树状数组之类的东西可以做做看？\n\nT12似乎不太严谨，极角排序能过，但是我不会。\n\nT13看起来像二分图匹配，没模板连匈牙利算法都写不太出来，更不用说Dinic最大流了。\n\n最后两题比较难，也没时间去做，就不管了。\n\n中间一度达到rank8，最后掉到rank20，有点可惜。\n\n- 84437728\n\n![84437728](https://i.loli.net/2020/09/20/D7Ec15rJY8TUnvy.jpg)","tags":["比赛"]},{"title":"配置Java环境等","url":"/2020/09/15/Java/","content":"\n\n\n配Java环境，简单配置IntelliJ IDEA，VS Code，eclipse。\n\n\n\n<!--more-->\n\n## 配置Java11环境\n\n先去[官网](https://www.oracle.com/java/technologies/javase-downloads.html)下载JDK，选Windows x64 Installer，不需要梯子就可以下载，如需要登录帐号就去网上找一个，然后正常安装即可。\n\n然后修改环境变量，可以参考[这个教程](https://www.runoob.com/w3cnote/windows10-java-setup.html)。\n\n配置完以后可以看 `java -version`，或者写一个hello world然后用 `javac XX`，`java XX` 试着编译一下。\n\n## 使用IntelliJ IDEA\n\nIDEA好像内置了JDK，直接新建Java项目无脑下一步就好了。\n\n## 安装配置eclipse\n\n和IDEA相比eclipse太菜了。再见。\n\n控制面板里找不到，根目录里面也没有卸载的地方，文档里也没说，真是垃圾。\n\n网上查了一下，直接把根目录删了好像就行了。\n\n## VS Code插件安装\n\n装 `Java Extension Pack`，会把必要的五六个插件都装上去，就可以用了。\n\n小东西用VS Code写，大的用IDEA，完美。\n\n- 84333405\n\n![84333405](https://i.loli.net/2020/09/15/jvaSFeQsEUnxT3W.jpg)","tags":["Java"]},{"title":"Educational Round 95总结","url":"/2020/09/14/CFedu95/","content":"\n突然unrated了，那就不打了早点睡觉，顺便在这里口胡一下做法。\n\n<!--more-->\n\n## A\n\nunr的罪魁祸首，题面有歧义。\n\n题目修好以后就是很简单的签到题，交换一次stick可以增加 $x-1$ 个stick，而总共需要 $y\\times k+k$ 个stick，除一下向上取整，再加上换coal用的 $k$ 次就是答案了。\n\n## B\n\n很显然的贪心，拿个大根堆模拟一下就好了。\n\n## C\n\n看起来是一个简单的线性DP。\n\n## D\n\n题面太长不看。看样例似乎是简单的数据结构题。后面的题以后有空再看了。\n\n- 84188262\n\n![84188262](https://i.loli.net/2020/09/14/27kewZt6KvQcRaB.jpg)\n\n","tags":["CodeForces"]},{"title":"AtCoder Beginner Contest 178","url":"/2020/09/13/ABC178/","content":"\n\n\n感觉题目变奇怪了，可能是我的思维越来越僵化了。。。\n\n\n\n<!--more-->\n\n## A\n\n送分题\n\n```c++\ncout << (a ? 0 : 1) << endl;\n```\n\n## B\n\n和上一次cf的B有点像\n\n```c++\n\tll a, b, c, d;\n    cin >> a >> b >> c >> d;\n    ll ans = max(a * c, a * d);\n    ans = max(ans, b * c);\n    ans = max(ans, b * d);\n    cout << ans << endl;\n```\n\n## C\n\n反向思维，得到 $N\\ge 2$ 的时候答案是 $10^N-2\\times9^N+8^N$，需要注意取模后算出的东西可能是负的，因为这个WA了一发\n\n```c++\n\tif (n <= 1)\n        cout << 0 << endl;\n    else\n    {\n        ll ans = ksm(10, n) - ksm(9, n) + ksm(8, n) - ksm(9, n);\n        ans %= mod;\n        ans = (ans + mod) % mod; // 不要忘了写这一行\n        cout << ans << endl;\n    }\n```\n\n## D\n\n将序列中所有元素均不小于 $3$，且所有元素和为 $n$ 的序列称为满足条件的序列，给出 $n$，求满足条件的序列个数，答案模 $10^9+7$。\n\n感觉应该是个DP，但是毫无思路。$n\\le2000$ 或许可以暴力？\n\n## E\n\n给出一些点求两点间最大曼哈顿距离。\n\n感觉应该是旋转卡壳求凸包直径，抄了个模板上去居然就过了。奇妙。\n\n计算几何还是需要重视一下。\n\n## F\n\n构造题，给两个长度相等的升序序列，问能不能改变第二个的顺序让两个序列的所有相同位置元素均不同。\n\n比赛的时候想了一下，只要两个里面最多相等元素的个数均不超过长度的一半就可以构造出来。\n\n但是没时间写了。不知道对不对。\n\n## 总结\n\n最近事情开始多起来了，不能再像暑假一样用大块时间学算法、练题了，所以更要规划好时间。\n\n之前觉得自己最大的问题在于代码能力，现在看来也不尽然。今天的CSP认证100+100+90+35+0=325，大模拟拿了90分，耗时也算正常，至少说明这方面的能力也不是那么差。\n\n但是不知道是不是cf换了个号从头打起的原因，心态上好像没有以前那么认真专注了，状态也是起伏很大。不过以前看最后两题往往没什么想法，最近倒是经常差一点做出来，可能在实力上确实是有了提升。\n\nABC和cf Div.3这样简单的比赛想要AK，现在看来并不需要学多少新东西，而是应该多练练各种题目，拓宽一下思维，见一见各种套路。\n\n等下周考完六级，要开始刷题了。有的中学生能做到半年千题，平均下来一天六七道，我就算比他们忙一些又比他们菜一些，一天两三道还是能做到的吧。\n\n- 84306688\n\n![84306688](https://i.loli.net/2020/09/13/MNghzcxWBGjwebQ.jpg)\n\n","tags":["AtCoder"]},{"title":"最小费用最大流","url":"/2020/09/08/MCMF/","content":"\n\n\n最小费用最大流模板。\n\n\n\n<!--more-->\n\n在最大流模型的基础上，给每条边增加了一个费用，于是需要求出费用最小的一条最大流。\n\n可以把求最大流的EK算法中的BFS改成最短路算法来找最小费用最大流。\n\n比较常见的费用流写法有三种：SPFA费用流，Dijkstra费用流以及zkw费用流。\n\n这里先放一个kuangbin的SPFA算法的模板，使用链式前向星存图。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\n\nconst int MAXN = 10000;\nconst int MAXM = 100000;\nconst int INF = 0x3f3f3f3f;\nstruct Edge\n{\n    int to, next, cap, flow, cost;\n} edge[MAXM];\nint head[MAXN], tol;\nint pre[MAXN], dis[MAXN];\nbool vis[MAXN];\nint N; //节点总个数，节点编号从0~N-1\nvoid init(int n)\n{\n    N = 2 * n + 2; // 原模板此处有误，现已改正\n    tol = 0;\n    memset(head, -1, sizeof(head));\n}\nvoid addedge(int u, int v, int cap, int cost)\n{\n    edge[tol].to = v;\n    edge[tol].cap = cap;\n    edge[tol].cost = cost;\n    edge[tol].flow = 0;\n    edge[tol].next = head[u];\n    head[u] = tol++;\n    edge[tol].to = u;\n    edge[tol].cap = 0;\n    edge[tol].cost = -cost;\n    edge[tol].flow = 0;\n    edge[tol].next = head[v];\n    head[v] = tol++;\n}\nbool spfa(int s, int t)\n{\n    queue<int> q;\n    for (int i = 0; i < N; i++)\n    {\n        dis[i] = INF;\n        vis[i] = false;\n        pre[i] = -1;\n    }\n    dis[s] = 0;\n    vis[s] = true;\n    q.push(s);\n    while (!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n        vis[u] = false;\n        for (int i = head[u]; i != -1; i = edge[i].next)\n        {\n            int v = edge[i].to;\n\n            if (edge[i].cap > edge[i].flow && dis[v] > dis[u] + edge[i].cost)\n            {\n                dis[v] = dis[u] + edge[i].cost;\n                pre[v] = i;\n                if (!vis[v])\n                {\n                    vis[v] = true;\n                    q.push(v);\n                }\n            }\n        }\n    }\n    if (pre[t] == -1)\n        return false;\n    else\n        return true;\n}\n//返回的是最大流，cost存的是最小费用\nint minCostMaxflow(int s, int t, int &cost)\n{\n    int flow = 0;\n    cost = 0;\n    while (spfa(s, t))\n    {\n        int Min = INF;\n        for (int i = pre[t]; i != -1; i = pre[edge[i ^ 1].to])\n        {\n            if (Min > edge[i].cap - edge[i].flow)\n                Min = edge[i].cap - edge[i].flow;\n        }\n        for (int i = pre[t]; i != -1; i = pre[edge[i ^ 1].to])\n        {\n            edge[i].flow += Min;\n            edge[i ^ 1].flow -= Min;\n            cost += edge[i].cost * Min;\n        }\n        flow += Min;\n    }\n    return flow;\n}\n\nsigned main()\n{\n    int n, m, s, t;\n    read(n), read(m), read(s), read(t);\n    init(n);\n    for (int i = 1, a, b, c, d; i <= m; i++)\n    {\n        read(a), read(b), read(c), read(d);\n        addedge(a, b, c, d);\n    }\n    int mc = 0;\n    int mf = minCostMaxflow(s, t, mc);\n    cout << mf << ' ' << mc << endl;\n    return 0;\n}\n```\n\n- 79905993 テキサス(アークナイツ)\n\n![79905993](https://i.loli.net/2020/09/08/uRC841zNy9fhHvO.jpg)","tags":["图论"]},{"title":"CF#668div2总结","url":"/2020/09/07/CF668div2/","content":"\n\n\n换了个号，从零开始。\n\n\n\n<!--more-->\n\n## A. Permutation Forgery\n\n给出 $n$ 的一个排列 $p$，定义序列 $\\text{F}(p)=\\text{sort}(p_1+p_2,p_2+p_3,\\cdots,p_{n-1}+p_n)$，让你输出 $n$ 的另一个排列 $p'$ 满足 $\\text{F}(p)=\\text{F}(p')$。\n\n简单的构造题，第一个和最后一个元素只加一次，中间的都和相邻的加两次，所以把序列翻转过来以后的效果是一样的。\n\n```c++\nsigned main()\n{\n    int T;\n    read(T);\n    while (T--)\n    {\n        int n;\n        read(n);\n        v.clear();\n        for (int i = 1, x; i <= n; ++i)\n        {\n            read(x);\n            v.emplace_back(x);\n        }\n        for (int i = 1; i <= n; ++i)\n            printf(\"%d \", v[n - i]);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n```\n\n5分钟过的，不错的开局。\n\n## B. Array Cancellation\n\n给一个元素和为 $0$ 的序列，含有 $n$ 个元素，有两种操作：\n\n1. 选取不同位置的两个数，前一个减少 $1$，后一个增加 $1$，不消耗费用；\n2. 选取不同位置的两个数，前一个增加 $1$，后一个减少 $1$，消耗 $1$ 点费用。\n\n求通过以上两种操作把所有元素全部变成 $0$ 需要花费的最小费用。\n\n前缀和水题，由于和为 $0$，前面的正数一定可以和后面的负数免费消去，但是前面的负数必须要花费代价。\n\n```c++\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 1e5 + 9;\nll a[maxn];\nsigned main()\n{\n    int T;\n    read(T);\n    while (T--)\n    {\n        int n;\n        read(n);\n        ll tmp = 0, ans = 0;\n        for (int i = 1; i <= n; ++i)\n        {\n            read(a[i]);\n            tmp += a[i];\n            if (tmp < 0)\n            {\n                ans -= tmp;\n                tmp = 0;\n            }\n        }\n        cout << ans << '\\n';\n    }\n    return 0;\n}\n```\n\n12分钟的时候过的，当时排名大概900左右，还是不错的。\n\n## C. Balanced Bitstring\n\n给一个长度为 $n$ 的串，包含 `0`，`1`，`?` 三种字符，其中 `?` 可以转化为另外两种，给出间距 $k$，问该串的所有长度为 $k$ 的连续子段能否均满足 `0`，`1` 的数量相等。数据范围 $2\\le k \\le n \\le 3\\times 10^5$，保证 $k$ 为偶数，多组数据。\n\n看到这数据范围就知道暴力和搜索已经死透了，DP似乎也做不了，正解是贪心、模拟，但是打比赛的时候我想的是用双指针。我至今都觉得双指针比贪心更像是正解。\n\n不管用什么做法，首先要注意到一个不变量：如果区间 $[l,r-1]$ 与区间 $[l+1,r]$ 均满足题意，那么 $str[l]=str[r]$，这是显然的。所以我们可以先判断前 $k$ 个字符是否符合条件，然后一位一位向后检查即可。中间需要一些分类讨论。\n\n代码是比赛的时候写的，有点丑陋。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring s;\nint n, k;\nsigned main()\n{\n    int T;\n    cin >> T;\n    while (T--)\n    {\n        cin >> n >> k >> s;\n        bool flag = true;\n        int l = 0, r = k - 1;\n        int cnt0 = 0, cnt1 = 0, cntq = 0, cntq0 = 0, cntq1 = 0;\n        for (int i = 0; i < k; ++i)\n        {\n            if (s[i] == '0')\n                cnt0++;\n            else if (s[i] == '1')\n                cnt1++;\n            else\n                cntq++;\n        }\n        if (cnt1 > k / 2 || cnt0 > k / 2)\n        {\n            puts(\"NO\");\n            continue;\n        }\n        cntq0 = k / 2 - cnt0;\n        cntq1 = k / 2 - cnt1;\n        while (r < n - 1)\n        {\n            r++;\n            if (s[l] != '?' && s[r] != '?' && s[l] == s[r])\n            {\n                l++;\n                continue;\n            }\n            else if (s[l] != '?' && s[r] != '?' && s[l] != s[r])\n            {\n                puts(\"NO\");\n                flag = false;\n                break;\n            }\n            else if (s[l] == '?' && s[r] != '?')\n            {\n                if (s[r] == '0')\n                {\n                    cnt0++;\n                    cntq0--;\n                }\n                else\n                {\n                    cnt1++;\n                    cntq1--;\n                }\n                if (cnt1 > k / 2 || cnt0 > k / 2)\n                {\n                    puts(\"NO\");\n                    flag = false;\n                    break;\n                }\n                l++;\n                continue;\n            }\n            else if (s[l] != '?' && s[r] == '?')\n                s[r] = s[l];\n            else\n            {\n                l++;\n                continue;\n            }\n            l++;\n        }\n        if (flag)\n            puts(\"YES\");\n    }\n    return 0;\n}\n```\n\n如果能注意到题目中的一些不变量，往往可以用尺取法解决。\n\n这题拖到1小时多才过，排名已经下降了很多。\n\n## D. Tree Tag\n\n有一棵树，A和B在两个结点上，给出两人的速度，每人轮流走一步，在 $10^{100}$ 时间内A要是抓到B就A赢，否则B赢，问最后结果。显然 $10^{100}$ 可以看作无穷大了。样例很良心，可以看出A获胜有三种可能：\n\n1. A第一步直接抓到B；\n2. A追上B；\n3. A速度达到树的直径的一半，就可以站在树的中间，不管B在哪里都可以抓到。\n\n读完题目第一反应是求树的直径，但是之前没做过类似的题，所以代码写的很慢也很丑，快结束的时候总算过了样例，交上去WA2，凉凉。\n\n比赛结束后一看，思路没问题，树的直径也没求错，只是第二种情况的判断错了，非常可惜。\n\n求树的直径一般用两次DFS或树形DP，显然这里需要DFS，我也只会DFS，第一次以A为根搜索出最远结点P并得到AB距离，判断第一个条件，然后从P开始DFS求出直径，判断第三个条件。问题在于第二个条件：事实上，只要 $2\\times v_a\\ge v_b$，A就可以追上B，因为A只要不断把B赶到叶子结点就可以了。\n\n可惜当时没考虑到这个简单的情况，判断的是 $v_a\\ge v_b$，令人恼火。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 2e5 + 9;\n\nint a[maxn], d[maxn];\nvi g[maxn];\nbool vis[maxn];\nvoid dfs1(int pos, int dep)\n{\n    vis[pos] = 1;\n    d[pos] = dep;\n    for (auto i : g[pos])\n        if (!vis[i])\n            dfs1(i, dep + 1);\n}\n\nsigned main()\n{\n    int T;\n    read(T);\n    while (T--)\n    {\n        int n, a, b, da, db;\n        bool flag = false;\n        read(n), read(a), read(b), read(da), read(db);\n        for (int i = 1, u, v; i < n; ++i)\n        {\n            read(u), read(v);\n            g[u].emplace_back(v);\n            g[v].emplace_back(u);\n        }\n        if (db < 2 * da + 1)\n            flag = true;\n        memset(vis, 0, sizeof(vis));\n        dfs1(a, 0);\n        if (d[b] <= da)\n            flag = true;\n        int p = 0, maxd = 0;\n        for (int i = 1; i <= n; ++i)\n            if (d[i] > maxd)\n                maxd = d[i], p = i;\n        memset(vis, 0, sizeof(vis));\n        dfs1(p, 0);\n        int maxr = *max_element(d + 1, d + 1 + n);\n        maxr++;\n        if (maxr / 2 <= da)\n            flag = true;\n        if (flag)\n            puts(\"Alice\");\n        else\n            puts(\"Bob\");\n        for (int i = 1; i <= n; ++i)\n            g[i].clear();\n    }\n    return 0;\n}\n```\n\n其实代码非常好写。\n\n## E. Fixed Point Removal\n\n给一个长度为 $n$ 的序列并给出其中元素的值，$q$ 次询问，每次固定区间 $[1,l]$ 和 $[n-r+1,n]$ 的元素，然后不断去掉大小等于序列位置的元素并连接成新序列，求最多可以去掉多少个元素。$1\\le n,q \\le 3\\times 10^5$。\n\n显然，如果同时可以删除多个元素，从后往前删除。预处理用 $i-a_i$ 替换 $a_i$ 并转化成区间 $[l+1,n-r]$ 来做也会方便很多。\n\n这些准备工作做好以后用线段树或树状数组维护，然后二分求答案。\n\n代码改日再补。\n\n## 总结\n\n又是差一点过4题，非常可惜。CD写的太慢了，如果写快一些还可以留出自己造数据的时间，D题的错误还是不难发现的。之前并没有做过求树的直径的题目，接下来要多扩充一下做题的范围。洛谷绿题以下难度的题目尽量不要做了，手速可以通过打ABC和div3来练。\n\n- 84140181 カグラナナ\n\n![84140181](https://i.loli.net/2020/09/07/Pjg8O5MECbzlvwk.jpg)\n\n","tags":["CodeForces"]},{"title":"最大流","url":"/2020/09/05/Maximum_Flow/","content":"\n\n\n整理了一下网络流最基础的概念。\n\n\n\n<!--more-->\n\n# 基本概念\n\n和拓扑排序类似，有向无自环连通图，有一个源点 $S$，一个汇点 $T$。\n\n每条边有一个容量 $c$。\n\n## 性质\n\n显而易见的三个性质：\n\n- 容量限制：$\\large f_{(u,v)}\\le c_{(u,v)}$，每条边的流量当然不会超过其容量；\n- 斜对称性：$\\large f_{(u,v)}=- f_{(v,u)}$，流出了 $f$ 自然就相当于流入了 $-f$；\n- 流量平衡：除了源点和汇点外的任意结点 $u$，$\\large\\sum_{(u,v)\\in E}f_{(u,v)}=0$，就像基尔霍夫电流定律一样。\n\n## 容许流\n\n对于每条边 $e$，给一个流量 $f_e$ 满足 $f_e\\le c_e$，由于存在流量平衡，令总流量 $W=\\sum_{e=(S,i)}f_e=\\sum_{e=(i,T)}f_e$，这样的一组 $f$ 称为该网络的一个容许流。\n\n总流量 $W$ 最大的容许流就是该网络的最大流，显然最大流可能不是唯一的。\n\n## 残余容量\n\n在选取了某个容许流之后，将这个容许流经过的每条边的容量减去相应的流量，剩下的容量就是残余容量（残量）。\n\n网络中所有节点以及剩余容量大于 $0$ 的边构成的子图被称为残量网络。\n\n## 增广路\n\n从源点到汇点的一条残量均大于 $0$ 的路径被称为增广路。\n\n增广路定理：只要残量网络中存在增广路，总流量就可以增大，当不存在增广路的时候当前流也就是最大流了。\n\n## 反向弧\n\n一条边可能被包含于多条增广路中，如果通过不断寻找增广路来求最大流，我们要让一条边拥有被多次选择的机会。\n\n为了解决这个问题，可以给每条边建立一条反向边，初始流量为 $0$，当某条边流出 $f$ 流量时，给它的反向边增加 $f$ 的流量，这样就相当于提供了反悔的机会。\n\n# 算法\n\n$n$ 个点，$m$ 条边，最大流 $f$\n\n## Ford-Fulkerson算法\n\n就是上面说的通过不断找增广路来求最大流的方法，通过DFS实现，时间复杂度 $O(mf)$。\n\n由于复杂度与最大流有关，在数据比较极端的情况下，FF算法的表现会非常离谱。\n\n所以这个算法并没有什么用处。\n\n## Edmond-Karp算法\n\n这是BFS实现的FF算法，每次找到的是最短的增广路，时间复杂度 $O(nm^2)$，看起来稍微靠谱了一点，但是还是会被卡掉。\n\n代码参考紫书。\n\n```c++\nstruct edge\n{\n    int from, to, cap, flow;\n    edge(int u, int v, int c, int f) : from(u), to(v), cap(c), flow(f) {}\n};\nstruct EK\n{\n    int n, m;\n    vector<edge> e;\n    vi g[maxn];\n    int a[maxn], p[maxn];\n    void init(int n)\n    {\n        for (int i = 1; i <= n; ++i)\n            g[i].clear();\n        e.clear();\n    }\n    void add(int from, int to, int cap)\n    {\n        e.push_back(edge(from, to, cap, 0));\n        e.push_back(edge(to, from, 0, 0));\n        m = e.size();\n        g[from].push_back(m - 2);\n        g[to].push_back(m - 1);\n    }\n    ll maxflow(int s, int t)\n    {\n        ll flow = 0;\n        for (;;)\n        {\n            memset(a, 0, sizeof(a));\n            queue<int> q;\n            q.push(s);\n            a[s] = inf;\n            int cnt = 0;\n            while (!q.empty())\n            {\n                int x = q.front();\n                q.pop();\n                for (int i = 0; i < g[x].size(); ++i)\n                {\n                    edge &eg = e[g[x][i]];\n                    if (!a[eg.to] && eg.cap > eg.flow)\n                    {\n                        p[eg.to] = g[x][i];\n                        a[eg.to] = min(a[x], eg.cap - eg.flow);\n                        q.push(eg.to);\n                    }\n                }\n                if (a[t])\n                    break;\n            }\n            if (!a[t])\n                break;\n            for (int u = t; u != s; u = e[p[u]].from)\n            {\n                e[p[u]].flow += a[t];\n                e[p[u] ^ 1].flow -= a[t];\n            }\n            flow += a[t];\n        }\n        return flow;\n    }\n};\nEK solve;\nsigned main()\n{\n    int m, s, t;\n    read(solve.n), read(m), read(s), read(t);\n    solve.init(solve.n);\n    for (int i = 1; i <= m; ++i)\n    {\n        int u, v, w;\n        read(u), read(v), read(w);\n        solve.add(u, v, w);\n    }\n    cout << solve.maxflow(s, t) << '\\n';\n    return 0;\n}\n```\n\n## Dinic算法\n\n这是对EK算法的优化，先用BFS分层，预处理出源点到每个点的距离，再用DFS寻找。\n\n分层会带来的两点好处：\n\n1. 如果不存在到汇点的增广路，就可以停止增广；\n2. 确保找到最短的增广路；\n\n两个优化：\n\n1. 多路增广：每找到一条增广路，如果残量还未用完就再找一条增广路，这样可以在一次DFS中找到多条增广路；\n2. 当前弧优化：如果一条边被增广过了，就不会被增广第二次，下次就不用经过这条边了。\n\n该算法的时间复杂度 $O(n^2m)$，在稠密图上的表现比EK算法好很多。\n\n在求解二分图最大匹配问题时，Dinic算法的时间复杂度是 $O(m\\sqrt n)$，比匈牙利算法更优秀。\n\n模板来自[OI wiki](https://oi-wiki.org/graph/flow/max-flow/)。\n\n```c++\nstruct Edge\n{\n    int from, to, cap, flow;\n    Edge(int u, int v, int c, int f) : from(u), to(v), cap(c), flow(f) {}\n};\n\nstruct Dinic\n{\n    int n, m, s, t;\n    vector<Edge> edges;\n    vector<int> G[maxn];\n    int d[maxn], cur[maxn];\n    bool vis[maxn];\n    void init(int n)\n    {\n        for (int i = 0; i < n; i++)\n            G[i].clear();\n        edges.clear();\n    }\n    void AddEdge(int from, int to, int cap)\n    {\n        edges.push_back(Edge(from, to, cap, 0));\n        edges.push_back(Edge(to, from, 0, 0));\n        m = edges.size();\n        G[from].push_back(m - 2);\n        G[to].push_back(m - 1);\n    }\n    bool BFS()\n    {\n        memset(vis, 0, sizeof(vis));\n        queue<int> Q;\n        Q.push(s);\n        d[s] = 0;\n        vis[s] = 1;\n        while (!Q.empty())\n        {\n            int x = Q.front();\n            Q.pop();\n            for (int i = 0; i < G[x].size(); i++)\n            {\n                Edge &e = edges[G[x][i]];\n                if (!vis[e.to] && e.cap > e.flow)\n                {\n                    vis[e.to] = 1;\n                    d[e.to] = d[x] + 1;\n                    Q.push(e.to);\n                }\n            }\n        }\n        return vis[t];\n    }\n    int DFS(int x, int a)\n    {\n        if (x == t || a == 0)\n            return a;\n        int flow = 0, f;\n        for (int &i = cur[x]; i < G[x].size(); i++)\n        {\n            Edge &e = edges[G[x][i]];\n            if (d[x] + 1 == d[e.to] && (f = DFS(e.to, min(a, e.cap - e.flow))) > 0)\n            {\n                e.flow += f;\n                edges[G[x][i] ^ 1].flow -= f;\n                flow += f;\n                a -= f;\n                if (a == 0)\n                    break;\n            }\n        }\n        return flow;\n    }\n    int Maxflow(int s, int t)\n    {\n        this->s = s;\n        this->t = t;\n        int flow = 0;\n        while (BFS())\n        {\n            memset(cur, 0, sizeof(cur));\n            flow += DFS(s, INF);\n        }\n        return flow;\n    }\n};\n```\n\n## 更高级的算法\n\n更强的优化：ISAP\n\n预流推进算法：HLPP\n\n这两个以后再说。\n\n# 最大流最小割定理\n\n割，就是去掉网络中的一些边使得源点到汇点不再连通。\n\n割的大小是这些去掉的边的容量之和，在所有可行的割中，容量和最小的被称为最小割。\n\n**最大流最小割定理：最大流等于最小割**\n\n因此，任意流不大于任意割。\n\n- 83800932\n\n![83800932](https://i.loli.net/2020/09/05/OAsfXIQBwocSazH.jpg)\n\n\n\n虽然最大流的算法比较好理解，但是每到用的时候都很不熟练。","tags":["图论"]},{"title":"C++作业预想","url":"/2020/09/03/International_Draughts/","content":"\n\n\nC++的信息技术基础认知与实践课需要做一个有图形界面的游戏。棋类游戏的图形界面比较好做，所以我打算做个国际跳棋游戏。\n\n\n\n<!--more-->\n\n## 综述\n\n小学的时候练过一段时间国际跳棋，规则很简单，算法应该不是很难写。先来看规则（波兰规则）：\n\n1. **棋盘：**$10 \\times 10$ 棋盘，相邻格子异色，每人左下角第一个是深色格子，只有深色格子可以落子；\n2. **棋子：**每一方20个子，从下往上四排；\n3. **行棋：**兵只能向左前方或右前方的空格行动，王棋的行动方式与国际象棋的主教完全相同；\n4. **吃子：**在自己行棋路径上如果存在后方没有棋子或棋盘边界支撑的敌方棋子就需要进行吃子操作，走到被吃掉的棋子的后方空位中：\n   1. 只能吃掉敌方棋子，不能跳过己方棋子；\n   2. 有吃必吃，当可以吃子的时候必须选择一条吃子路径；\n   3. 有多吃多，必须选择吃子数量最多的路径（之一）；\n   4. 土耳其打击，即不能重复吃掉一个子；\n5. **升变：**兵在一次行棋后停留在敌方底线就会升变为王棋；\n6. **胜负结算：**如果一方失去所有棋子或无法继续行棋则判负。\n\n规则比较简单，用一个二维数组存放棋盘可以比较好的模拟行棋的过程。\n\n接下来需要考虑如何具体实现。\n\n## 图形界面\n\n本来棋盘这样的东西是很适合用easyx库来画的，但是这次好像一定要面向对象，做Windows桌面应用，事情就变得复杂起来了。\n\n上课演示的VC6.0已经被淘汰太久了，和现在的VS差别巨大，所以还是要自己探索。\n\n这部分等搞明白了再更新。\n\n## 算法\n\n需要写一个AI程序，太强的也写不出来，反正这作业对算法方面的要求也几乎没有，只要写一个并不是特别蠢就可以了。\n\n由于每次行棋的合法选择很少，所以可以考虑搜索：\n\n1. 找出可能的行棋路径\n   1. 判断是否存在吃子情况，如果存在，搜索出若干条最大吃子路径\n   2. 如果不存在，找出可行路径（一般不会超过20种）\n2. 局势判断\n   1. 找出对方的可行送吃路径（一般不会超过5种），计算子力交换后双方的局势，如果会导致局势对己方的不利程度超过阈值则选取避免对方送吃的路径；\n   2. 找出己方的可行送吃路径（一般不会超过5种），计算子力交换后双方的局势，如果会导致局势对己方的有利程度超过阈值则选择最大的此种路径；\n   3. 计算棋子的个数、位置价值之和与密集程度，生成该时刻的局势，选取剩余路径中对局势影响最优的一条。\n3. 优化\n   1. 在局势判断的前2条中，可以使用迭代加深搜索，选取一个较为合适的预测对方的步数作为最大深度；\n   2. 增加残局特殊策略；\n   3. 优化局势计算函数。\n\n等图形界面搞好了再写成代码。\n\n![82229673](https://i.loli.net/2020/09/03/DE946d5NxMIfkih.jpg)\n\n\n\n","tags":["其它"]},{"title":"关于博客","url":"/2020/09/01/main/","content":"\n此帖置顶\n\n<!--more-->\n\n这里有各种乱七八糟的东西\n\n内容很少的[CSDN博客](https://me.csdn.net/Pastafarian)\n\n两个CF帐号\n\n[![](https://cfrating.ihcr.top/?user=_Watson&style=for-the-badge)](https://codeforces.com/profile/_Watson)\n\n\n[![](https://cfrating.ihcr.top/?user=Watson_2020&style=for-the-badge)](https://codeforces.com/profile/Watson_2020)\n\n[AtCoder](https://atcoder.jp/users/Kutori)\n\n### 本月待办\n\n1. 配置 $\\TeX$ 环境，整理模板\n2. 少做水题，每天至少做一道蓝题\n3. 学数论和计算几何\n4. 练一练DP\n5. cf上分\n\n### 代码起手式\n\n- C++11\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\n//* C++ 11\ntemplate <typename T, typename... Args>\ninline void read(T &t, Args &... args)\n{\n    read(t);\n    read(args...);\n}\n\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 1e4 + 9;\n\nsigned main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"data.txt\",\"w\",stdout);\n    //std::ios::sync_with_stdio(false);\n    //std::cin.tie(0);\n    //std::cout.tie(0);\n    \n    //fclose(stdin);\n    //fclose(stdout);\n    return 0;\n}\n```\n\n\n\n### 彩虹\n\n![](https://i.loli.net/2020/02/02/FaQY4pvPuTi2W9S.png)\n\n### 洛谷\n\n| 难度          | 数量 |\n| ------------- | ---- |\n| 暂无评定      | 9    |\n| 入门          | 47   |\n| 普及-         | 73   |\n| 普及/提高-    | 86   |\n| 普及+/提高    | 43   |\n| 提高+/省选-   | 41   |\n| 省选/NOI-     | 6    |\n| NOI/NOI+/CTSC | 1    |\n\n\n\n\n### 统计\n\n| 时间       | 成就      |\n| ---------- | --------- |\n| 2019.11.6  | 做完NOJ   |\n| 2019.11.24 | 洛谷橙名  |\n| 2020.1.15  | 洛谷AC100 |\n| 2020.7.14  | 洛谷AC200 |\n| 2020.9.4   | 洛谷AC300 |\n| 2020.9.5   | cf蓝名    |\n\n\n","tags":["其它"]},{"title":"2020年度大更新","url":"/2020/09/01/2020update/","content":"\n\n\n主题更新完毕，一些隐藏的问题可能会逐渐暴露出来。\n\n\n\n<!--more-->\n\n## 主题\n\n`landscape`->`stun`\n\n增加功能（理论上）：\n\n- 文章置顶\n- 头像\n- 分享链接\n- 友链\n- 背景图片与特效\n- 搜索（可能存在一些问题，已关闭）\n- 夜间模式\n- 显示最后修改时间\n- 代码复制\n- ......\n\n待修复问题：\n\n- 数学公式无法正确渲染（修复完毕）\n  - 因此上半年的博客暂时撤下\n- live2D动画无法显示\n  - 需要使用Git进行一些操作\n  - 珂朵莉装不上了，装miku吧\n- 头像等图片无法正常显示\n  - 调试yml文件（修复完毕）\n- ......\n\n\n\n## 模板更新\n\n1. `math: true` 代替原先的 `mathjax: true`\n2. 置顶：`top: true`\n3. 最后修改时间：`updated: YYYY-MM-DD`\n\n[参考文档](https://liuyib.github.io/hexo-theme-stun/zh-CN/guide/quick-start.html)\n\n## 维修记录\n\n### 主题更换\n\n安装主题：`git clone https://github.com/liuyib/hexo-theme-stun.git themes/stun`\n\n修改博客的 `yml` 文件更换主题。\n\n大部分操作可以在上面的文档中找到。\n\n### 修复数学公式渲染问题\n\n我的大多数博客中都有内联公式，因此这是我首先需要解决的问题。\n\n记得在刚使用 `landscape` 主题的时候也遇到过公式无法渲染的问题，当时的解决方法是根据[这篇博客](https://www.jianshu.com/p/7ab21c7f0674)说的修改了一下一个配置文件。但是之前照着文档里说的把 `hexo-renderer-kramed` 引擎卸载了，装了一个新的，新引擎相应的配置文件并没有找到，所以我还是把新的卸掉了，把 `hexo-renderer-kramed` 装了回来。\n\n然后找到 `node_modules\\kramed\\lib\\rules\\inline.js`，把其中的\n\n```javascript\nescape: /^\\\\([\\\\`*{}\\[\\]()#$+\\-.!_>])/,\n```\n\n改成\n\n```javascript\nescape: /^\\\\([`*\\[\\]()#$+\\-.!_>])/,\n```\n\n并把\n\n```javascript\nem: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n```\n\n改成\n\n```javascript\nem: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/\n```\n\n然后就可以了。\n\n### live2D\n\n本来想装[珂朵莉](https://github.com/phlzy/chtholly_kanban)的，但是装不上去，所以只好装miku了\n\n首先，`npm install --save hexo-helper-live2d`，安装\n\n然后在hexo的 `__config.yml` 中增加\n\n```yml\n# Live2D \n## https://github.com/EYHN/hexo-helper-live2d \nlive2d:\n  # enable: true \n  # enable: false\n  scriptFrom: local # 默认 \n  pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径) \n  pluginJsPath: lib/ # 脚本文件相对与插件根目录路径 \n  pluginModelPath: assets/ # 模型文件相对与插件根目录路径 \n  # scriptFrom: jsdelivr # jsdelivr CDN \n  # scriptFrom: unpkg # unpkg CDN \n  # scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js \n  # 你的自定义 url \n  tagMode: false \n  # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中 \n  debug: false \n  # 调试, 是否在控制台输出日志 \n  model: \n    # scale: 1\n    # use: /assets/chtholly.model.json\n    use: live2d-widget-model-miku\n    # npm-module package name \n    # use: wanko # 博客根目录/live2d_models/ 下的目录名 \n    # use: ./source/live2d/wanko # 相对于博客根目录的路径 \n    # use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url \n    display: \n      position: right\n      width: 150 \n      height: 300 \n    mobile: \n      show: true\n      # 手机中是否展示 \n      scale: 0.5\n```\n\n然后 `npm install live2d-widget-model-miku`\n\n就完成了\n\n### 图片修改\n\n修改头像、网页标签等，用PS改一改就好了\n\n### 评论区\n\n[注册](https://github.com/settings/applications/new)并按照要求填写，然后修改yml相关内容\n\n按照[这篇博客](https://blog.csdn.net/Mart1nn/article/details/87478971)调整可以修复 `Error: Not found` 的问题\n\n### 其他\n\n搜索、阅读量统计等，参考文档即可\n\n头像出处：\n\n![Chtholly](https://i.loli.net/2020/09/01/JRAGqP42Kohb3Tw.jpg)\n\n基本上就是这样了\n\n## 后记\n\n### cmd的问题\n\n出现了名为 `Spawn failed` 的错误，似乎是找不到仓库了，上网查了一下解决方案，发现问题出在Windows的cmd上面。\n\n解决方法如下：\n\n1. 打开Git，输入 `cd` 和 `.deploy_git` 文件夹的路径，打开这个文件夹\n2. 输入 `git log` 查看日志\n3. 输入 `q` 退出日志状态\n4. 找到对应的版本id，输入 `git reset --hard id`，或者根据顺序用 `git reset --hard HEAD^` 来回退到上一个正常的版本\n5. `hexo clean`，`hexo g`，`hexo d` 正常更新一遍\n6. 抛弃cmd，以后使用Git进行更新\n\n### 卸载搜索功能\n\n`npm un hexo-algolia --save`","tags":["其它"]},{"title":"有趣的图论和数据结构等","url":"/2020/08/31/2020-8-index/","content":"\n\n\n计划每天学一个新东西，比赛多的时候就写简单的或者不重要的，别的就在比赛少的时候写。反正是写给自己看，有些有趣的数据结构也就写一写当做娱乐好了。\n\n\n\n<!--more-->\n\n|                        内容（原计划）                        |    更新版    |\n| :----------------------------------------------------------: | :----------: |\n|        [LCA](https://phlzy.github.io/2020/08/14/LCA/)        |              |\n| [DFS序，树链剖分](https://phlzy.github.io/2020/08/18/path_decomposition/) |              |\n|  [左偏树](https://phlzy.github.io/2020/08/16/Leftist_Tree/)  |              |\n|                            扫描线                            |              |\n|                        ~~各种生成树~~                        | 计算几何基础 |\n| [zkw线段树](https://phlzy.github.io/2020/08/19/zkw_Segment_Tree/) |              |\n|                            划分树                            |              |\n|                      ~~可持久化线段树~~                      |   旋转卡壳   |\n|                            伸展树                            |              |\n|                        ~~FHQ-Treap~~                         |   半平面交   |\n|                           ~~斜堆~~                           |  Lucas定理   |\n|                          ~~点分治~~                          |   排列组合   |\n|                          ~~树套树~~                          |              |\n|                           ~~LCT~~                            |              |\n|                          ~~Tarjan~~                          |              |\n|                          ~~网络流~~                          |              |\n\n\n\n顺便放上[模板的链接](https://phlzy.github.io/2020/08/12/Template/)\n\n[踩过的坑](https://phlzy.github.io/2020/08/19/Tips/)\n\n\n\n![阿尔托莉雅](https://i.loli.net/2020/08/19/38fVQGqbd6BZKIe.jpg)\n\n\n\n## 8月23日更新\n\n- 练一练大模拟题\n- 继续多打cf和ATCoder\n- 计算几何\n- 数论、概率论\n- 剩余时间（重要性递减）\n  - 英语（反正也要考六级了）\n  - 数据结构科技\n  - DP\n  - 博弈论\n  - 图论（树上操作，网络流等）\n  - 字符串（自动机，后缀科技）\n\n","tags":["其它"]},{"title":"关于游泳","url":"/2020/08/31/swim/","content":"\n\n是时候，该为我近十五年的游泳运动生涯画上句号了。\n\n\n\n<!--more-->\n\n昨天晚上快要打cf的比赛的时候，学校游泳队的队长大哥问我脚蹼尺码，当时比较忙没有马上回复，直到打完比赛在微信上打字的时候，我突然意识到，这将近15年的游泳运动生涯，似乎是真的结束了。\n\n退出校游泳队的想法并不是昨天突然萌生的，而是在几个月前早就有了，当时由于受到疫情影响游泳队一个学期都没有训练，我也没有提出这个想法。吴清源说的“不搏二兔”我觉得非常有道理，既然我选择将几乎全部业余时间用于ACM的训练，每周一个上午的游泳训练也自然需要放弃了。\n\n虽然我从未真正从心里喜欢过游泳这项运动，小时候也曾多次寻找机会试图放弃，但是毕竟是比较专业的练了五六年，最近几年也有几次比赛需要参加，说完全没有感情也是不可能的。当年在体育场的体能训练、备战市运会的一天双练、打酱油的迎春杯省赛等场景仍然历历在目。大学游泳队的氛围也很好，我在之前的训练中对我们学校游泳队的水平可以说非常了解，作为游泳队的主力，这样退役让我心怀愧疚，但是我必须这么做。\n\n三四年前我虽然已经很久没有训练，但是在自己调整了不到一周后，我的50米自由泳依然可以冲到28秒，还是可以带领团队拿到金牌。自由泳并不是我小时候练的主项，但是三年前的我，称一句“宝刀未老”，应该也不算太过。可是大半年前，在校队训练了几次的我50米自由泳仍然无法游进30秒，虽然客观上泳池规格、出发形式以及赛程都对成绩有影响，但是我的状态确实是不复当年了。又过了大半年，以我目前的竞技状态，也只能在校队中表现一下，如果代表学校外出比赛，必然是没有什么希望的。\n\n本来我的游泳运动生涯可能在几年前选择了学业就早早结束了，但是比赛总是阴魂不散，说不定什么时候，就要重新回去训练一下，应付比赛了。这一次，应该是真的结束了。\n\n还记得小时候父亲逼我坚持练游泳，他不止一次对我说，他并不希望我今后成为职业运动员，但是希望我能够熟练掌握游泳的技能，并获得强健的体魄。在他看来，学会游泳不仅多了一项求生的工具，也多了一种爱好、多掌握了一种门技术。从某种角度来说，他说的并没有问题，但是仔细想想，似乎也并不是那么回事。如今我确实掌握了各种游泳的技术，可能在人群中，能在泳池中超过我的人不到千分之一，但是这只是在泳池的理想环境中，如果在洪水中、海里或是任何未知的水域中，我和绝大多数普通人并没有太大的区别。在湍急的水流中，即便是奥运冠军也不能保证自己的安全。游泳的技能在这十多年中，也并没有给我带来多少好处，除了大一上学期免去了体育锻炼课与30次打卡，就是那几块几乎毫无价值的奖牌，剩下能让我长久铭记的，可能是十年前两次急性肠胃炎的滋味。\n\n对别人来说，游泳代表的可能是夏日的清凉，是暑假的悠闲，是玩水的快乐，而这些对我来说几乎都没有。我并不喜欢去游泳，我更喜欢待在家里，做我想做的事情。\n\n有人觉得，被ACM束缚的大学生活，很亏。我觉得不然。高中的时候比较喜欢化学，也曾希望未来从事化学方面的工作，是因为学习化学的时候我可以感受到化学的美，感受到自然规律的巧妙。由于种种原因，我最终也没有选择化学相关的专业，当年的梦想现在已经用来追忆了。在学习其它科目的过程中，我并不能感受到那种知识的美妙之处，直到接触到了这些算法与数据结构，这是与化学不同的美，是人类用智慧创造出的精妙理论之美。我终于和当年一样，在学习知识的时候能够重新给自己正向的反馈，而不是觉得在浪费自己的生命。\n\n人的生命非常有限，我也只是一个普通人，我很清楚的知道想达到像Tarjan、Dijkstra这样的成就几乎是不可能的，我只希望，我能在我愿意研究的领域中，留下一点探索的痕迹，在未来有和我同样兴趣的人探索到这个地方的时候，能够欣慰的说，原来从前也有这样的一个人和我一样走到了这里，看到了这里的奥秘。如果能够做到这样，我想我生命的价值也就达到了。\n\n总是有人说什么艺多不压身，说到底还是在欺骗自己，人的时间是有限的，搞的好像自己会了很多东西，学一身三脚猫功夫，什么事情都做不好，还让自己看起来很忙很努力，真是毫无意义。几百年前还有所谓的“全才”，后来就没有了，也证明了这个观点。国内有理论计算机科学方向的大学非常少，我也不想在我不感兴趣的东西上浪费我的时间，所以我今后也并不怎么想读研。以后怎样，就随他去吧。\n\n一想到以后可以少做一件不怎么感兴趣的事，多了一些时间追求目前的理想，也就畅快了不少。理想屈服于现实的感受，真的不怎么样，我也不希望再体会一次。\n\n![hikaru](https://i.loli.net/2020/08/31/Vr8IknRaj2SvfGx.png)\n\n在这里放这张图真是再合适不过了","tags":["随笔"]},{"title":"AtCoder Beginner Contest 177","url":"/2020/08/29/ABC177/","content":"\n\n\n虽然题目很水，但是。。。\n\n\n\n<!--more-->\n\n## A\n\n显然\n\n```c++\nll a, b, c;\ncin >> a >> b >> c;\nif (b * c >= a)\n    cout << \"Yes\" << endl;\nelse\n    cout << \"No\" << endl;\n```\n\n## B\n\n看数据范围，直接暴力\n\n```c++\nstring s, t;\ncin >> s >> t;\nint ans = inf;\nint a = s.length(), b = t.length();\nfor (int i = 0; i < a; ++i)\n{\n    int cnt = 0;\n    if (i + b - 1 >= a)\n        break;\n    for (int j = 0; j < b; ++j)\n        if (s[i + j] != t[j])\n            cnt++;\n    ans = min(ans, cnt);\n}\n```\n\n## C\n\n式子都给你了，无脑前缀和，居然Wa了两发，真的傻逼\n\n```c++\nint n;\nread(n);\nfor (int i = 1; i <= n; ++i)\n{\n    read(a[i]);\n    s[i] = (s[i - 1] + a[i]);\n}\nll ans = 0;\nfor (int i = 1; i < n; ++i)\n{\n    ans += a[i] * ((s[n] - s[i]) % mod) % mod;\n    ans %= mod;\n}\ncout << ans % mod << endl;\n```\n\n算前缀和的时候不要取模，这种地方也能错也是没谁了\n\n## D\n\n并查集裸题，求最大集合的大小\n\n```c++\nint fa[maxn], a[maxn];\nint findfa(int x)\n{\n    return fa[x] == x ? x : fa[x] = findfa(fa[x]);\n}\nvoid join(int x, int y)\n{\n    int fx = findfa(x), fy = findfa(y);\n    if (fx != fy)\n        fa[fx] = fy;\n}\nmap<int, int> mp;\nsigned main()\n{\n    int m, n;\n    read(m), read(n);\n    for (int i = 1; i <= m; ++i)\n        fa[i] = i;\n    for (int i = 1; i <= n; ++i)\n    {\n        int u, v;\n        read(u), read(v);\n        join(u, v);\n    }\n    int ans = 0;\n    for (int i = 1; i <= m; ++i)\n    {\n        findfa(i);\n        mp[fa[i]]++;\n        ans = max(ans, mp[fa[i]]);\n    }\n    cout << ans << endl;\n    return 0;\n}\n```\n\n自己写的时候路径压缩还写错了一次，虽然很快就改对了\n\n## E\n\n虽然秒出了正解，但是一直没调对。。。\n\n显然，如果是 `pairwise coprime` 的，说明任意两个不同元素不会有相同质因子，那么用欧拉筛先找出范围内所有质因子然后进行一遍匹配，如果某个质因子匹配到的元素个数超过一个就说明不符合条件。剩下两种情况直接 $O(n)$ 跑一遍就好了。\n\n稍微观察一下就可以发现，上面的匹配过程和埃氏筛的原理差不多，复杂度是 $O(n\\log n)$ 的，没有任何问题。\n\n所以，为什么我在一个小时中尝试了各种写法，但是一次都没过呢？\n\n我居然用欧拉筛找的是 $[1,\\sqrt n]$ 区间中的质数！\n\n真服了。\n\n还有，这题会爆int。\n\n```c++\nconst int maxn = 1e6 + 9;\nbitset<maxn> num;\nvector<int> prime;\ninline void init(int n)\n{\n    for (int i = 2; i <= n; ++i)\n    {\n        if (!num[i])\n            prime.push_back(i);\n        for (int j = 0; j < prime.size(); ++j)\n        {\n            if (i * prime[j] >= n)\n                break;\n            num[i * prime[j]] = 1;\n            if (i % prime[j] == 0)\n                break;\n        }\n    }\n}\nvector<ll> v;\nunordered_map<ll, int> ump;\nint main()\n{\n    init(1000000);\n    int sz = prime.size();\n    int n;\n    ll maxx = 0;\n    read(n);\n    bool flag = true;\n    for (int i = 1; i <= n; ++i)\n    {\n        ll x;\n        maxx = max(maxx, x);\n        read(x);\n        ump[x]++;\n        v.emplace_back(x);\n    }\n    for (int i = 0; i < sz; ++i)\n    {\n        int tot = 0;\n        for (int j = 1;; ++j)\n        {\n            if (1LL * j * prime[i] > 1LL * maxx)\n                break;\n            tot += ump[j * prime[i]];\n        }\n        if (tot > 1)\n        {\n            flag = false;\n            break;\n        }\n    }\n    if (flag)\n    {\n        cout << \"pairwise coprime\" << endl;\n        return 0;\n    }\n    ll g = v[0];\n    for (int i = 1; i < n; ++i)\n        g = __gcd(g, v[i]);\n    if (g == 1)\n        cout << \"setwise coprime\" << endl;\n    else\n        cout << \"not coprime\" << endl;\n    return 0;\n}\n```\n\n这也从侧面证明了队友的重要性。当局者迷，旁观者清，要是有队友在场这种题可能十分钟就过了。\n\n当然，总是出这种傻逼错误也是很需要反省的。\n\n第二天回来一看，这题不仅可以这样做，甚至连 $O(n\\sqrt n)$ 的暴力做法也能过，这就更让人恼火了。\n\n## F\n\n有趣的题目，有趣的做法。\n\n有人用两棵线段树做，也有人用一个 `map` 和一个 `multiset`。下面的这份代码看得我似懂非懂，过两天回头再来看看。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nmap<int, int> m;\nmultiset<int> s;\nint main(){\n    int h, w, a, b;\n    cin >> h >> w;\n    for (int i = 0; i < w; i++)\n        m[i] = i, s.insert(0);\n    for (int i = 0; i < h; i++){\n        cin >> a >> b;\n        a--;\n        auto pos = m.lower_bound(a);\n        int mx = -1;\n        while (pos != m.end() && pos->first <= b){\n            mx = max(mx, pos->second);\n            int x = pos->first - pos->second;\n            s.erase(s.find(x));\n            m.erase(pos++);\n        }\n        if (mx != -1 && b < w){\n            s.insert(b - mx);\n            m[b] = mx;\n        }\n        cout << (s.empty() ? -1 : *s.begin() + i + 1) << endl;\n    }\n    return 0;\n}\n```\n\n根据代码大概可以知道 `multiset` 中存储的是最短水平移动距离，`map` 中的可能是水平移动的起点，并不是很确定。\n\n## 总结\n\n最近两场ABC都是至少可以过5题的，但是目标并没有达到。\n\n虽然ABC大部分题目难度很低，但是刷水题并不是没有意义，多打打这样的比赛可以提升速度与debug能力，也能巩固一些基础知识，还能维持一下比赛的状态。\n\n组队赛告一段落，我们最终排名第四，有点危险。\n\nCCF认证还有两个星期，不知道考什么，这两天还是先全面发展，看看图论和数学好了。这种考试也不可能考很难的数据结构之类的东西。\n\n暑假只剩最后一场cf，差32分上蓝。能不能完成之前立的flag，就看这次的发挥了。虽然说正常发挥的话只要把前三题比较快的过掉，基本就能达到目的了，但是我的状态波动也很大，结果如何还未尝可知。\n\n不管怎样，上蓝是迟早的事，新学期要到了，立一个新的flag，学期结束前上紫。\n\n让我们拭目以待。\n\n![83590230](https://i.loli.net/2020/08/30/nw3GJg8kPUKSBZV.jpg)","tags":["AtCoder"]},{"title":"Splay区间操作","url":"/2020/08/29/Splay_beta/","content":"\n前几天打比赛没时间写博客，这两天终于可以更新了。\n\nSplay虽然常数大，但是其Splay函数拥有一些神奇的性质，可以实现一些别的平衡树难以完成的操作，如序列翻转等。\n\n\n\n<!--more-->\n\n## 区间翻转\n\n有一个序列 $[1,n]$，每次翻转其中的 $[l,r]$，有 $q$ 次操作。\n\n如果直接模拟，复杂度 $O(qn)$。\n\n像AVL树、旋转式Treap、替罪羊树等常见的平衡树很难用来维护序列，因为如果对序列建树，需要修改的区间在平衡树中可能会分散在多个位置，不仅修改起来很复杂还无法发挥出平衡树的优势。而Splay的自我调整过程可以将待修改区间挤到一个子树中，就可以发挥出平衡树的优势了。\n\n具体来说，由于Splay操作每次将一个结点旋转到根结点，那么我们先把结点 $l-1$ Splay到根结点，显然区间 $[l,n]$ 现在就位于根结点的右子树了，然后再把结点 $r+1$ Splay到根结点的右儿子，那么 $r+1$ 的左子树就是区间 $[l,r]$ 了，我们只需要对这个子树的根打标记并像线段树一样传递标记即可实现区间翻转。复杂度 $O(q\\log n)$。\n\n代码如下：（[模板题P3391](https://www.luogu.com.cn/problem/P3391)）\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 1e5 + 9;\n\nstruct node\n{\n    int fa, sz, cnt, val, tag;\n    int son[2];\n    //node(){}\n};\nnode tree[maxn];\nint ori[maxn], root, wz;\ninline bool which(int x)\n{\n    return x == tree[tree[x].fa].son[1]; //left:0 right:1\n}\ninline void update(int x)\n{\n    if (x == 0)\n        return;\n    tree[x].sz = tree[x].cnt;\n    if (tree[x].son[0])\n        tree[x].sz += tree[tree[x].son[0]].sz;\n    if (tree[x].son[1])\n        tree[x].sz += tree[tree[x].son[1]].sz;\n}\ninline void push_down(int x)\n{\n    if (x && tree[x].tag)\n    {\n        tree[tree[x].son[0]].tag ^= 1;\n        tree[tree[x].son[1]].tag ^= 1;\n        swap(tree[x].son[0], tree[x].son[1]);\n        tree[x].tag = 0;\n    }\n}\ninline void rotate(int x)\n{\n    int f = tree[x].fa, gf = tree[f].fa;\n    push_down(x), push_down(f); //* push down the tags\n    bool w = which(x);\n    tree[f].son[w] = tree[x].son[w ^ 1];\n    tree[tree[f].son[w]].fa = f; //* conect son\n    tree[f].fa = x;\n    tree[x].fa = gf;\n    tree[x].son[w ^ 1] = f; //* conect father\n    if (gf != 0)\n        tree[gf].son[tree[gf].son[1] == f] = x; //* update grandpa\n    update(f);\n}\nvoid splay(int x, int to)\n{\n    while (tree[x].fa != to)\n    {\n        int y = tree[x].fa;\n        if (tree[y].fa != to)\n            rotate(which(x) == which(y) ? y : x);\n        rotate(x);\n    }\n    if (to == 0)\n        root = x; //! very important\n}\nint build(int l, int r, int fa)\n{\n    if (l > r)\n        return 0;\n    int mid = (l + r) >> 1;\n    int now = ++wz;\n    tree[now].fa = fa;\n    tree[now].cnt = 1;\n    tree[now].val = ori[mid];\n    tree[now].sz = 1;\n    tree[now].son[0] = build(l, mid - 1, now);\n    tree[now].son[1] = build(mid + 1, r, now);\n    update(now);\n    return now;\n}\nint find_val(int x)\n{\n    int now = root;\n    while (1)\n    {\n        push_down(now);\n        if (x <= tree[tree[now].son[0]].sz)\n            now = tree[now].son[0];\n        else\n        {\n            x -= tree[tree[now].son[0]].sz + 1;\n            if (x == 0)\n                return now;\n            now = tree[now].son[1];\n        }\n    }\n}\nvoid reverse(int x, int y)\n{\n    int l = find_val(x - 1), r = find_val(y + 1);\n    splay(l, 0);\n    splay(r, l);\n    int pos = tree[root].son[1];\n    pos = tree[pos].son[0];\n    tree[pos].tag ^= 1;\n}\nvoid show(int now)\n{\n    push_down(now); //* dfs\n    if (tree[now].son[0])\n        show(tree[now].son[0]);\n    if (tree[now].val != -inf && tree[now].val != inf)\n        cout << tree[now].val << ' ';\n    if (tree[now].son[1])\n        show(tree[now].son[1]);\n}\nsigned main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    std::cout.tie(0);\n    int n, m, x, y;\n    cin >> n >> m;\n    ori[1] = -inf, ori[n + 2] = inf;\n    for (int i = 1; i <= n; ++i)\n        ori[i + 1] = i;\n    root = build(1, n + 2, 0);\n    for (int i = 1; i <= m; i++)\n    {\n        cin >> x >> y;\n        reverse(x + 1, y + 1);\n    }\n    show(root);\n    return 0;\n}\n```\n\n由于是序列操作，不需要逐个插入元素，类似线段树的建树过程即可。\n\n","tags":["数据结构"]},{"title":"Splay（伸展树）","url":"/2020/08/21/Splay/","content":"\n# 简介：\n\n本来这是一个月前写的文章，但是系统出毛病了没保存上，只好重新写一下了，也算是加深印象吧。网上关于splay和treap的博客非常多，但是代码实现一些人用的是指针，一些人的node不保存父亲结点，还有一些代码风格非常鬼畜，所以还是需要存一份适合自己的模板和教程。\n\n“平衡二叉树还有很多其他的变种……或许其中最有趣的要数 Sleator 和 Tarjan 提出的‘伸展树’，它可以‘自我调整’。伸展树不需要明确的平衡条件（如颜色）来维持平衡。替代的是，每次存取时‘伸展操作’（涉及旋转）在树内执行。在一棵有 n 个结点的树上，每个操作的摊还代价是 $O(\\lg n)$。”——《算法导论》\n\n<!--more-->\n\n# 基本性质：\n\n与AVL树类似，splay维持平衡也需要多种旋转的组合。这里将左旋操作称为Zag，右旋操作称为Zig。\n\n正如上文所说，splay没有明确的平衡条件，取而代之的是其特有的splay（伸展）操作：每次访问splay的时候都进行一次该操作，使得目标结点旋转到根节点。在多次伸展下，树的形态会自然趋向于平衡，所以很多人说“有事没事splay一下”就是这个道理。\n\n# 具体实现：\n\n## 1、准备工作\n\n### 存储结构\n\n```c++\nstruct node\n{\n    int v;//值\n    int fa;//父亲\n    int ch[2];//左右儿子\n    int size;//结点大小\n    int sum;//子树大小\n} tree[N];\n```\n\n非常普通，没什么好说的。\n\n## 2、重要功能\n\n### update\n\n更新结点大小\n\n```c++\ninline void update(int x)\n{\n    tree[x].sum = tree[tree[x].ch[0]].sum + tree[tree[x].ch[1]].sum + tree[x].size;\n}\n```\n\n### 确定自己的位置\n\n```c++\ninline bool findd(int x)\n{\n    return tree[tree[x].fa].ch[0] == x ? 0 : 1;\n}\n```\n\n是左儿子返回0，右儿子返回1。\n\n### connect\n\n```c++\ninline void connect(int x, int fa, int son)\n{\n    tree[x].fa = fa;\n    tree[fa].ch[son] = x;\n}\n```\n\n重新确立父子关系\n\n### rotate\n\n搬一下写Treap的文章里的图\n\n![200719rotate.png](https://i.loli.net/2020/07/19/KX6iGy8ZTHAD4pY.png)\n\n由于splay是要把结点旋转上去，所以只要知道自己的位置就自动确定了是左旋还是右旋，那么只需要一个函数就可以完成了：\n\n```c++\ninline void rotate(int x)\n{\n    int Y = tree[x].fa;\n    int R = tree[Y].fa;\n    int Yson = findd(x);\n    int Rson = findd(Y);\n    int B = tree[x].ch[Yson ^ 1];\n    connect(B, Y, Yson);\n    connect(Y, x, Yson ^ 1);\n    connect(x, R, Rson);\n    update(Y), update(x);\n}\n```\n\n### splay\n\n最重要的操作，将这个结点旋转到根部：\n\n1. 如果父亲是根，直接旋转一次\n2. 如果自己和父亲、祖父在同一条直线上，先把父亲转上去（自己也会上去），再把自己转上去，如图：\n\n![200721zigzig.png](https://i.loli.net/2020/08/04/swcuRnGSrO8I4yE.png)\n\n![200721zagzag.png](https://i.loli.net/2020/08/04/ztgJxXUDCcsQB3S.png)\n\n3. 如果自己和父亲、祖父不在同一条直线上，把自己转上去两次，如图：\n\n![200721zagzig.png](https://i.loli.net/2020/08/04/czBh2THp7KQIlAk.png)\n\n![200721zigzag.png](https://i.loli.net/2020/08/04/jDClxS6BTztiXLu.png)\n\n显然splay操作只会使树变得更平衡。\n\n```c++\ninline void splay(int x, int to)\n{\n    to = tree[to].fa;\n    while (tree[x].fa != to)\n    {\n        int y = tree[x].fa;\n        if (tree[y].fa == to)\n            rotate(x);\n        else if (findd(x) == findd(y))\n            rotate(y), rotate(x);\n        else\n            rotate(x), rotate(x);\n    }\n}\n```\n\n### 插入\n\n利用BST的性质找到插入位置，然后splay上去。\n\n```c++\ninline int newpoint(int v, int fa)\n{\n    tree[++tot].fa = fa;\n    tree[tot].v = v;\n    tree[tot].sum = tree[tot].size = 1;\n    return tot;\n}\ninline void ins(int x)\n{\n    int cur = tree[0].ch[1];\n    if (tree[0].ch[1] == 0)\n    {\n        newpoint(x, 0);\n        tree[0].ch[1] = tot;\n    }\n    else\n    {\n        while (1)\n        {\n            ++tree[cur].sum;\n            if (tree[cur].v == x)\n            {\n                ++tree[cur].size;\n                splay(cur, tree[0].ch[1]);\n                return;\n            }\n            int nxt = x < tree[cur].v ? 0 : 1;\n            if (!tree[cur].ch[nxt])\n            {\n                int p = newpoint(x, cur);\n                tree[cur].ch[nxt] = p;\n                splay(p, tree[0].ch[1]);\n                return;\n            }\n            cur = tree[cur].ch[nxt];\n        }\n    }\n}\n```\n\n\n\n### 删除\n\n先找到这个值，这个时候已经splay到根了，删除就比较方便。\n\n```c++\ninline int find(int v)\n{\n    int cur = tree[0].ch[1];\n    while (1)\n    {\n        if (tree[cur].v == v)\n        {\n            splay(cur, tree[0].ch[1]);\n            return cur;\n        }\n        int nxt = v < tree[cur].v ? 0 : 1;\n        if (!tree[cur].ch[nxt])\n            return 0;\n        cur = tree[cur].ch[nxt];\n    }\n}\ninline void del(int x)\n{\n    int pos = find(x);\n    if (!pos)\n        return;\n    if (tree[pos].size > 1)\n    {\n        --tree[pos].size;\n        --tree[pos].sum;\n    }\n    else\n    {\n        if (!tree[pos].ch[0] && !tree[pos].ch[1])\n            tree[0].ch[1] = 0;\n        else if (!tree[pos].ch[0])\n        {\n            tree[0].ch[1] = tree[pos].ch[1];\n            tree[tree[0].ch[1]].fa = 0;\n        }\n        else\n        {\n            int left = tree[pos].ch[0];\n            while (tree[left].ch[1])\n                left = tree[left].ch[1];\n            splay(left, tree[pos].ch[0]);\n            connect(tree[pos].ch[1], left, 1);\n            connect(left, 0, 1);\n            update(left);\n        }\n    }\n}\n```\n\n\n\n### 根据值查询排名\n\n与删除类似，由于会splay到最上面，计算左子树大小就好了。\n\n```c++\ninline int get_rank(int v)\n{\n    int pos = find(v);\n    return tree[tree[pos].ch[0]].sum + 1;\n}\n```\n\n\n\n### 根据排名查找值\n\n与AVL树类似\n\n```c++\ninline int get_val(int x)\n{\n    int cur = tree[0].ch[1];\n    while (1)\n    {\n        int used = tree[cur].sum - tree[tree[cur].ch[1]].sum;\n        if (x > tree[tree[cur].ch[0]].sum && x <= used)\n        {\n            splay(cur, tree[0].ch[1]);\n            return tree[cur].v;\n        }\n        if (x < used)\n            cur = tree[cur].ch[0];\n        else\n            x -= used, cur = tree[cur].ch[1];\n    }\n}\n```\n\n\n\n### 查询前驱/后继\n\n唯二不需要伸展的操作。由于是数组中建的树，实现难度远远低于AVL树。\n\n```c++\ninline int prev(int v)\n{\n    int cur = tree[0].ch[1];\n    int ans = -inf;\n    while (cur)\n    {\n        if (tree[cur].v < v && tree[cur].v > ans)\n            ans = tree[cur].v;\n        if (v > tree[cur].v)\n            cur = tree[cur].ch[1];\n        else\n            cur = tree[cur].ch[0];\n    }\n    return ans;\n}\ninline int succ(int v)\n{\n    int cur = tree[0].ch[1];\n    int ans = inf;\n    while (cur)\n    {\n        if (tree[cur].v > v && tree[cur].v < ans)\n            ans = tree[cur].v;\n        if (v < tree[cur].v)\n            cur = tree[cur].ch[0];\n        else\n            cur = tree[cur].ch[1];\n    }\n    return ans;\n}\n```\n\n\n\n## 3、完整代码（以[P3369](https://www.luogu.com.cn/problem/P3369)为例）\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\n\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 1e5 + 9;\ntemplate <typename T>\ninline void write(T x)\n{\n    if (x == 0)\n        putchar('0');\n    if (x < 0)\n        x = -x, putchar('-');\n    static int sta[36];\n    int tot = 0;\n    while (x > 0)\n        sta[tot++] = x % 10, x /= 10;\n    while (tot)\n        putchar(sta[--tot] + 48);\n}\nstruct node\n{\n    int v;\n    int fa;\n    int ch[2];\n    int size;\n    int sum;\n} tree[maxn];\nint tot;\ninline void update(int x)\n{\n    tree[x].sum = tree[tree[x].ch[0]].sum + tree[tree[x].ch[1]].sum + tree[x].size;\n}\ninline bool findd(int x)\n{\n    return tree[tree[x].fa].ch[0] == x ? 0 : 1;\n}\ninline void connect(int x, int fa, int son)\n{\n    tree[x].fa = fa;\n    tree[fa].ch[son] = x;\n}\ninline void rotate(int x)\n{\n    int Y = tree[x].fa;\n    int R = tree[Y].fa;\n    int Yson = findd(x);\n    int Rson = findd(Y);\n    int B = tree[x].ch[Yson ^ 1];\n    connect(B, Y, Yson);\n    connect(Y, x, Yson ^ 1);\n    connect(x, R, Rson);\n    update(Y), update(x);\n}\ninline void splay(int x, int to)\n{\n    to = tree[to].fa;\n    while (tree[x].fa != to)\n    {\n        int y = tree[x].fa;\n        if (tree[y].fa == to)\n            rotate(x);\n        else if (findd(x) == findd(y))\n            rotate(y), rotate(x);\n        else\n            rotate(x), rotate(x);\n    }\n}\ninline int newpoint(int v, int fa)\n{\n    tree[++tot].fa = fa;\n    tree[tot].v = v;\n    tree[tot].sum = tree[tot].size = 1;\n    return tot;\n}\ninline void ins(int x)\n{\n    int cur = tree[0].ch[1];\n    if (tree[0].ch[1] == 0)\n    {\n        newpoint(x, 0);\n        tree[0].ch[1] = tot;\n    }\n    else\n    {\n        while (1)\n        {\n            ++tree[cur].sum;\n            if (tree[cur].v == x)\n            {\n                ++tree[cur].size;\n                splay(cur, tree[0].ch[1]);\n                return;\n            }\n            int nxt = x < tree[cur].v ? 0 : 1;\n            if (!tree[cur].ch[nxt])\n            {\n                int p = newpoint(x, cur);\n                tree[cur].ch[nxt] = p;\n                splay(p, tree[0].ch[1]);\n                return;\n            }\n            cur = tree[cur].ch[nxt];\n        }\n    }\n}\ninline int find(int v)\n{\n    int cur = tree[0].ch[1];\n    while (1)\n    {\n        if (tree[cur].v == v)\n        {\n            splay(cur, tree[0].ch[1]);\n            return cur;\n        }\n        int nxt = v < tree[cur].v ? 0 : 1;\n        if (!tree[cur].ch[nxt])\n            return 0;\n        cur = tree[cur].ch[nxt];\n    }\n}\ninline void del(int x)\n{\n    int pos = find(x);\n    if (!pos)\n        return;\n    if (tree[pos].size > 1)\n    {\n        --tree[pos].size;\n        --tree[pos].sum;\n    }\n    else\n    {\n        if (!tree[pos].ch[0] && !tree[pos].ch[1])\n            tree[0].ch[1] = 0;\n        else if (!tree[pos].ch[0])\n        {\n            tree[0].ch[1] = tree[pos].ch[1];\n            tree[tree[0].ch[1]].fa = 0;\n        }\n        else\n        {\n            int left = tree[pos].ch[0];\n            while (tree[left].ch[1])\n                left = tree[left].ch[1];\n            splay(left, tree[pos].ch[0]);\n            connect(tree[pos].ch[1], left, 1);\n            connect(left, 0, 1);\n            update(left);\n        }\n    }\n}\ninline int get_rank(int v)\n{\n    int pos = find(v);\n    return tree[tree[pos].ch[0]].sum + 1;\n}\ninline int get_val(int x)\n{\n    int cur = tree[0].ch[1];\n    while (1)\n    {\n        int used = tree[cur].sum - tree[tree[cur].ch[1]].sum;\n        if (x > tree[tree[cur].ch[0]].sum && x <= used)\n        {\n            splay(cur, tree[0].ch[1]);\n            return tree[cur].v;\n        }\n        if (x < used)\n            cur = tree[cur].ch[0];\n        else\n            x -= used, cur = tree[cur].ch[1];\n    }\n}\ninline int prev(int v)\n{\n    int cur = tree[0].ch[1];\n    int ans = -inf;\n    while (cur)\n    {\n        if (tree[cur].v < v && tree[cur].v > ans)\n            ans = tree[cur].v;\n        if (v > tree[cur].v)\n            cur = tree[cur].ch[1];\n        else\n            cur = tree[cur].ch[0];\n    }\n    return ans;\n}\ninline int succ(int v)\n{\n    int cur = tree[0].ch[1];\n    int ans = inf;\n    while (cur)\n    {\n        if (tree[cur].v > v && tree[cur].v < ans)\n            ans = tree[cur].v;\n        if (v < tree[cur].v)\n            cur = tree[cur].ch[0];\n        else\n            cur = tree[cur].ch[1];\n    }\n    return ans;\n}\nint main()\n{\n    int n;\n    read(n);\n    while (n--)\n    {\n        int op, x;\n        read(op), read(x);\n        if (op == 1)\n            ins(x);\n        else if (op == 2)\n            del(x);\n        else if (op == 3)\n        {\n            write(get_rank(x));\n            putchar('\\n');\n        }\n        else if (op == 4)\n        {\n            write(get_val(x));\n            putchar('\\n');\n        }\n        else if (op == 5)\n        {\n            write(prev(x));\n            putchar('\\n');\n        }\n        else\n        {\n            write(succ(x));\n            putchar('\\n');\n        }\n    }\n    return 0;\n}\n\n```\n\n平衡树最基本的操作就都实现了。splay的复杂度是均摊 $O(\\log n)$ 的，不太适合可持久化。\n\n\n\n# 后记\n\n以后还需要写一下splay处理序列问题。\n\n\n\n![83758942](https://i.loli.net/2020/08/20/fEji9Aco5JlFSeL.jpg)\n\n\n\nFGO    アナスタシア・ニコラエヴナ・ロマノヴァ","tags":["数据结构"]},{"title":"经验总结（更新中）","url":"/2020/08/19/Tips/","content":"\n\n在这里总结一些踩过的坑以及一些小技巧。\n\n\n\n<!--more-->\n\n-  容易犯错的地方（fst原因大全）\n   1. 数组大小有时候会是 $2\\times 10^5$ 甚至是 $5\\times 10^5$，不要想当然直接开 `maxn=1e5+9`，运气好的话在pretest中RE了还能查出来，要是运气不好过了pretest那就等着fst吧\n   2. 初始化的时候尽量写 `maxx=-inf,minn=inf` 这样的极端数据，无脑初始化为 `0` 是一个坏习惯\n   3. 不开 `long long` 见祖宗，被坑了无数次了\n   4. `double` 的精度并没有想象的那么高，用的时候要小心\n-  小优化\n   \n   1.  读01矩阵这样的东西用 `scanf(\"%c\",&x)` 比用 `scanf(\"%1d\",&x)` 稍微快一点\n-  一些经验\n   1.  指针和宏定义稍有不慎就会出奇怪的毛病且非常难以调试，用不好就不要用\n   2.  不要吃饱了撑着写一堆 `register` 变量或者位运算，有时候编译器自己会优化的，多用 `register` 并不一定使程序变快，甚至可能会负优化；多用位运算也不一定会变快，出错的概率倒是大大增加\n   3.  想不出做法的时候试试暴力，有奇效\n   4.  不只是序列可以分块做，图也是可以分块的\n   5.  单调栈非常有用（被这东西坑了两次了）\n   6.  如果觉得需要使用一些比较复杂的数据结构，最好再分析一遍题意，否则很可能把简单问题复杂化\n- 容易忘记的小知识点\n\n   1. 斐波那契数列通项公式 $\\large f_n=\\dfrac{(\\frac{1+\\sqrt 5}{2})^n-(\\frac{1-\\sqrt 5}{2})^n}{\\sqrt 5}$\n\n   2. 在只含加法和乘法的式子中，如果最后的运算结果需要对p取模，那么可以在运算过程中随便取模\n   \n      \n\n\n\n","tags":["其它"]},{"title":"非递归式线段树","url":"/2020/08/19/zkw_Segment_Tree/","content":"\n\n\n递归式线段树非常好用，但是常数大，极端情况下可能会被卡掉。非递归式线段树更像是树状数组，常数小，代码也短，当然功能也稍微弱了一点。最近看了几遍zkw的PPT，了解了一下非递归式线段树，感觉对线段树的理解又深了一点。\n\n<!--more-->\n\n先来观察一下这个图：\n\n![完全二叉树](https://i.loli.net/2020/08/19/r8dn2KQy9zm1Ytx.png)\n\n上面是一棵完全二叉树，结点序号用红色标出，黑色的是序号的二进制表示。我们可以发现一个规律：父亲结点的二进制表示是两个儿子的二进制表示的前缀。普通的递归式线段树写法也正是利用了这个性质，所以有 `tree[p]=tree[p<<1]+tree[p<<1|1]` 的写法。\n\n所以有人认为线段树和Trie是一个东西，其实也是有道理的。只不过平时常用的Trie不是二叉树，而是26叉树罢了。\n\n那么递归写法的 `build` 和 `update` 函数都是递归到底部后 `push_up`，如果不采用递归我们就需要更充分利用上面说的前缀性质：直接将数据按顺序存在叶子里面，然后不断除2往上跳就好了。\n\n如果这样的就必须要是一棵完全二叉树，所以空间要足够大，直接和普通的一样四倍就没问题了。\n\n具体实现以后再写。\n\n用的是标记永久化。\n\n目前看来zkw线段树可以像递归式线段树一样做到：\n\n- 单点修改\n- 区间修改（加上一个数）\n- 单点查询\n- 区间查询（和、最值等）\n\n但是似乎不能做到：\n\n- 维护两种运算，如 [这道题](https://www.luogu.com.cn/problem/P3373)\n\n搬个模板：\n\n```c++\n#include <iostream>\n#include<cstdio>\n#define ll long long\nusing namespace std;\nint n,m;\nll a[400005],mark[400005];\nll bit,lb;\ninline int getlong(int k)//查询结点第几层\n{\n    int i=0;\n    while(k>>=1)i++;\n    return i;\n}\ninline int put(int k,int t)//修改\n{\n    int tmp=1<<(lb-getlong(k));\n    while(k>>=1)\n        a[k]+=t*tmp;\n    return 0;\n}\ninline ll get1(ll k)//查询\n{\n    ll tmp=1<<(lb-getlong(k));//tmp有多少叶节点就加几倍\n    ll re=a[k]+mark[k]*tmp;\n    do\n    {\n        k>>=1;\n        re+=mark[k]*tmp;\n    }while(k);\n    return re;\n}\ninline ll get(ll s,ll t)//区间查询\n{\n    ll re=0;\n    for(s=s+bit-1,t=t+bit+1;s^t^1;s>>=1,t>>=1)//s-1和t+1变开区间，s+bit和t+bit到对应叶节点\n    {\n        if(!(s&1))\n            re+=get1(s^1);//*(1<<(lb-getlong(s)));\n        if(t&1)\n            re+=get1(t^1);//*(1<<(lb-getlong(t)));\n    }\n    return re;\n}\ninline int change(ll s,ll t,ll k)//区间修改\n{\n    for(s=s+bit-1,t=t+bit+1;s^t^1;s>>=1,t>>=1)\n    {\n        //int tmp;\n        if(!(s&1))\n        {\n            mark[s^1]+=k;//*(1<<(lb-getlong(s)));\n            put(s^1,k);\n        }\n        if(t&1)\n        {\n            mark[t^1]+=k;//*(1<<(lb-getlong(t)));\n            put(t^1,k);\n        }\n    }\n    return 0;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin>>n>>m;\n    for(bit=1;bit-2<n;bit<<=1);\n    lb=getlong(bit);\n    for(int i=bit+1;i<=bit+n;i++)\n        cin>>a[i];\n    for(int i=bit-1;i;i--)\n    {\n        a[i]=a[i<<1]+a[i<<1|1];//( i*2==i<<1) , (i*2+1==i<<1|1)\n        //a[i<<1]-=a[i];a[i<<1|1]-=a[i];\n    }\n    for(int i=1;i<=m;i++)\n    {\n        ll aa,b,c,d;\n        cin>>aa;\n        if(aa==2)\n        {\n            cin>>b>>c;//cout<<b<<' '<<c<<' '<<get(b,c)<<endl;\n            cout<<get(b,c)<<endl;\n            for(int i=1;i<=n+bit;i++)cout<<get1(i)<<' ';cout<<endl;\n        }\n        else\n        {\n            cin>>b>>c>>d;change(b,c,d);\n            //cout<<b<<' '<<c<<' '<<d<<endl;\n            for(int i=1;i<=n+bit;i++)cout<<get1(i)<<' ';cout<<endl;\n        }\n    }\n\n    return 0;\n}\n```\n\n[PPT链接](https://wenku.baidu.com/view/0c1bbba40029bd64783e2cca.html)\n\n顺便放三篇有趣的文章以后看看：\n\n- [JAVA实现线段树](https://www.luogu.com.cn/blog/AldonahZero/solution-p3372)\n- [试图用珂朵莉树水过线段树](https://www.luogu.com.cn/blog/aaronlee/solution-p3372-1)\n- [指令集优化暴力](https://www.luogu.com.cn/blog/yurzhang/solution-p3372)\n\n![63770148](https://i.loli.net/2020/08/19/YKg7CRX2eQn648a.jpg)\n\n难得看到有人画兰朵露可","tags":["数据结构"]},{"title":"树链剖分","url":"/2020/08/18/path_decomposition/","content":"\n\n\n树链剖分，就是把一棵树分成一些链，然后就可以用数据结构来维护。\n\n\n\n<!--more-->\n\n# 重链剖分\n\n## DFS序\n\n在对一棵树进行DFS的时候每经过一个新的结点就记录它的编号，这样就可以得到一个排列，称为DFS序。\n\n由于是用DFS的方式遍历这棵树，我们可以得到这样的性质：\n\n- 每个点的子树对应DFS序上一段连续的区间\n  - 若进入点 $x$ 的时间是 $DFS_x$，离开点 $x$ 的时间是 $DFS_x+size_x-1$\n\n那么可以用线段树之类的东西来维护这个子树，可以做到 $O(\\log n)$ 复杂度完成：\n\n- 将一个点的子树所有点权加上一个值\n- 查询一个点的子树内点权最小值\n- 查询一个点的子树内的点权和\n\n如果没有DFS序为了完成上面的操作可能需要这样：每个结点维护点权、子树大小、子树点权和、子树点权最小值以及一个lazy-tag。似乎也是可以做的但是比较麻烦。\n\n## 轻重链\n\n如果我们在上面的基础上需要支持以下两个操作：\n\n- 修改单点点权\n- 查询两点路径上最小点权\n\n第二个操作用上面的原始做法是很难完成的，因为区间查询很难做到。\n\n所以需要把树上问题转化成序列问题。先引入**轻链**和**重链**的概念：\n\n对于**非叶结点** $x$，设其**最大的子树**对应的**子结点**为 $y$，则将边 $(x,y)$ 称为重边，其余的边为轻边。\n\n重边形成的链即为重链。\n\n那么可以得到以下几条性质：\n\n- 如果边 $(x,y)$ 是轻边，$size_x\\ge2size_y$ \n  - 显而易见，如果是轻边说明至少有两个子树，并且 $y$ 不是唯一最大的子树\n- 重链的起点是根结点或轻边的终点（轻儿子）\n- 一个点到根的路径上，轻边数量的级别是 $O(\\log n)$ \n- 重链的条数是 $O(\\log n)$ \n- 可以将树上的一条路径划分为 $O(\\log n)$ 条重链\n\n## 实现\n\n首先当然是存图，现在觉得链式前向星还是挺好用的\n\n```c++\nint head[maxn], to[maxn], nxt[maxn], tot = 0;\ninline void add(int u, int v)\n{\n    to[++tot] = v;\n    nxt[tot] = head[u];\n    head[u] = tot;\n}\n```\n\n先进行一次DFS，求出每个结点的子树大小和重儿子\n\n```c++\nint son[maxn], id[maxn], fa[maxn], cnt, dep[maxn], sz[maxn], top[maxn];\nint w[maxn], wt[maxn];\nvoid dfs1(int p, int f, int d)\n{\n    dep[p] = d;\n    fa[p] = f;\n    sz[p] = 1;\n    int maxson = -1;\n    for (int i = head[p]; i; i = nxt[i])\n    {\n        int y = to[i];\n        if (y == f)\n            continue;\n        dfs1(y, p, d + 1);\n        sz[p] += sz[y];\n        if (sz[y] > maxson)//son数组放重儿子\n            son[p] = y, maxson = sz[y];\n    }\n}\n```\n\n再进行一次DFS记录DFS序，到一个点时先访问重儿子再访问其余儿子\n\n```c++\nvoid dfs2(int p, int topf)\n{\n    id[p] = ++cnt;\n    wt[cnt] = w[p];\n    top[p] = topf;\n    if (son[p] == 0)\n        return;\n    dfs2(son[p], topf);\n    for (int i = head[p]; i; i = nxt[i])\n    {\n        int y = to[i];\n        if (y == fa[p] || y == son[p])\n            continue;\n        dfs2(y, y);\n    }\n}\n```\n\n\n\n   -  对于一条重链，链上的点在DFS 序中一定相邻\n   -  一条重链对应DFS 序中一段区间\n\n\n\n做好准备工作以后放进线段树。\n\n区间和查询：\n\n```c++\nint query(int l, int r)\n{\n    int ans = 0;\n    while (top[l] != top[r])\n    {\n        if (dep[top[l]] < dep[top[r]])\n            swap(l, r);\n        ans += tree.query(1, 1, n, id[top[l]], id[l]);\n        ans %= mod;\n        l = fa[top[l]];\n    }\n    if (dep[l] > dep[r])\n        swap(l, r);\n    ans += tree.query(1, 1, n, id[l], id[r]);\n    return ans % mod;\n}\n```\n\n区间修改：\n\n```c++\nvoid update(int l, int r, int k)\n{\n    k %= mod;\n    while (top[l] != top[r])\n    {\n        if (dep[top[l]] < dep[top[r]])\n            swap(l, r);\n        tree.update(1, 1, n, id[top[l]], id[l], k);\n        l = fa[top[l]];\n    }\n    if (dep[l] > dep[r])\n        swap(l, r);\n    tree.update(1, 1, n, id[l], id[r], k);\n}\n```\n\n子树和查询：\n\n```c++\ninline int qson(int p)\n{\n    return tree.query(1, 1, n, id[p], id[p] + sz[p] - 1);\n}\n```\n\n子树修改：\n\n```c++\ninline void upson(int p, int k)\n{\n    tree.update(1, 1, n, id[p], id[p] + sz[p] - 1, k);\n}\n```\n\n树链剖分代码写错极难调试，有时候出一点小错误甚至也能过数据不强的测试点，非常难受。\n\n操作细节部分日后再补，今天就先把这个能用的模板搞出来：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\n\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 2e5 + 9;\n\nint n, m, root, mod;\nint head[maxn], to[maxn], nxt[maxn], tot = 0;\ninline void add(int u, int v)\n{\n    to[++tot] = v;\n    nxt[tot] = head[u];\n    head[u] = tot;\n}\n\nint son[maxn], id[maxn], fa[maxn], cnt, dep[maxn], sz[maxn], top[maxn];\nint w[maxn], wt[maxn];\n\nstruct segtree\n{\n    int tree[maxn << 2], tag[maxn << 2];\n    void push_up(int p)\n    {\n        tree[p] = (tree[p << 1] + tree[p << 1 | 1]) % mod;\n    }\n    void build(int p, int l, int r)\n    {\n        tag[p] = 0;\n        if (l == r)\n        {\n            tree[p] = wt[l] % mod;\n            return;\n        }\n        int mid = (l + r) >> 1;\n        build(p << 1, l, mid);\n        build(p << 1 | 1, mid + 1, r);\n        push_up(p);\n    }\n    void flag(int p, int l, int r, int k)\n    {\n        tag[p] = (tag[p] + k) % mod;\n        tree[p] += k * (r - l + 1);\n        tree[p] %= mod;\n    }\n    void push_down(int p, int l, int r)\n    {\n        int mid = (l + r) >> 1;\n        flag(p << 1, l, mid, tag[p]);\n        flag(p << 1 | 1, mid + 1, r, tag[p]);\n        tag[p] = 0;\n    }\n    void update(int p, int l, int r, int ul, int ur, int k)\n    {\n        if (ul <= l && ur >= r)\n        {\n            tree[p] += k * (r - l + 1);\n            tag[p] += k;\n            tree[p] %= mod;\n            tag[p] %= mod;\n            return;\n        }\n        push_down(p, l, r);\n        int mid = (l + r) >> 1;\n        if (ul <= mid)\n            update(p << 1, l, mid, ul, ur, k);\n        if (ur > mid)\n            update(p << 1 | 1, mid + 1, r, ul, ur, k);\n        push_up(p);\n    }\n    int query(int p, int l, int r, int qx, int qy)\n    {\n        if (qx <= l && qy >= r)\n            return tree[p];\n        int ans = 0, mid = (l + r) >> 1;\n        push_down(p, l, r);\n        if (qx <= mid)\n            ans += query(p << 1, l, mid, qx, qy), ans %= mod;\n        if (qy > mid)\n            ans += query(p << 1 | 1, mid + 1, r, qx, qy), ans %= mod;\n        return ans;\n    }\n};\nsegtree tree;\n\nvoid dfs1(int p, int f, int d)\n{\n    dep[p] = d;\n    fa[p] = f;\n    sz[p] = 1;\n    int maxson = -1;\n    for (int i = head[p]; i; i = nxt[i])\n    {\n        int y = to[i];\n        if (y == f)\n            continue;\n        dfs1(y, p, d + 1);\n        sz[p] += sz[y];\n        if (sz[y] > maxson)\n            son[p] = y, maxson = sz[y];\n    }\n}\n\nvoid dfs2(int p, int topf)\n{\n    id[p] = ++cnt;\n    wt[cnt] = w[p];\n    top[p] = topf;\n    if (son[p] == 0)\n        return;\n    dfs2(son[p], topf);\n    for (int i = head[p]; i; i = nxt[i])\n    {\n        int y = to[i];\n        if (y == fa[p] || y == son[p])\n            continue;\n        dfs2(y, y);\n    }\n}\n\nint query(int l, int r)\n{\n    int ans = 0;\n    while (top[l] != top[r])\n    {\n        if (dep[top[l]] < dep[top[r]])\n            swap(l, r);\n        ans += tree.query(1, 1, n, id[top[l]], id[l]);\n        ans %= mod;\n        l = fa[top[l]];\n    }\n    if (dep[l] > dep[r])\n        swap(l, r);\n    ans += tree.query(1, 1, n, id[l], id[r]);\n    return ans % mod;\n}\n\nvoid update(int l, int r, int k)\n{\n    k %= mod;\n    while (top[l] != top[r])\n    {\n        if (dep[top[l]] < dep[top[r]])\n            swap(l, r);\n        tree.update(1, 1, n, id[top[l]], id[l], k);\n        l = fa[top[l]];\n    }\n    if (dep[l] > dep[r])\n        swap(l, r);\n    tree.update(1, 1, n, id[l], id[r], k);\n}\n\ninline int qson(int p)\n{\n    return tree.query(1, 1, n, id[p], id[p] + sz[p] - 1);\n}\n\ninline void upson(int p, int k)\n{\n    tree.update(1, 1, n, id[p], id[p] + sz[p] - 1, k);\n}\n\nsigned main()\n{\n    read(n), read(m), read(root), read(mod);\n    int op, u, v, k;\n    for (int i = 1; i <= n; ++i)\n        read(w[i]);\n    for (int i = 1; i < n; ++i)\n    {\n        read(u), read(v);\n        add(u, v), add(v, u);\n    }\n    dfs1(root, 0, 1);\n    dfs2(root, root);\n    tree.build(1, 1, n);\n    while (m--)\n    {\n        read(op);\n        if (op == 1)\n        {\n            read(u), read(v), read(k);\n            update(u, v, k);\n        }\n        else if (op == 2)\n        {\n            read(u), read(v);\n            cout << query(u, v) << '\\n';\n        }\n        else if (op == 3)\n        {\n            read(u), read(k);\n            upson(u, k);\n        }\n        else\n        {\n            read(u);\n            cout << qson(u) << '\\n';\n        }\n    }\n    return 0;\n}\n```\n\n其实树链剖分的函数也可以封装进结构体，但是代码耗时增加了将近30%，感觉有点亏。\n\n# 长链剖分\n\n重链剖分选择的是子树大小最大的儿子，长链剖分选择的是子树高度最大的儿子。一些情况下这两种是一样的。长链剖分的复杂度在很多时候并没有重链剖分优秀，因此比较少见，具体内容可以在[HaHaTa的这篇博客](http://hahata.org/193/)中了解。\n\n![83686942](https://i.loli.net/2020/08/19/VCHMpkNei5nmBI4.jpg)\n\n雪花ラミィ\n\n","tags":["图论"]},{"title":"左偏树","url":"/2020/08/16/Leftist_Tree/","content":"\n\n\n普通二叉堆支持 $O(\\log n)$ 插入，$O(\\log n)$ 删除堆顶，$O(1)$ 查询堆顶，但美中不足的是不支持合并。左偏树是一种可并堆，除了满足上面的操作外还可以做到 $O(\\log n)$ 合并。\n\n<!--more-->\n\n## 性质\n\n一棵左偏树满足以下几条性质：（以小根堆为例）\n\n- 是一棵二叉树\n- 每个结点维护两个值，分别是数据大小 $val$ 和到子树中最近叶子结点的距离 $dis$\n  - 所以叶子结点的 $dis$ 必定为 $0$\n- 父亲结点的 $val$ 必然小于其左右儿子的 $val$（堆性质）\n- 左儿子的 $dis$ 不小于右儿子的 $dis$（左偏性质）\n  - 父亲结点的 $dis$ 必定比右儿子的 $dis$ 大 $1$\n  - 如果一个结点没有左儿子，那它一定是叶子结点\n\n根据上面的性质可以得到一个推论：结点数为 $n$ 的左偏树中最大的 $dis$ 不超过 $\\log(n+1)-1$，极端情况是左偏树成为一棵满二叉树。这个推论的逆命题也是成立的，如果最大 $dis$ 为 $k$，那么至少有 $2^{k+1}-1$ 个结点。\n\n## 合并\n\n先看左偏树最核心的 `merge` 操作：（以小根堆为例）\n\n首先，如果有一个待合并的左偏树是空的，那么返回另一个就好了。\n\n然后考虑一般情况，假设两棵左偏树分别是A与B，默认A的根结点键值小于B的（如果不是就swap一下）。那么我们取A的根为新树的根，然后合并A的右子树和B。\n\n合并了A的右子树和B后如果左偏性质被破坏了，那么就swap左右子树，并更新父亲的 $dis$。\n\n一直这样下去，就可以把两棵树合并了，根据上面的推论可以得出最坏情况的复杂度是 $O(\\log n_A +\\log n_B)$，非常优秀。\n\n## 其他操作\n\n太晚了明天再写\n\n## 实现\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\n\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 1e5 + 9;\n\nstruct Tree\n{\n    int dis, val, root, ls, rs;\n};\n\nstruct Leftist_Tree\n{\n    Tree lt[maxn];\n    int merge(int x, int y)\n    {\n        if (!x || !y)\n            return x + y;\n        if (lt[x].val > lt[y].val || (lt[x].val == lt[y].val && x > y))\n            swap(x, y);\n        lt[x].rs = merge(lt[x].rs, y);\n        if (lt[lt[x].ls].dis < lt[lt[x].rs].dis)\n            swap(lt[x].ls, lt[x].rs);\n        lt[lt[x].ls].root = x;\n        lt[lt[x].rs].root = x;\n        lt[x].root = x;\n        lt[x].dis = lt[lt[x].rs].dis + 1;\n        return x; //root\n    }\n    int find(int x)\n    {\n        return lt[x].root == x ? x : lt[x].root = find(lt[x].root);\n    }\n    int top(int x)\n    {\n        return lt[x].val;\n    }\n    void pop(int x)\n    {\n        lt[x].val = -1;\n        lt[lt[x].ls].root = lt[x].ls;\n        lt[lt[x].rs].root = lt[x].rs;\n        lt[x].root = merge(lt[x].ls, lt[x].rs);\n    }\n};\nLeftist_Tree t;\n\nsigned main()\n{\n    int n, m;\n    read(n), read(m);\n    t.lt[0].dis = -1;\n    for (int i = 1; i <= n; ++i)\n    {\n        t.lt[i].root = i;\n        read(t.lt[i].val);\n    }\n    while (m--)\n    {\n        int op, x, y;\n        read(op);\n        if (op == 1)\n        {\n            read(x), read(y);\n            if (t.lt[x].val == -1 || t.lt[y].val == -1)\n                continue;\n            int fx = t.find(x), fy = t.find(y);\n            if (fx != fy)\n            {\n                int p = t.merge(fx, fy);\n                t.lt[fx].root = p;\n                t.lt[fy].root = p;\n            }\n        }\n        else\n        {\n            read(x);\n            if (t.lt[x].val == -1)\n                puts(\"-1\");\n            else\n            {\n                cout << t.top(t.find(x)) << '\\n';\n                t.pop(t.find(x));\n            }\n        }\n    }\n    return 0;\n}\n```\n\n","tags":["数据结构"]},{"title":"LCA","url":"/2020/08/14/LCA/","content":"\n\n\n在有根树中，最近公共祖先（**L**east **C**ommon **A**ncestors）是两个结点最近的的公共祖先，也是最深的一个。\n\n\n\n<!--more-->\n\n\n\n随便找一棵有根树，在里面随便找两个不同结点A、B，求它们的最近公共祖先C，有以下几种方法：\n\n## 1. 暴力\n\n- 先从A、B中深度大的一个向上走，直到两个深度一样。\n- 如果这时候遇到了另一个，那么直接找到了；如果没有相遇，两个同时往上走，直到遇见为止。\n- 正确性显然，复杂度 $O(nq)$\n\n当然了，这样必然会T。\n\n## 2. 倍增\n\n暴力的问题在于每次往上走的步长都是1，效率低下，所以可以先走一大步，如果过头了就回来缩小步长，否则继续向前走。\n\n复杂度 $O((n+q)\\log n)$，比较优秀，也是很常用的做法。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\n\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 5e5 + 9;\n\nstruct node\n{\n    int to, nxt;\n};\nnode e[maxn << 1];\nint head[maxn], num;\nvoid add(int u, int v)\n{\n    e[++num].to = v;\n    e[num].nxt = head[u];\n    head[u] = num;\n}\nint depth[maxn], fa[maxn][22], lg[maxn];\nvoid dfs(int pos, int f)\n{\n    fa[pos][0] = f;\n    depth[pos] = depth[f] + 1;\n    for (int i = 1; i <= lg[depth[pos]]; ++i)\n        fa[pos][i] = fa[fa[pos][i - 1]][i - 1];\n    for (int i = head[pos]; i; i = e[i].nxt)\n        if (e[i].to != f)\n            dfs(e[i].to, pos);\n}\nint lca(int x, int y)\n{\n    if (depth[x] < depth[y])\n        swap(x, y);\n    while (depth[x] > depth[y])\n    {\n        x = fa[x][lg[depth[x] - depth[y]] - 1];\n    }\n    if (x == y)\n        return x;\n    for (int k = lg[depth[x]] - 1; k >= 0; --k)\n        if (fa[x][k] != fa[y][k])\n            x = fa[x][k], y = fa[y][k];\n    return fa[x][0];\n}\n\nsigned main()\n{\n    int n, m, s;\n    read(n), read(m), read(s);\n    for (int i = 1; i < n; ++i)\n    {\n        int x, y;\n        read(x), read(y);\n        add(x, y), add(y, x);\n    }\n    for (int i = 1; i <= n; ++i)\n        lg[i] = lg[i - 1] + (1 << lg[i - 1] == i);\n    dfs(s, 0);\n    for (int i = 1; i <= m; ++i)\n    {\n        int x, y;\n        read(x), read(y);\n        cout << lca(x, y) << '\\n';\n    }\n    return 0;\n}\n```\n\n## 3. ST表\n\n同样对树进行一次 dfs，求出结点顺序和深度然后用ST表维护区间中深度最小结点的位次。\n\n复杂度 $O(n\\log n+q)$，动态点分治在线求LCA比较有用。\n\n详细内容以后再补。\n\n## 4. 树链剖分\n\n不会树剖，大概是这样做的：\n\n对树进行轻重链剖分，每次沿重链向上跳，直到两个节点的 top 相同，此时 dep 较小的就是LCA。\n\n复杂度 $O(n+q\\log n)$，这种做法的另一个好处在于可以结合别的线性数据结构把树上的信息转化为链上的信息。\n\n详细内容以后再补。\n\n## 5. Tarjan算法\n\n把询问分别挂在两节点上，然后对整棵树做一次 dfs ，用并查集维护每个节点当前深度最小的祖先。\n\n复杂度 $O(n+q)$，唯一一个线性复杂度的，但是似乎很少用。\n\n详细内容以后再补。\n\n![83613096](https://i.loli.net/2020/08/15/QvCZyBsRS8PKoeL.jpg)\n\n没看过Fate，但是这个阿尔托莉雅真可爱\n\n","tags":["图论"]},{"title":"分块","url":"/2020/08/13/block/","content":"\n\n\n分块是一种很暴力的思想，总是可以莫名其妙的乱搞掉一些题目。莫队算法就是建立在分块的基础上，所以还是有必要学一下分块。\n\n\n\n\n<!--more-->\n\n简单的说**分块**就是把整个序列分成若干个连续的块，每个块包含一段比较短的区间。可以用分块做很多事情，比如像线段树一样对区间进行修改查询。\n\n由均值不等式可以得出，一般块的长度分为 $\\sqrt {len}$ 比较合适。\n\n所以如果要用树形的结构表示，大概是这样的：\n\n![分块](https://i.loli.net/2020/08/13/ZMYCoQ8ylg4jrk5.png)\n\n可见无论原来的序列有多长，这个树形结构的高度永远都是3，因此它的复杂度远远不如线段树的 $O(n\\log n)$，而是 $O(n\\sqrt n)$。所幸在大部分情况下这个根号复杂度也是可以接受的。\n\n由于这个思想非常暴力，代码实现也比较容易理解：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\n\nconst int maxn = 1e5 + 9;\n\nint ans[maxn], fa[maxn], a[maxn];\nint st[maxn], ed[maxn], sz[maxn], tag[maxn];\nint n, m, sq;\n\nvoid change(int x, int y)\n{\n    int l = fa[x], r = fa[y];\n    for (int i = x; i <= min(y, ed[l]); ++i)\n    {\n\n    }\n    if (l != r)\n    {\n        for (int i = st[r]; i <= y; ++i)\n        {\n\n        }\n    }\n    for (int i = l + 1; i < r; ++i)\n    {\n\n    }\n}\n\nint query(int x, int y)\n{\n    int res = 0, l = fa[x], r = fa[y];\n    for (int i = x; i <= min(y, ed[l]); ++i)\n    {\n        \n    }\n    if (l != r)\n    {\n        for (int i = st[r]; i <= y; ++i)\n\n    }\n    for (int i = l + 1; i < r; ++i)\n    {\n\n    }\n    return res;\n}\n\nsigned main()\n{\n\n    read(n), read(m);\n    sq = sqrt(n);\n    for (int i = 1; i < +n; ++i)\n        read(s[i]);\n    for (int i = 1; i <= sq; ++i)\n    {\n        st[i] = n / sq * (i - 1) + 1;\n        ed[i] = n / sq * i;\n    }\n    ed[sq] = n;\n    for (int i = 1; i <= sq; ++i)\n        for (int j = st[i]; j <= ed[i]; ++j)\n            fa[j] = i;\n    for (int i = 1; i <= sq; ++i)\n        sz[i] = ed[i] - st[i] + 1;\n    \n\n    return 0;\n}\n```\n\n大概可以搞出这样的一个模板。\n\n但是可能会出现一些很玄学的问题。\n\n比如 [P3870 [TJOI2009]开关](https://www.luogu.com.cn/problem/P3870) 这样写总有两个点过不去，怎么都调不对，不知道为什么，但是稍微改变一下写法就能过了：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 1e5 + 9;\n\nint n, m;\nint sq;\nint q[maxn];\nbool tag[maxn];\nbool k[maxn];\nint sum[maxn];\n\nvoid opt1(int l, int r)\n{\n    for (int i = l; i <= min(r, q[l] * sq); i++)\n    {\n        sum[q[i]] -= (k[i] ^ tag[q[i]]);\n        k[i] ^= 1;\n        sum[q[i]] += (k[i] ^ tag[q[i]]);\n    }\n    if (q[l] != q[r])\n    {\n        for (int i = (q[r] - 1) * sq + 1; i <= r; i++)\n        {\n            sum[q[i]] -= (k[i] ^ tag[q[i]]);\n            k[i] ^= 1;\n            sum[q[i]] += (k[i] ^ tag[q[i]]);\n        }\n    }\n    for (int i = q[l] + 1; i < q[r]; i++)\n    {\n        tag[i] ^= 1;\n        sum[i] = sq - sum[i];\n    }\n}\nint opt2(int l, int r)\n{\n    int s = 0;\n    for (int i = l; i <= min(r, q[l] * sq); i++)\n    {\n        s += (k[i] ^ tag[q[i]]);\n    }\n    if (q[l] != q[r])\n    {\n        for (int i = (q[r] - 1) * sq + 1; i <= r; i++)\n        {\n            s += (k[i] ^ tag[q[i]]);\n        }\n    }\n    for (int i = q[l] + 1; i < q[r]; i++)\n    {\n        s += sum[i];\n    }\n    return s;\n}\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    sq = sqrt(n);\n    for (int i = 1; i <= n; i++)\n    {\n        q[i] = (i - 1) / sq + 1;\n    }\n    while (m--)\n    {\n        int opt, l, r;\n        scanf(\"%d%d%d\", &opt, &l, &r);\n        if (opt == 0)\n        {\n            opt1(l, r);\n        }\n        else\n        {\n            printf(\"%d\\n\", opt2(l, r));\n        }\n    }\n    return 0;\n}\n```\n\n这就非常令人难以理解。\n\n线段树就比这个靠谱得多。我还是更喜欢线段树。\n\n虽然分块这种做法看起来很丑陋，但是有时候还是挺有用的，所以先了解一下。\n\n\n\n\n\n最近比赛的状态依然不好。\n\n![83510923](https://i.loli.net/2020/08/14/rLgvUPjmKEsSThI.jpg)","tags":["数据结构"]},{"title":"模板（更新中）","url":"/2020/08/12/Template/","content":"\n\n\n# 模板\n\n<!--more-->\n\n\n## 字符串\n\n### KMP\n\n```c++\n/*a:模式串 s:待匹配串*/\nchar s[maxn], a[maxn];\nint nxt[maxn], lena, lens;\nvoid getnext(){\n    nxt[0] = -1, nxt[1] = 0;\n    for (int i = 2, k; i <= lena; ++i){\n        k = nxt[i - 1];\n        while (k != -1 && a[k + 1] != a[i])\n            k = nxt[k];\n        nxt[i] = k + 1;\n    }\n}\nvoid kmp(){\n    for (int i = 1, k = 0; i <= lens; ++i){\n        while (k != -1 && s[i] != a[k + 1])\n            k = nxt[k];\n        k++;\n        if (k == lena)//匹配成功\n            k = nxt[k];\n    }\n}\nint main(){\n    scanf(\"%s\", s + 1);\n    scanf(\"%s\", a + 1);\n    a[0] = s[0] = '$';//否则strlen函数失效\n    lena = strlen(a) - 1, lens = strlen(s) - 1;\n    getnext();\n    kmp();\n}\n```\n\n### AC自动机\n\n常数巨大需要修改\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst int INF = 0x3f3f3f3f;\nconst int maxn = 1e6 + 9;\nstruct Trie\n{\n    int next[500010][26], fail[500010], end[500010];\n    int root, L;\n    int newnode()\n    {\n        for (int i = 0; i < 26; i++)\n            next[L][i] = -1;\n        end[L++] = 0;\n        return L - 1;\n    }\n    void init()\n    {\n        L = 0;\n        root = newnode();\n    }\n    void insert(char buf[])\n    {\n        int len = strlen(buf);\n        int now = root;\n        for (int i = 0; i < len; i++)\n        {\n            if (next[now][buf[i] - 'a'] == -1)\n                next[now][buf[i] - 'a'] = newnode();\n            now = next[now][buf[i] - 'a'];\n        }\n        end[now]++;\n    }\n    void build()\n    {\n        queue<int> Q;\n        fail[root] = root;\n        for (int i = 0; i < 26; i++)\n            if (next[root][i] == -1)\n                next[root][i] = root;\n            else\n            {\n                fail[next[root][i]] = root;\n                Q.push(next[root][i]);\n            }\n        while (!Q.empty())\n        {\n            int now = Q.front();\n            Q.pop();\n            for (int i = 0; i < 26; i++)\n                if (next[now][i] == -1)\n                    next[now][i] = next[fail[now]][i];\n                else\n                {\n                    fail[next[now][i]] = next[fail[now]][i];\n                    Q.push(next[now][i]);\n                }\n        }\n    }\n    int query(char buf[])\n    {\n        int len = strlen(buf);\n        int now = root;\n        int res = 0;\n        for (int i = 0; i < len; i++)\n        {\n\n            now = next[now][buf[i] - 'a'];\n            int temp = now;\n            while (temp != root)\n            {\n                res += end[temp];\n                end[temp] = 0;\n                temp = fail[temp];\n            }\n        }\n        return res;\n    }\n    void debug()\n    {\n        for (int i = 0; i < L; i++)\n        {\n            printf(\"id = %3d,fail = %3d,end = %3d,chi = [\", i, fail[i], end[i]);\n            for (int j = 0; j < 26; j++)\n                printf(\"%2d\", next[i][j]);\n            printf(\"]\\n\");\n        }\n    }\n};\nchar buf[maxn];\nTrie ac;\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    ac.init();\n    for (int i = 0; i < n; i++)\n    {\n        scanf(\"%s\", buf);\n        ac.insert(buf);\n    }\n    ac.build();\n    scanf(\"%s\", buf);\n    printf(\"%d\\n\", ac.query(buf));\n    return 0;\n}\n```\n\n### Manacher\n\n待修改\n\n```c++\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nchar str[11000005],str_new[11000005];\nint p[22000020],len;\nvoid init()\n{\n    int t=2;\n    len=strlen(str);\n    str_new[0]='@';\n    str_new[1]='#';\n    for(int i=0; i<len; i++)\n    {\n        str_new[t++]=str[i];\n        str_new[t++]='#';\n    }\n    str_new[t]='$';\n}\nvoid Manacher()\n{\n    memset(p,0,sizeof(p));\n    int mid,ans=0,r=0;\n    for(int i=1;i<len*2+2;i++)\n    {\n        if(i<r)\n            p[i]=p[2*mid-i]<(r-i)?p[2*mid-i]:r-i;\n        else\n            p[i]=1;\n        for(;str_new[i-p[i]]==str_new[i+p[i]];p[i]++);\n        if(i+p[i]>r)\n            mid=i,r=i+p[i];\n        if(p[i]>ans)\n            ans=p[i];\n    }\n    printf(\"%d\\n\",--ans);\n}\nint main()\n{\n    scanf(\"%s\",str);\n    init();\n    Manacher();\n    return 0;\n}\n```\n\n## 图论\n\n### MST-Kruskal\n\n```c++\nstruct edge{\n    int x, y, w;\n    bool operator<(const edge &b) const{\n        return w < b.w;\n    }\n};\nint n, m, fa[maxn], k;\nint find(int x)\n{\n    return fa[x] == x ? x : fa[x] = find(fa[x]);\n}\nvoid join(int x, int y){\n    int tx = find(x), ty = find(y);\n    if (tx != ty)\n        fa[tx] = ty;\n}\nedge e[maxn];\nvoid kruskal(){\n    for (int i = 1; i <= n; ++i)\n        fa[i] = i;\n    sort(e + 1, e + m + 1);\n    for (int i = 1; i <= m; ++i){\n        edge t = e[i];\n        if (find(t.x) == find(t.y))\n            continue;\n        join(t.x, t.y);\n    }\n}\n```\n\n### 树链剖分\n\n```c++\nint n, m, root, mod;\nint head[maxn], to[maxn], nxt[maxn], tot = 0;\ninline void add(int u, int v)\n{\n    to[++tot] = v;\n    nxt[tot] = head[u];\n    head[u] = tot;\n}\n\nint son[maxn], id[maxn], fa[maxn], cnt, dep[maxn], sz[maxn], top[maxn];\nint w[maxn], wt[maxn];\n\nstruct segtree\n{\n    int tree[maxn << 2], tag[maxn << 2];\n    void push_up(int p)\n    {\n        tree[p] = (tree[p << 1] + tree[p << 1 | 1]) % mod;\n    }\n    void build(int p, int l, int r)\n    {\n        tag[p] = 0;\n        if (l == r)\n        {\n            tree[p] = wt[l] % mod;\n            return;\n        }\n        int mid = (l + r) >> 1;\n        build(p << 1, l, mid);\n        build(p << 1 | 1, mid + 1, r);\n        push_up(p);\n    }\n    void flag(int p, int l, int r, int k)\n    {\n        tag[p] = (tag[p] + k) % mod;\n        tree[p] += k * (r - l + 1);\n        tree[p] %= mod;\n    }\n    void push_down(int p, int l, int r)\n    {\n        int mid = (l + r) >> 1;\n        flag(p << 1, l, mid, tag[p]);\n        flag(p << 1 | 1, mid + 1, r, tag[p]);\n        tag[p] = 0;\n    }\n    void update(int p, int l, int r, int ul, int ur, int k)\n    {\n        if (ul <= l && ur >= r)\n        {\n            tree[p] += k * (r - l + 1);\n            tag[p] += k;\n            tree[p] %= mod;\n            tag[p] %= mod;\n            return;\n        }\n        push_down(p, l, r);\n        int mid = (l + r) >> 1;\n        if (ul <= mid)\n            update(p << 1, l, mid, ul, ur, k);\n        if (ur > mid)\n            update(p << 1 | 1, mid + 1, r, ul, ur, k);\n        push_up(p);\n    }\n    int query(int p, int l, int r, int qx, int qy)\n    {\n        if (qx <= l && qy >= r)\n            return tree[p];\n        int ans = 0, mid = (l + r) >> 1;\n        push_down(p, l, r);\n        if (qx <= mid)\n            ans += query(p << 1, l, mid, qx, qy), ans %= mod;\n        if (qy > mid)\n            ans += query(p << 1 | 1, mid + 1, r, qx, qy), ans %= mod;\n        return ans;\n    }\n};\nsegtree tree;\n\nvoid dfs1(int p, int f, int d)\n{\n    dep[p] = d;\n    fa[p] = f;\n    sz[p] = 1;\n    int maxson = -1;\n    for (int i = head[p]; i; i = nxt[i])\n    {\n        int y = to[i];\n        if (y == f)\n            continue;\n        dfs1(y, p, d + 1);\n        sz[p] += sz[y];\n        if (sz[y] > maxson)\n            son[p] = y, maxson = sz[y];\n    }\n}\n\nvoid dfs2(int p, int topf)\n{\n    id[p] = ++cnt;\n    wt[cnt] = w[p];\n    top[p] = topf;\n    if (son[p] == 0)\n        return;\n    dfs2(son[p], topf);\n    for (int i = head[p]; i; i = nxt[i])\n    {\n        int y = to[i];\n        if (y == fa[p] || y == son[p])\n            continue;\n        dfs2(y, y);\n    }\n}\n\nint query(int l, int r)\n{\n    int ans = 0;\n    while (top[l] != top[r])\n    {\n        if (dep[top[l]] < dep[top[r]])\n            swap(l, r);\n        ans += tree.query(1, 1, n, id[top[l]], id[l]);\n        ans %= mod;\n        l = fa[top[l]];\n    }\n    if (dep[l] > dep[r])\n        swap(l, r);\n    ans += tree.query(1, 1, n, id[l], id[r]);\n    return ans % mod;\n}\n\nvoid update(int l, int r, int k)\n{\n    k %= mod;\n    while (top[l] != top[r])\n    {\n        if (dep[top[l]] < dep[top[r]])\n            swap(l, r);\n        tree.update(1, 1, n, id[top[l]], id[l], k);\n        l = fa[top[l]];\n    }\n    if (dep[l] > dep[r])\n        swap(l, r);\n    tree.update(1, 1, n, id[l], id[r], k);\n}\n\ninline int qson(int p)\n{\n    return tree.query(1, 1, n, id[p], id[p] + sz[p] - 1);\n}\n\ninline void upson(int p, int k)\n{\n    tree.update(1, 1, n, id[p], id[p] + sz[p] - 1, k);\n}\n\nsigned main()\n{\n    read(n), read(m), read(root), read(mod);\n    int op, u, v, k;\n    for (int i = 1; i <= n; ++i)\n        read(w[i]);\n    for (int i = 1; i < n; ++i)\n    {\n        read(u), read(v);\n        add(u, v), add(v, u);\n    }\n    dfs1(root, 0, 1);\n    dfs2(root, root);\n    tree.build(1, 1, n);\n    while (m--)\n    {\n        read(op);\n        if (op == 1)\n        {\n            read(u), read(v), read(k);\n            update(u, v, k);\n        }\n        else if (op == 2)\n        {\n            read(u), read(v);\n            cout << query(u, v) << '\\n';\n        }\n        else if (op == 3)\n        {\n            read(u), read(k);\n            upson(u, k);\n        }\n        else\n        {\n            read(u);\n            cout << qson(u) << '\\n';\n        }\n    }\n    return 0;\n}\n```\n\n\n\n## 计算几何\n\n`const double eps = 1e-8;`\n\n### 点\n\n```c++\nint sgn(double x){\n    if (fabs(x) < eps) return 0;\n    if (x < 0) return -1;\n    return 1;\n}\nstruct point{\n    double x, y;\n    point() {}\n    point(double x, double y) : x(x), y(y) {}\n    point operator+(const point &p) const {\n        point new_p(x + p.x, y + p.y);\n        return new_p;\n    }\n    point operator-(const point &p) const {\n        point new_p(x - p.x, y - p.y);\n        return new_p;\n    }\n    point operator|(const double &p) const {\n        point new_p(x * p, y * p);\n        return new_p;\n    }\n    point operator/(const double &p) const {\n        point new_p(x / p, y / p);\n        return new_p;\n    }\n    bool operator==(const point &p) const {\n        return sgn(x - p.x) == 0 && sgn(y - p.y) == 0;\n    }\n    double operator*(const point &p) const {\n        return x * p.x + y * p.y;\n    }\n    double operator^(const point &p) const {\n        return x * p.y - y * p.x;\n    }\n    double len() {\n        return sqrt(x * x + y * y);\n    }\n    void print() {\n        cout << x << ' ' << y << '\\n';\n    }\n};\ndouble dist(const point &a, const point &b){\n    return sqrt((a - b) * (a - b));\n}\ntypedef point vec;\n```\n\n### 二维凸包\n\n#### Graham算法\n\n```c++\nconst int maxn = 1e5 + 10;\npoint pt[maxn];\nint Stack[maxn], top;\nbool _cmp(point p1, point p2){\n    double tmp = (p1 - pt[0]) ^ (p2 - pt[0]);\n    if (sgn(tmp) > 0)\n        return true;\n    else if (sgn(tmp) == 0 && sgn(dist(p1, pt[0]) - dist(p2, pt[0])) <= 0)\n        return true;\n    else\n        return false;\n}\nvoid Graham(int n)\n{\n    point p0;\n    int k = 0;\n    p0 = pt[0];\n    for (int i = 1; i < n; i++){\n        if ((p0.y > pt[i].y) || (p0.y == pt[i].y && p0.x > pt[i].x)){\n            p0 = pt[i];\n            k = i;\n        }\n    }\n    swap(pt[k], pt[0]);\n    sort(pt + 1, pt + n, _cmp);\n    if (n == 1){\n        top = 1;\n        Stack[0] = 0;\n        return;\n    }\n    if (n == 2){\n        top = 2;\n        Stack[0] = 0;\n        Stack[1] = 1;\n        return;\n    }\n    Stack[0] = 0;\n    Stack[1] = 1;\n    top = 2;\n    for (int i = 2; i < n; i++){\n        while (top > 1 && \n               sgn((pt[Stack[top - 1]] - pt[Stack[top - 2]]) ^ (pt[i] - pt[Stack[top - 2]])) <= 0)\n            top--;\n        Stack[top++] = i;\n    }\n}\n```\n\n## 数据结构\n\n### 线段树\n\n```c++\nint a[maxn];\n\nstruct segtree\n{\n    int tree[maxn << 2], tag[maxn << 2];\n    void push_up(int p)\n    {\n        tree[p] = tree[p << 1] + tree[p << 1 | 1];\n    }\n    void build(int p, int l, int r)\n    {\n        tag[p] = 0;\n        if (l == r)\n        {\n            tree[p] = a[l];\n            return;\n        }\n        int mid = (l + r) >> 1;\n        build(p << 1, l, mid);\n        build(p << 1 | 1, mid + 1, r);\n        push_up(p);\n    }\n    void flag(int p, int l, int r, int k)\n    {\n        tag[p] += k;\n        tree[p] += k * (r - l + 1);\n    }\n    void push_down(int p, int l, int r)\n    {\n        int mid = (l + r) >> 1;\n        flag(p << 1, l, mid, tag[p]);\n        flag(p << 1 | 1, mid + 1, r, tag[p]);\n        tag[p] = 0;\n    }\n    void update(int p, int l, int r, int ul, int ur, int k)\n    {\n        if (ul <= l && ur >= r)\n        {\n            tree[p] += k * (r - l + 1);\n            tag[p] += k;\n            return;\n        }\n        push_down(p, l, r);\n        int mid = (l + r) >> 1;\n        if (ul <= mid)\n            update(p << 1, l, mid, ul, ur, k);\n        if (ur > mid)\n            update(p << 1 | 1, mid + 1, r, ul, ur, k);\n        push_up(p);\n    }\n    int query(int p, int l, int r, int qx, int qy)\n    {\n        if (qx <= l && qy >= r)\n            return tree[p];\n        int ans = 0, mid = (l + r) >> 1;\n        push_down(p, l, r);\n        if (qx <= mid)\n            ans += query(p << 1, l, mid, qx, qy);\n        if (qy > mid)\n            ans += query(p << 1 | 1, mid + 1, r, qx, qy);\n        return ans;\n    }\n};\n```\n\n### 划分树\n\n静态区间第 $k$ 小\n\n```c++\nconst int maxn = 2e5 + 9;\n\nint tree[30][maxn];\nint sorted[maxn];\nint toleft[30][maxn];\n\nvoid build(int l, int r, int dep)\n{\n    if (l == r)\n        return;\n    int mid = (l + r) >> 1;\n    int same = mid - l + 1;\n    for (int i = l; i <= r; ++i)\n        if (tree[dep][i] < sorted[mid])\n            same--;\n    int lpos = l, rpos = mid + 1;\n    for (int i = l; i <= r; ++i)\n    {\n        if (tree[dep][i] < sorted[mid])\n            tree[dep + 1][lpos++] = tree[dep][i];\n        else if (tree[dep][i] == sorted[mid] && same > 0)\n        {\n            tree[dep + 1][lpos++] = tree[dep][i];\n            same--;\n        }\n        else\n            tree[dep + 1][rpos++] = tree[dep][i];\n        toleft[dep][i] = toleft[dep][l - 1] + lpos - l;\n    }\n    build(l, mid, dep + 1);\n    build(mid + 1, r, dep + 1);\n}\nint query(int l, int r, int x, int y, int dep, int k)\n{\n    if (x == y)\n        return tree[dep][x];\n    int mid = (l + r) >> 1;\n    int cnt = toleft[dep][y] - toleft[dep][x - 1];\n    if (cnt >= k)\n    {\n        int newx = l + toleft[dep][x - 1] - toleft[dep][l - 1];\n        int newy = newx + cnt - 1;\n        return query(l, mid, newx, newy, dep + 1, k);\n    }\n    else\n    {\n        int newy = y + toleft[dep][r] - toleft[dep][y];\n        int newx = newy - (y - x - cnt);\n        return query(mid + 1, r, newx, newy, dep + 1, k - cnt);\n    }\n}\nsigned main()\n{\n    int n, m;\n    read(n), read(m);\n    //memset(tree, 0, sizeof(tree));\n    for (int i = 1; i <= n; ++i)\n    {\n        read(tree[0][i]);\n        sorted[i] = tree[0][i];\n    }\n    sort(sorted + 1, sorted + n + 1);\n    build(1, n, 0);\n    while (m--)\n    {\n        int l, r, k;\n        read(l), read(r), read(k);\n        cout << query(1, n, l, r, 0, k) << '\\n';\n    }\n    return 0;\n}\n```\n\n### 左偏树\n\n可并堆\n\n```c++\nconst int maxn = 1e5 + 9;\n\nstruct Tree\n{\n    int dis, val, root, ls, rs;\n};\n\nstruct Leftist_Tree\n{\n    Tree lt[maxn];\n    int merge(int x, int y)\n    {\n        if (!x || !y)\n            return x + y;\n        if (lt[x].val > lt[y].val || (lt[x].val == lt[y].val && x > y))\n            swap(x, y);\n        lt[x].rs = merge(lt[x].rs, y);\n        if (lt[lt[x].ls].dis < lt[lt[x].rs].dis)\n            swap(lt[x].ls, lt[x].rs);\n        lt[lt[x].ls].root = x;\n        lt[lt[x].rs].root = x;\n        lt[x].root = x;\n        lt[x].dis = lt[lt[x].rs].dis + 1;\n        return x; //root\n    }\n    int find(int x)\n    {\n        return lt[x].root == x ? x : lt[x].root = find(lt[x].root);\n    }\n    int top(int x)\n    {\n        return lt[x].val;\n    }\n    void pop(int x)\n    {\n        lt[x].val = -1;\n        lt[lt[x].ls].root = lt[x].ls;\n        lt[lt[x].rs].root = lt[x].rs;\n        lt[x].root = merge(lt[x].ls, lt[x].rs);\n    }\n};\nLeftist_Tree t;\n\nsigned main()\n{\n    int n, m;\n    read(n), read(m);\n    t.lt[0].dis = -1;\n    for (int i = 1; i <= n; ++i)\n    {\n        t.lt[i].root = i;\n        read(t.lt[i].val);\n    }\n    while (m--)\n    {\n        int op, x, y;\n        read(op);\n        if (op == 1)\n        {\n            read(x), read(y);\n            if (t.lt[x].val == -1 || t.lt[y].val == -1)\n                continue;\n            int fx = t.find(x), fy = t.find(y);\n            if (fx != fy)\n            {\n                int p = t.merge(fx, fy);\n                t.lt[fx].root = p;\n                t.lt[fy].root = p;\n            }\n        }\n        else\n        {\n            read(x);\n            if (t.lt[x].val == -1)\n                puts(\"-1\");\n            else\n            {\n                cout << t.top(t.find(x)) << '\\n';\n                t.pop(t.find(x));\n            }\n        }\n    }\n    return 0;\n}\n```\n\n\n\n## 优化\n\n### 普通快读\n\n```c++\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\n```\n\n### 究极版\n\n```c++\nchar nc()\n{\n    static char buf[100000], *p1, *p2;\n    return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++;\n}\ninline int read()\n{\n    register int x = 0;\n    register char a = nc();\n    while (a < '0' || a > '9')\n        a = nc();\n    while (a >= '0' && a <= '9')\n        x = x * 10 + a - '0', a = nc();\n    return x;\n}\nchar pbuf[10000000], *pp = pbuf;\ninline void write(int x)\n{\n    static int sta[35];\n    register int top = 0;\n    if (!x)\n        sta[++top] = 0;\n    while (x)\n        sta[++top] = x % 10, x /= 10;\n    while (top)\n        *pp++ = sta[top--] ^ '0';\n}\n```\n\n输入用法：`int n=read()`\n\n输出用法：\n\n```c++\nfor(int i=1;i<=n;++i)\n\twrite(ans[i]), *pp++ = '\\n';//答案后面换行或者空格\nfwrite(pbuf, 1, pp - pbuf, stdout);//最后用这个\n```\n\n","tags":["模板"]},{"title":"CF#663div2总结","url":"/2020/08/10/CF663div2/","content":"\n帽子戏法！\n\n<!--more-->\n\n## A\n\n本来是一眼题，结果因为前一天做了一道求异或和的题，把这里的 `or` 也都看成 `xor` 了，浪费 $5$ 分钟。**首杀**。\n\n## B\n\n也是水题，结果看成只需要满足一条从左上角到右下角的路线，先打了个DFS+剪枝，发现第三个样例输出是3，代码看起来也没什么问题，就又写了个 $O(mn)$ 的DP，发现第三个样例输出还是3。。。然后才发现是题目读错了。浪费 $50$ 分钟。**梅开二度**。\n\n## C\n\n很简单的组合数学题，推到4就已经很清楚了，$S_n=n\\cdot S_{n-1}+(n-2)[(n-1)!-S_{n-1}]$，整理一下可以得到 $S_n=(n-2)(n-1)!+2S_{n-1}$，甚至可以得到通项公式 $S_n=n!-2^{n-1}$。但是把模数看成了数据范围，$O(n)$ 的递推式列出来以后还想了半天怎么优化复杂度，浪费 $5$ 分钟。**帽子戏法**。\n\n## D\n\n前三道题已经浪费了一个小时了，留给D的时间已经不多了，虽然D的性质也很显然，排除 $\\min(m,n)\\ge 4$ 的和 $\\min(m,n)=1$ 的情况以后随便什么状压DP之类的都可以做的，但是最后还是来不及调了，遗憾。\n\n## E\n\n根本来不及看，虽然看了估计也做不出来，好像是树剖之类的题。\n\n\n\n一共两个小时的比赛，理解错题意导致浪费一个小时，那还比个P。最近几场CF会做的题总是不能全过，经常因为各种奇怪的原因做不完或者做错。这也不是要提高算法之类的的能力了，或许要多做做各种题目提升一下审题能力和代码能力，尤其是手速和debug速度。如果能稳定发挥的话上个蓝名应该已经不是问题了。\n\n\n\n状态什么时候能好呢。。。\n\n![83493912](https://i.loli.net/2020/08/10/r3efvqXE7OjP5wL.jpg)\n\n","tags":["CodeForces"]},{"title":"2020暑假训练整合（已完结）","url":"/2020/08/09/2020Summer/","content":"\n7月20日开始暑假训练\n\n<!--more-->\n\n**由于CSDN比较稳定，每天的题解笔记之类放在CSDN上**\n\n- 7月20日 STL、分治、贪心等\n  - [2020暑期训练1](https://blog.csdn.net/Pastafarian/article/details/107474375)\n- 7月21日 基础DP\n  - [2020暑期训练2](https://blog.csdn.net/Pastafarian/article/details/107512800)\n- 7月22日 基础数据结构\n  - [2020暑期训练3](https://blog.csdn.net/Pastafarian/article/details/107543109)\n- 7月23日 数论\n  - [2020暑期训练4](https://blog.csdn.net/Pastafarian/article/details/107593890)\n- 7月26日 DP优化\n  - [2020暑期训练5](https://blog.csdn.net/Pastafarian/article/details/107620694)\n- 7月27日 图论\n  - [2020暑期训练6](https://blog.csdn.net/Pastafarian/article/details/107645822)\n- 7月28日 字符串\n  - [2020暑期训练7](https://blog.csdn.net/Pastafarian/article/details/107694716)\n- 7月29日 计算几何基础\n  -   [2020暑期训练8](https://blog.csdn.net/Pastafarian/article/details/107764056)\n- 7月31日 组合数学\n  - [2020暑期训练9](https://blog.csdn.net/Pastafarian/article/details/107788906)\n- 8月2日 概率\n  - [2020暑期训练10](https://blog.csdn.net/Pastafarian/article/details/107885231)\n\n[以及慢慢更新的模板整理](https://phlzy.github.io/2020/08/12/Template/)\n\n![200723.jpg](https://i.loli.net/2020/07/23/Cx7nHkT4QsElFOj.jpg)\n\n","tags":["其它"]},{"title":"洛谷8月月赛Idiv2","url":"/2020/08/08/LGR-074div2/","content":"\n和上次一样先口胡一些思路，等题解出了以后再做完善。\n\n<!--more-->\n\n## A&B\n\nA没啥好说的，直接上代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint num[600];\nsigned main()\n{\n    int k;\n    ll x;\n    cin >> k >> x;\n    num[k + 1] = 1;\n    int cnt = 0;\n    while (x)\n    {\n        num[++cnt] += x % 10;\n        x /= 10;\n        if (num[cnt] > 9)\n        {\n            num[cnt + 1] += num[cnt] / 10;\n            num[cnt] %= 10;\n        }\n    }\n    if (num[cnt + 1] > 0)\n        cnt++;\n    for (int i = max(k + 1, cnt); i > 0; --i)\n        cout << num[i];\n    return 0;\n}\n```\n\nB找一下规律：\n\n- 全 `0` 的时候直接结束；\n- 其中一个为 `0` 的时候用 `0` 去乘大数，另一个数字除完向下取整；\n- 两个相等的时候：\n  - 一起减一下就好了\n  - 或者先把一个除成 `0`，再处理另一个\n- 其他情况：\n  - 乘除一次把两个变成一样的\n  - 或者像上面一样先把一个除成 `0`，再处理另一个\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nsigned main()\n{\n    ll a, b, c, d;\n    cin >> a >> b >> c >> d;\n    if (a * b == 0)\n    {\n        if (a == b)\n            cout << 0;\n        else\n            cout << d;\n        return 0;\n    }\n    if (a == b)\n        cout << min(c, d + d);\n    else\n        cout << min(c + d, d + d);\n    return 0;\n}\n```\n\n这次的AB非常简单。\n\n## C\n\n很明显是按位处理，但是被我写挂了：\n\n- $m$ 的最大范围达到了 $2^{30}\\times 10^6$，很明显用 `long long`，结果脑子一抽写了 `__int128_t`，又顺便写了个输出函数，将问题大大复杂化；\n- 解法是统计每一位的 `1` 的个数，顺便算出最小需要的 $m$ 大小，如果大于询问的 $m$ 直接输出 `-1`，否则从高位到低位进行dfs，搜到的第一个答案就是最大的 $k$；\n- 然后我好像又双叒叕死在搜索上了。\n\n附上怎么都调不对的代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\nint tmp[100];\ntemplate <typename T>\ninline void write(T x)\n{\n    int cnt = 0;\n    if (x < 0)\n    {\n        x = -x;\n        putchar('-');\n    }\n    do\n    {\n        tmp[++cnt] = x % 10;\n    } while (x /= 10);\n    while (cnt)\n        putchar('0' + tmp[cnt--]);\n    putchar('\\n');\n}\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 1e5 + 9;\nint tot[35], tot1[35];\n__int128_t ret, m, num[35][2], mintot;\nbool vis[35];\nvoid dfs(int d, __int128_t sum)\n{\n    if (d < 0)\n    {\n        for (int i = 0; i <= 30; ++i)\n            if (vis[i])\n                ret += ((__int128_t)1 << i);\n        return;\n    }\n    if (sum > m || ret != 0)\n    {\n        //write(ret);\n        return;\n    }\n    //write(sum);\n    vis[d] = true;\n    dfs(d - 1, sum + num[d - 1][1]);\n    vis[d] = false;\n    dfs(d - 1, sum + num[d - 1][0]);\n    return;\n}\nsigned main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"data.txt\",\"w\",stdout);\n    //std::ios::sync_with_stdio(false);\n    //std::cin.tie(0);\n    //std::cout.tie(0);\n    ull n, q, a;\n    read(n);\n    for (int i = 1; i <= n; ++i)\n    {\n        read(a);\n        for (int j = 0; j <= 30; ++j)\n            if (a >> j & 1)\n                tot[j]++;\n    }\n    mintot = 0;\n    for (int j = 0; j <= 30; ++j)\n    {\n        num[j][1] = (__int128_t)(1 << j) * (__int128_t)(n - tot[j]);\n        num[j][0] = (__int128_t)(1 << j) * (__int128_t)tot[j];\n        mintot += min((__int128_t)(1 << j) * (__int128_t)tot[j], (__int128_t)(1 << j) * (__int128_t)(n - tot[j]));\n    }\n    //write(mintot);\n    read(q);\n    while (q--)\n    {\n        read(m);\n        if (m < mintot)\n        {\n            puts(\"-1\");\n            continue;\n        }\n        for (int i = 0; i <= 30; ++i)\n            vis[i] = false;\n        ret = 0;\n        dfs(31, 0);\n        ret = ((m >> 31) << 31) + ret;\n        write(ret);\n    }\n    //fclose(stdin);\n    //fclose(stdout);\n    return 0;\n}\n```\n\n\n\n## D\n\n第一眼看到的想法：既然是树，就可以从叶子结点开始一层一层处理，先把所有连接叶子结点的边权求出来，然后把叶子结点全部摘掉并重复上一步过程。\n\n当然这样做肯定是不对的：\n\n![200808.png](https://i.loli.net/2020/08/08/Y6kJL4IsQofepHz.png)\n\n比方说这个图按照这个做法就是不可行的。\n\n所以应该还是要根据父亲结点的值做一些调整。\n\n具体解法等官方题解出来再说，这题我也没写代码。\n\n要多练练搜索了，DP和简单的图论也要做一做。\n\n![83492606.jpg](https://i.loli.net/2020/08/08/hWmVtilwrdPRgox.jpg)","tags":["洛谷"]},{"title":"CF1399D题解","url":"/2020/08/07/CF1399D-Solution/","content":"\n构造，模拟？[链接](https://codeforces.com/problemset/problem/1399/D) [或者在洛谷看](https://www.luogu.com.cn/problem/CF1399D)\n\n<!--more-->\n\n比赛的时候做出来了，后来看了很多题解发现我的理解似乎比较独特，就记录一下（做法本质上是一样的）。\n\n我们可以让一个点根据原序列的内容进行移动，将这个问题转化为下面的形式：\n\n假设在平面直角坐标系中有一个点坐标为 $(x,y)$，当走到序列的下一个元素时，如果是 `0` 该点就移动到 $(x+1,y-1)$ 处，如果是 `1` 该点就移动到 $(x+1,y+1)$ 处。为了便于模拟，我们让这个点的初始状态位于原点。\n\n显然，这个点的运动轨迹是一条折线，而且终点在 $(n,num_1-num_0)$。$k$ 的最小值就是折线最高点和最低点之间的距离。这 $k$ 个子序列也可以用它们的纵坐标来表示，画个图稍作推导即可得出。\n\n代码如下：\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 9;\nint ans[maxn];\nunordered_map<int, int> mp;\nint main()\n{\n    int T;\n    scanf(\"%d\", &T);\n    while (T--)\n    {\n        int n, x;\n        scanf(\"%d\", &n);\n        mp.clear();\n        int h = 0, maxx = 0, minn = 0, cnt = 0;\n        for (int i = 1; i <= n; ++i)\n        {\n            scanf(\"%1d\", &x);\n            if (x == 1)\n                h++;\n            else\n                h--;\n            if (h > 0)\n            {\n                if (h > maxx)\n                    mp[h] = ++cnt, maxx = h;//更新最高点高度\n                ans[i] = h;\n                if (x == 0)\n                    ans[i]++;\n            }\n            else if (h < 0)\n            {\n                if (h < minn)\n                    mp[h] = ++cnt, minn = h;//更新最低点高度\n                ans[i] = h;\n                if (x == 1)\n                    ans[i]--;\n            }\n            else\n            {\n                if (x == 1)\n                    ans[i] = -1;\n                else\n                    ans[i] = 1;\n            }\n        }\n        printf(\"%d\\n\", cnt);\n        for (int i = 1; i <= n; ++i)\n            printf(\"%d \", mp[ans[i]]);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n```\n","tags":["CodeForces"]},{"title":"【胡思乱想】如果给Trie增加索引","url":"/2020/08/04/nonsense-index-trie/","content":"\n[P1019单词接龙](https://www.luogu.com.cn/problem/P1019)是一个DFS的题，但是前几天看了AC自动机的东西总觉得可以结合Trie来搞一搞，所以就把这个奇怪的想法写下来了。\n\n**注意：本文只是随手记下突然产生的一个想法，因此内容质量可能非常低！**\n\n<!--more-->\n\n比方说有以下这7个单词，然后从字母a开始接龙：\n\n1. egg\n2. ksi\n3. simple\n4. apple\n5. kk\n6. eioua\n7. abba\n\n我们可以先构建一棵Trie，把单词按顺序插进去，就像这样：\n\n![200804101901.jpg](https://i.loli.net/2020/08/04/mcplDiXs72HjKwJ.jpg)\n\n这是普通的Trie的构造过程，我们可以对其结点进行以下魔改：\n\n```c++\nstruct node\n{\n    int son[26];\n    int isword, cnt, index[maxn];//或许用vector更好\n    node()\n    {\n        cnt = 0;\n        isword = 0;\n        memset(son, 0, sizeof(son));\n        memset(index, 0, sizeof(index));\n    }\n};\n```\n\n在结点中加入一个索引，当所有单词插入完毕后，进行检验：\n\n从第一个单词的最后一个字母开始，检查能否连接到新的单词头上（包括自己）\n\n然后Trie就会变成这样：\n\n![200804101902.jpg](https://i.loli.net/2020/08/04/2j4BdICiTkJYZR5.jpg)\n\n这样我们的DFS会比较容易，但是也有一个弊端：我们可能难以统计单词的经过次数。\n\n为了解决这个问题，可以把所有不是从叶子结点的索引全部放到叶子结点，由于叶子结点有 `isword` 标记可以判断单词是哪一个，就可以统计次数了。也就是说把上图第二个索引改为 `6->8` 即可。\n\n但是我认为这样做的时间复杂度非常差，并且这个在叶子结点增加了索引的Trie似乎也没有其他有趣的功能。这个看起来并没有什么用的东西可能真的没有什么用。\n\n这个做法理论上应该是可行的，但是比写DFS麻烦太多了，所以我也没有去实现，就在这里记录一下我的想法好了。\n\n顺便附上DFS代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 1e5 + 9;\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\nint vis[21];\nstring t[21], str;\nint check(string a, string b)\n{\n    for (int i = a.size() - 1; i >= 0; i--)\n    {\n        if (a[i] == b[0])\n        {\n            int len = i;\n            for (int j = 0; j < b.size(); j++)\n            {\n                if (a[len] == b[j])\n                    len++;\n                else\n                    break;\n            }\n            if (len == a.size())\n                return len - i;\n        }\n    }\n    return 0;\n}\nint n, ans = 0;\nvoid dfs(int dul, string a)\n{\n    ans = max(ans, (int)a.size() - dul);\n    for (int i = 1; i <= n; i++)\n    {\n        if (vis[i] > 1)\n            continue;\n        int d = check(a, t[i]);\n        if (d == 0)\n            continue;\n        vis[i]++;\n        dfs(dul + d, a + t[i]);\n        vis[i]--;\n    }\n    return;\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"data.txt\",\"w\",stdout);\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n        cin >> t[i];\n    cin >> str;\n    dfs(0, str);\n    cout << ans << '\\n';\n    //fclose(stdin);\n    //fclose(stdout);\n    return 0;\n}\n```\n\n这篇乱七八糟的文章就不放图了\n\n最后修改于2020-08-06","tags":["其它"]},{"title":"单调队列优化DP等","url":"/2020/08/02/P2034P2627/","content":"\n\n\n### 算法简介\n\n以[P2034 选择数字](https://www.luogu.com.cn/problem/P2034)和[P2627 [USACO11OPEN]Mowing the Lawn G](https://www.luogu.com.cn/problem/P2627)为例（双倍经验）总结一下单调队列优化DP和一些其它的东西。\n\n<!--more-->\n\n## 单调队列优化\n\n给出 $n$ 个非负整数，选若干个数，其中不能有超过 $k$ 个连续的数被选，需要使选出的数字和最大。也就是说，连续的 $k+1$ 个数中必然会被丢掉至少一个。\n\n显然我们只要让被丢掉的数的和最小，用总和减去这个最小值就能求出答案了。因此最初的状态转移方程是这样的：\n\n$$dp[i]=num[i]+\\min(dp[i-1],dp[i-2],\\cdots,dp[i-k])$$\n\n其中 $dp[i]$ 就表示如果丢掉第 $i$ 个数，前 $i$ 个数中被丢掉的总和。\n\n这样做的时间复杂度是 $O(nk)$，在这题的数据范围下几乎不可能通过。\n\n因此我需要对这个过程进行优化，上面做法浪费时间的原因在于求区间最小值的时候重复了很多次，可以用单调队列把这些多余的过程优化掉。\n\n构造一个从队首到队尾单调递增的单调队列，每次将新元素入队前把比它大的元素全部从队尾弹出，放入新元素，再把与当前位置距离超过 $k$ 的从队首弹出。这样每次计算 $dp[i]$ 的时候只需要从队首拿出元素加上去就可以了。\n\n代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst int INF = 0x3f3f3f3f;\nconst int maxn = 1e5 + 9;\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\nstruct node\n{\n    ull sum;\n    int n;\n    node() { sum = 0, n = 0; }\n    node(ull a, int b) : sum(a), n(b) {}\n};\ndeque<node> dq;\null dp[maxn];\nint main()\n{\n    int n, k;\n    read(n), read(k);\n    ull sum = 0, ans = 0;\n    dq.push_back(node(0, 0));\n    for (int i = 1; i <= n; ++i)\n    {\n        read(dp[i]);\n        sum += dp[i];\n        if (!dq.empty())\n            dp[i] += dq.front().sum;\n        while (!dq.empty() && dq.back().sum >= dp[i])\n            dq.pop_back();\n        dq.push_back(node(dp[i], i));\n        while (!dq.empty() && dq.front().n < i - k)\n            dq.pop_front();\n    }\n    for (int i = n - k; i <= n; ++i)\n        ans = max(ans, sum - dp[i]);\n    cout << ans << '\\n';\n    return 0;\n}\n```\n\n其中 `dq.push_back(node(0, 0));` 是必要的，否则dp数列从一开始就会错掉。\n\n\n\n当然，在 $k$ 非常小的时候，就不需要用单调队列，直接用上面的状态转移方程就好了。\n\n## 线段树优化\n\n因为要查询区间最小值，所以直接用线段树来维护，代替单调队列，代码更长更难写，复杂度由 $O(n)$ 退化到 $O(n\\log k)$，虽然完全可以解决这个问题，但是显然被单调队列全方位吊打。\n\n## 最短路\n\n这个做法是在题解里看到的，非常有意思：\n\n由于数据范围是 $0\\lt k \\le n \\le 1\\times 10^5$，$O(n\\log^2 k)$ 也可以过。我们事先设置一个超级起点和一个超级终点，从超级起点开始走向 $1\\cdots k$ 的点，每走到点 $i$ 就走向 $i+1\\cdots 1+k+1$ 的点，直到走进超级终点为止。由于连边的操作是一个点向一个区间连边，所以依然可以使用线段树来优化，再用Dijkstra算法求最短路即可。\n\n显然这个做法比线段树优化更为复杂，速度也更慢，但是这个转化问题的思路还是比较有意义的。\n\n![200802.jpg](https://i.loli.net/2020/08/02/theHfoBYdK1JyDF.jpg)\n\n这个好像是儿子的壁纸？","tags":["洛谷"]},{"title":"Educational Round 92总结","url":"/2020/07/31/CFedu92/","content":"\n每次打比赛总是会理解错题意。\n\n[题解部分在CSDN上也发了](https://blog.csdn.net/Pastafarian/article/details/107686440)\n\n<!--more-->\n\n# A. LCM Problem\n水题，显然 $2\\times a\\le \\mathrm{lcm}(a,b) \\; , \\;b\\le \\mathrm{lcm}(a,b)$，那么就做完了。\n# B. Array Walk\n很明显是个DP，但是我调了好久才对，还是太菜了。\n推导过程如下：\n首先对于 $z=0$ 的情况，显然最终结果是 $dp_0=max_0=\\sum_{i=1}^{k+1}a_i$\n所以可以建一个前缀和数组。\n\n$z=1$的时候除了不仅可以像上面那样走，还可以选择在路程中间后退一次或者在末端后退一次。在中间后退使得路径长度减少2，中间有连续的两个块会被经过两次；在末端后退会路径长度减少1，路径的倒数第二个块经过两次。于是可以再开一个数组记录到当前位置为止的最大相邻块值的和，即$m[i] = \\max(m[i - 1], a[i - 1] + a[i])$\n那么 $max_1=\\max(pre[k-1] + m[k-1], pre[k]  + a[k-1])$\n显然，$dp_1=\\max(dp_0,max_1)$\n\n$z\\ge2$ 的时候以此类推，可以得到 $dp_i=\\max(dp_{i-1},max_i)$ 以及\n$max_i=\\max(pre[k + 1 - 2 \\times i] + i \\times m[k + 1 - 2 \\times i], pre[k + 2 - 2 \\times i] + (i - 1) \\times m[k + 2 - 2 \\times i] + a[k + 1 - 2 \\times i])$\n\n于是这题就做完了，复杂度 $O(k)$。\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst int INF = 0x3f3f3f3f;\nconst int maxn = 1e5 + 9;\ninline int read()\n{\n    int data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    return f * data;\n}\nint arr[maxn], pre[maxn], m[maxn];\n\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"data.txt\",\"w\",stdout);\n    //std::ios::sync_with_stdio(false);\n    //std::cin.tie(0);\n    int T;\n    T = read();\n    while (T--)\n    {\n        memset(m, 0, sizeof(m));\n        int n = read(), k = read(), z = read();\n        for (int i = 1; i <= n; ++i)\n        {\n            arr[i] = read();\n            pre[i] = pre[i - 1] + arr[i];\n            m[i] = max(m[i - 1], arr[i - 1] + arr[i]);\n        }\n        int ans = pre[k + 1], tmp;\n        for (int i = 1; i <= z; ++i)\n        {\n            if (k < 2 * i - 1)\n                break;\n            tmp = max(pre[k + 1 - 2 * i] + i * m[k + 1 - 2 * i], pre[k + 2 - 2 * i] + (i - 1) * m[k + 2 - 2 * i] + arr[k + 1 - 2 * i]);\n            ans = max(ans, tmp);\n        }\n        cout << ans << '\\n';\n    }\n    //fclose(stdin);\n    //fclose(stdout);\n    return 0;\n}\n```\n# C. Good String\n比赛的时候理解错了题意，试了二分和尺取法结果都过不了样例。第二天再看发现题目读错了。。。。。\n显然，满足题目要求的左移和右移后相同的序列只可能是两种：\n\n1. 所有的元素全部相同\n2. 两个不同元素交替循环，如 `0101010101`\n\n可以发现，如果序列长度是奇数那么必须是第一种\n由于所有字符都是数字，可以把所有组合都枚举一遍计算好串长度最大值，再用总长度减一下就行了\n这题到这里也就做完了\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst int INF = 0x3f3f3f3f;\nconst int maxn = 1e5 + 9;\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\nstring s;\nint calc(int x, int y)\n{\n    int ans = 0;\n    for (int i = 0; i < s.length(); ++i)\n        if (s[i] - '0' == x)\n        {\n            ans++;\n            swap(x, y);\n        }\n    if (x != y && ans & 1)\n        ans--;\n    return ans;\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"data.txt\",\"w\",stdout);\n    //std::ios::sync_with_stdio(false);\n    //std::cin.tie(0);\n    int T;\n    read(T);\n    while (T--)\n    {\n        cin >> s;\n        int ans = 0;\n        for (int i = 0; i <= 9; ++i)\n            for (int j = 0; j <= 9; ++j)\n                ans = max(ans, calc(i, j));\n        cout << s.length() - ans << '\\n';\n    }\n    //fclose(stdin);\n    //fclose(stdout);\n    return 0;\n}\n\n```\n# D. Segment Intersections\n又是一个题面令人费解的题，并且比C难多了。\n分类讨论很复杂，尤其两条线段不相交的情况。\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\nll n, k, l1, l2, r1, r2;\nint main()\n{\n    int t;\n    read(t);\n    while (t--)\n    {\n        read(n), read(k), read(l1), read(r1), read(l2), read(r2);\n        ll ans = 1e18;\n        if (max(l1, l2) <= min(r1, r2))\n        {\n            ll rem = max((ll)0, k - n * (min(r1, r2) - max(l1, l2)));\n            ll mp = n * (abs(l1 - l2) + abs(r1 - r2));\n            ans = min(rem, mp) + max((ll)0, rem - mp) * 2;\n        }\n        else//不相交\n        {\n            ll inv = max(l1, l2) - min(r1, r2);//间隔\n            for (int i = 1; i <= n; ++i)\n            {\n                ll tmp = i * inv;//补上间隔\n                ll mp = (max(r1, r2) - min(l1, l2)) * i;//最大长度\n                tmp += min(k, mp) + max((ll)0, k - mp) * 2;//调整\n                ans = min(ans, tmp);\n            }\n        }\n        cout << ans << '\\n';\n    }\n}\n```\n照着题解的kotlin代码写了一份c++的\n# E. Calendar Ambiguity\n由题，$x\\times d+y\\equiv y\\times d+x \\pmod w$，变形可得：\n$(x-y)\\times(d-1)\\equiv 0\\pmod w$\n那么就很明显了，既然 $d$ 和 $w$ 都已知了，$x-y$ 一定是 $\\frac{w}{\\gcd(w,d-1)}$ 的整数倍。接下来等差数列求和就可以解决了。\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\nll m, d, w;\nint main()\n{\n    int t;\n    read(t);\n    while (t--)\n    {\n        read(m), read(d), read(w);\n        ll w2 = w / __gcd(d - 1, w);\n        ll md = min(m, d);\n        ll cnt = md / w2;\n        ll ans = (2 * md - w2 * (cnt + 1)) * cnt / 2;\n        cout << ans << '\\n';\n    }\n}\n```\n\n# 总结\n\n以我目前的水平，前五题应该是可以做出来的，即便像D这样的题比赛的时候调不出来，做对四题也是应该的。这一场做出四题基本能进1000，五题就能进500，可以涨一大波分。但是最终的结果不尽人意，主要还是因为这种题目做的还不够多。CF这种类型的题目一般不需要任何算法，仅仅是对暴力模拟的一点优化而已，因此还是要做一些div2的BCD题来熟练一下。\n\n![200731.jpg](https://i.loli.net/2020/07/31/WTIi26RS54fwm8n.jpg)\n\n","tags":["CodeForces"]},{"title":"洛谷7月月赛div2","url":"/2020/07/25/LGR-073div2/","content":"\n在出题解之前口胡了一些思路，现在把之前想错的和没写的补上。\n\n<!--more-->\n\n## A&B\n\nA二分答案，不卡精度，很简单；\n\nB算一下前缀和，后面计算取模的时候注意一下顺序，也没什么问题。\n\n*没什么问题*\n\n## C\n\n应该是一个DP，容易发现每一列在旋转的时候是不会变的，而上下是否颠倒与其旋转次数奇偶有关，所以可以判断能否做出目标形状，最少次数应该是从某个边缘开始逐渐还原的顺序需要的次数。没写代码不知道这个思路对不对。\n\n*观察到的性质没有问题，确实需要利用这个性质来解题，但是需要转化后通过计算逆序对的方法求解。*\n\n## D\n\n写这篇文章就是为了记下看到D题以后我的胡思乱想。\n\n看到单点修改先想到树状数组，但是显然没法完成区间排序判断。区间排序会打乱元素顺序，那么差分就没有用，每次排序用时 $(r-l)\\log(r-l)$，太长，考虑用一个map之类的东西存放，这样如果重复元素多的话会好一点。但是这样做显然是不行的，首先不可能每次把区间的一堆东西丢进map，这样比直接排序还慢，而如果用类似前缀和的思想，开 $n$ 个map，那不仅空间会爆炸，map的复制也是个问题。因为要有序，所以不能用hash。\n\n第二个想法是用珂朵莉树，每次查询区间的时候把没有的区间放进set，有的区间split掉得到要求的区间，但是这样同样需要很多的map，并且复杂度不见得优秀到哪里去，估计也是不行的。\n\n然后想如果搞一棵树去存序列的点的话也是修改比较方便，判断操作是很麻烦的，还是需要维护序列的数据结构，或许可以把线段树的结构修改一下，下面的叶子存储数据，在上面建一个类似于平衡树的结构？不知道有什么神奇的结构可以搞这样的序列。\n\n*本题的正解是线段树与哈希，需要将一个区间哈希成一个值，非常巧妙。从来没有想过还可以有这样的做法。*\n\n8月月赛快来了，7月236pts，下次希望能超过250pts。\n\n![200725.jpg](https://i.loli.net/2020/07/25/NGbP53ZU69HFqOa.jpg)","tags":["洛谷"]},{"title":"CF#658div2总结","url":"/2020/07/24/CF658div2/","content":"\n这场除了E比较难，其他题都比较简单，可惜比赛的时候思路并没有很清晰。\n\n<!--more-->\n\n## A&B\n\nA水题。B稍微想一下，第一个遇到多于一个的堆的人可以掌控之后的局势，必然获胜，也很容易。\n\n## C\n\nC给的积分居然比B还低，就离谱。\n\n不过C也确实很简单，应该先看Hard Version，就比较容易想出先全部推平再转化的做法，先看Easy Version反而有一种被误导的感觉。\n\n比赛的时候看到序列翻转就像中了邪一样去想Splay，这种比赛平时连线段树都不会考，会考Splay？\n\n题解写在CSDN上：[CF1382C（1381A）Prefix Flip](https://blog.csdn.net/Pastafarian/article/details/107562596)\n\n## D\n\nD的转化倒是非常巧妙，归并的性质似乎没有那么容易看出来，虽然看出来以后正确性是非常容易证明的。转化成DP以后就没有难度了，最简单的01背包。\n\n题解写在CSDN上：[CF1382D（1381B）Unmerge](https://blog.csdn.net/Pastafarian/article/details/107568308)\n\n## E\n\n只有E题的构造比较难，毕竟也是div1的C，\\*2500的题了，改天有空的时候好好学一下。\n\n\n\n过了C大概能进1000，再过D能进500，思路并不复杂，也都是我会的算法，为什么比赛的时候就做不出来？以后需要每天做一两道div1的AB题开拓一下思维了。\n\n\n\n今天的比赛不能再掉分了\n\n![200724.jpg](https://i.loli.net/2020/07/24/UPnsZ3ykSA1RIDl.jpg)","tags":["CodeForces"]},{"title":"单调栈","url":"/2020/07/20/Monotone_Stack/","content":"\n## 简介：\n\n顾名思义，单调栈中的元素是单调的，规定其单调性由**出栈顺序**决定，即栈顶元素最小的单调栈是单调递增栈，反之则是单调递减栈。\n\n<!--more-->\n\n## 单调栈原理\n\n例如有一个单调递增栈，要把4，2，3，6，1，5这6个数放进去，其运行过程如图所示：\n\n![200720MS.png](https://i.loli.net/2020/07/20/VQN1ESyAT2Wpagj.png)\n\n可见，每当新元素加入时都会把比它小的元素一个个弹出，直到栈顶元素比它大或栈空为止。这个维护单调性的操作和单调队列有些相似。\n\n单调栈这个数据结构虽然看起来很蠢，但是却能优化一些算法，例如在一个数列中找到每个数后面第一个比它大的数据的位置，暴力算法的复杂度是 $O(n^2)$，对于随机数据可能会表现比较好，但是如果某一个测试数据是单调递减的序列，暴力算法一定会被卡掉，而使用单调栈是稳定的 $O(n)$，这是一个非常大的进步。\n\n\n## 具体实现（模板题[P5788](https://www.luogu.com.cn/problem/P5788)）\n\nSTL的栈就很好用，没必要手写。用递增的单调栈从后往前过一遍就可以了。\n\n### AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 3e6 + 9;\nint n, a[maxn], ans[maxn];\nstack<int> s;\ninline int read()//数据有点多，cin会TLE\n{\n    int data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    return f * data;\n}\nint main()\n{\n    n = read();\n    for (int i = 1; i <= n; ++i)\n        a[i] = read();\n    for (int i = n; i > 0; --i)\n    {\n        while (!s.empty() && a[s.top()] <= a[i])\n            s.pop();\n        if (!s.empty())\n            ans[i] = s.top();\n        s.push(i);\n    }\n    for (int i = 1; i <= n; ++i)\n        cout << ans[i] << ' ';\n    return 0;\n}\n```\n\n![200720ms.jpg](https://i.loli.net/2020/07/20/yRQ6YscEXWt7JOa.jpg)\n\n这个瓶子也算是个栈？","tags":["数据结构"]},{"title":"洛谷P2671题解","url":"/2020/07/19/P2671-Solution/","content":"\n\n\n[P2671求和](https://www.luogu.com.cn/problem/P2671) 前缀和，数学推导\n\n<!--more-->\n\n这题比较复杂，以下是部分思路：\n\n1. 数据范围很大，要用 `long long` 存储，算一次取模一次，并且算法的时间复杂度不能超过 $O(n\\log n)$；\n   -  最简单的想法是 $O(n^3)$ 的暴力，稍作分析可以优化为 $O(n^2)$，但是显然这两种方法在这里都不管用\n   -  但是以上分析的过程可以得到一个**非常重要的结论**：$y$ 的值并不需要我们知道\n   -  在两个大小不同而奇偶性相同的数之间必然存在一个偶数是这两个数的平均数\n2. 由上一条可以发现，数字对应的编号的意义在于计算 $(x+z)\\times (number\\_x+number\\_z)$ 以及根据奇偶性分组，而颜色也需要另行分组，因此可以分为不多于 $2\\times m$ 种\n3. 在每组中求这些乘积的和，使用分配率以后可以发现，$x\\times number\\_x$ 与 $z\\times number\\_z$ 可以在读入的时候直接算出，因此只需要算 $\\sum (x\\times number\\_z+z\\times number\\_x)$，这个求和可以化成 $\\sum _{i=1}^n x_i\\times (\\sum _{j=1}^n number\\_z_j)-x_i\\times number\\_x_i$ 之类的东西，从而在 $O(n)$ 时间内求出\n\n\n\n大致的思路就是这样，以下是代码的一种写法\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e5 + 9;\nconst int mod = 10007;\n\ninline ll read()\n{\n    ll data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    return f * data;\n}\n\nint num[maxn], col[maxn];\nll ans, f[maxn][2][4];\n//f[][0][]:颜色  f[][1][]:奇偶\nint main()\n{\n    int n = read(), m = read();\n    for (int i = 1; i <= n; i++)\n        num[i] = read() % mod;\n    for (int i = 1; i <= n; i++)\n        col[i] = read() % mod;\n    for (int i = 1; i <= n; i++)\n    {\n        (ans += (f[col[i]][i % 2][0] * (i % mod) * (num[i] % mod)) % mod) %= mod;\n        (ans += f[col[i]][i % 2][1]) %= mod;\n        (ans += ((i % mod) * f[col[i]][i % 2][2]) % mod) %= mod;\n        (ans += ((num[i] % mod) * f[col[i]][i % 2][3]) % mod) %= mod;\n        (f[col[i]][i % 2][0] += 1) %= mod;\n        //满足条件个数\n        (f[col[i]][i % 2][1] += (i % mod) * (num[i] % mod)) %= mod;\n        //sum z*number_z\n        (f[col[i]][i % 2][2] += num[i] % mod) %= mod;\n        //sum z\n        (f[col[i]][i % 2][3] += i % mod) %= mod;\n        //sum number_z\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n\n```\n\n这题真是让人头大。。。\n\n![200719P2671.jpg](https://i.loli.net/2020/07/19/bloA8djRuJw2GgX.jpg)","tags":["洛谷"]},{"title":"Treap（树堆）","url":"/2020/07/19/Treap/","content":"\n# 简介：\n\n“如果将一个含n个元素的集合插入到一棵二叉搜索树中，所得到的的树可能会相当不平衡，从而导致查找时间很长……随机构造二叉搜索树是趋向于平衡的……可以采用一种策略是先随机排列这些元素，然后按照排列的顺序将它们插入到树中……一棵Treap树就是一棵更改了结点排序方式的二叉搜索树”——《算法导论》\n\n<!--more-->\n\n# 基本性质：\n\n顾名思义，Treap是Tree与Heap的结合体，二叉搜索树功能强大但是容易退化，而堆则具有完全二叉树的性质，Treap兼具二者优点，从而保持平衡。\n\n显然，为了保持搜索树的性质，Treap中的元素不能像堆一样放，依然需要遵循BST的规则，因此对于每个元素需要引入一个随机数作为维持堆的性质的依据。对于每个节点，满足以下三个性质：\n\n1. 如果ls是root的左孩子，val[ls]<val[root]；\n2. 如果rs是root的右孩子，val[rs]>val[root]；\n3. 如果s是root的后代，rnd[u]>rnd[root]（小根堆）\n\n\n\n# 具体实现：\n\n## 1、准备工作\n\n### 存储结构\n\n```c++\nstruct node{\n    int ls, rs, val, size, rnd, freq;\n} treap[maxn];\n```\n\n数组存Treap，没什么好说的，和AVL树相比多了一个值rnd\n\n### 随机数生成\n\n可以用自带的 `rand()` 函数，但是据说容易被卡，所以也可以自己写。\n\nupdate:\n\n```c++\nmt19937 rng(time(0));\n```\n\n然后用 `rng()` 代替 `rand()` 就好了。\n\n## 2、重要功能\n\n### 更新信息\n\n```c++\ninline void update(int k) \n{\n    treap[k].size = treap[treap[k].ls].size + treap[treap[k].rs].size + treap[k].freq;\n}\n```\n\n### 旋转\n\n对于一棵BST，可以发现以下两种旋转结点的方式可以不改变结点排列规则而改变树的结构，所以Treap可以通过这两种方式使结点满足堆的性质。\n\n![200719rotate.png](https://i.loli.net/2020/07/19/KX6iGy8ZTHAD4pY.png)\n\n- 左旋：\n\n\t1. 取出根的右子树，即图中提取出C的过程\n\t2. 用根的右子树的左子树替换根的右子树，即图中F—>A的过程\n\t3. 用根替换被取出的右子树的左子树，即图中下移A点使其变成C的左子树的过程\n\t4. 更新数据\n\n\n```c++\ninline void rotate_l(int &k)\n{\n    int t = treap[k].rs;\n    treap[k].rs = treap[t].ls;\n    treap[t].ls = k;\n    treap[t].size = treap[k].size;\n    update(k);\n    k = t;\n}\n```\n\n- 右旋：\n\n  1.  取出根的左子树，即图中提取出B的过程\n  2. 用根的左子树的右子树替换根的左子树，即图中E—>A的过程\n  3. 用根替换被取出的左子树的右子树，即图中下移A点使其变成B的右子树的过程\n  4. 更新数据\n\n```c++\ninline void rotate_r(int &k)\n{\n    int t = treap[k].ls;\n    treap[k].ls = treap[t].rs;\n    treap[t].rs = k;\n    treap[t].size = treap[k].size;\n    update(k);\n    k = t;\n}\n```\n\n可见左旋和右旋正好是完全相反的过程，它们与在堆中插入元素时不断向上对比交换效果类似，从堆的角度来看，左旋相当于交换右孩子与父亲的值，右旋反之。\n\n\n\n### 插入\n\nBST的递归插入方式，顺便维护堆的性质。\n\n```c++\nvoid insert(int &k, int x)\n{\n    if (k == 0)\n    {\n        cnt++;\n        k = cnt;\n        treap[k].size = treap[k].freq = 1;\n        treap[k].val = x;\n        treap[k].rnd = rand();\n        return;\n    }\n    treap[k].size++;\n    if (treap[k].val == x)\n        treap[k].freq++; \n    else if (x > treap[k].val)\n    {\n        insert(treap[k].rs, x);\n        if (treap[treap[k].rs].rnd < treap[k].rnd)\n            rotate_l(k); \n    }\n    else\n    {\n        insert(treap[k].ls, x);\n        if (treap[treap[k].ls].rnd < treap[k].rnd)\n            rotate_r(k);\n    }\n}\n```\n\n\n\n### 删除\n\n先利用BST性质找到这个值，再把这个节点旋转成叶子节点，最后删除\n\n```c++\nvoid del(int &k, int x)\n{\n    if (k == 0)\n        return;\n    if (treap[k].val == x)\n    {\n        if (treap[k].freq > 1)\n        {\n            treap[k].freq--;\n            treap[k].size--;\n            return; \n        }\n        if (treap[k].ls * treap[k].rs == 0)\n            k = treap[k].ls + treap[k].rs; //有一个儿子为空\n        else if (treap[treap[k].ls].rnd < treap[treap[k].rs].rnd)\n            rotate_r(k), del(k, x);\n        else\n            rotate_l(k), del(k, x);\n    }\n    else if (x > treap[k].val)\n        treap[k].size--, del(treap[k].rs, x);\n    else\n        treap[k].size--, del(treap[k].ls, x);\n}\n```\n\n\n\n### 根据值查询排名\n\n与AVL树类似\n\n```c++\nint query_rank(int k, int x)\n{\n    if (k == 0)\n        return 0;\n    if (treap[k].val == x)\n        return treap[treap[k].ls].size + 1;\n    else if (x > treap[k].val)\n        return treap[treap[k].ls].size + treap[k].freq + query_rank(treap[k].rs, x);\n    else\n        return query_rank(treap[k].ls, x);\n}\n```\n\n\n\n### 根据排名查找值\n\n同样与AVL树类似\n\n```c++\nint query_val(int k, int x)\n{\n    if (k == 0)\n        return 0;\n    if (x <= treap[treap[k].ls].size)\n        return query_val(treap[k].ls, x);\n    else if (x > treap[treap[k].ls].size + treap[k].freq)\n        return query_val(treap[k].rs, x - treap[treap[k].ls].size - treap[k].freq);\n    else\n        return treap[k].val;\n}\n```\n\n\n\n### 查询前驱/后继\n\n由于是数组中建的树，实现难度远远低于AVL树\n\n```c++\nint query_pre(int k, int x)\n{\n    int t = k, ans = 0;\n    while (t)\n    {\n        if (treap[t].val < x)\n            ans = treap[t].val, t = treap[t].rs;\n        else\n            t = treap[t].ls;\n    }\n    return ans;\n}\nint query_suf(int k, int x)\n{\n    int t = k, ans = 0;\n    while (t)\n    {\n        if (treap[t].val > x)\n            ans = treap[t].val, t = treap[t].ls;\n        else\n            t = treap[t].rs;\n    }\n    return ans;\n}\n```\n\n\n\n## 3、完整代码（以[P3369](https://www.luogu.com.cn/problem/P3369)为例）\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1e5 + 9;\nstruct node\n{\n    int ls, rs, val, size, rnd, freq;\n} treap[maxn];\nint n, cnt, root;\ninline void update(int k)\n{\n    treap[k].size = treap[treap[k].ls].size + treap[treap[k].rs].size + treap[k].freq;\n}\ninline void rotate_l(int &k)\n{\n    int t = treap[k].rs; \n    treap[k].rs = treap[t].ls;\n    treap[t].ls = k;\n    treap[t].size = treap[k].size;\n    update(k);\n    k = t;\n}\ninline void rotate_r(int &k)\n{\n    int t = treap[k].ls;\n    treap[k].ls = treap[t].rs;\n    treap[t].rs = k;\n    treap[t].size = treap[k].size;\n    update(k);\n    k = t;\n}\nvoid insert(int &k, int x)\n{\n    if (k == 0)\n    {\n        cnt++;\n        k = cnt;\n        treap[k].size = treap[k].freq = 1;\n        treap[k].val = x;\n        treap[k].rnd = rand();\n        return;\n    }\n    treap[k].size++;\n    if (treap[k].val == x)\n        treap[k].freq++;\n    else if (x > treap[k].val)\n    {\n        insert(treap[k].rs, x);\n        if (treap[treap[k].rs].rnd < treap[k].rnd)\n            rotate_l(k);\n    }\n    else\n    {\n        insert(treap[k].ls, x);\n        if (treap[treap[k].ls].rnd < treap[k].rnd)\n            rotate_r(k);\n    }\n}\nvoid del(int &k, int x)\n{\n    if (k == 0)\n        return;\n    if (treap[k].val == x)\n    {\n        if (treap[k].freq > 1)\n        {\n            treap[k].freq--;\n            treap[k].size--;\n            return;\n        }\n        if (treap[k].ls * treap[k].rs == 0)\n            k = treap[k].ls + treap[k].rs; \n        else if (treap[treap[k].ls].rnd < treap[treap[k].rs].rnd)\n            rotate_r(k), del(k, x);\n        else\n            rotate_l(k), del(k, x);\n    }\n    else if (x > treap[k].val)\n        treap[k].size--, del(treap[k].rs, x);\n    else\n        treap[k].size--, del(treap[k].ls, x);\n}\nint query_rank(int k, int x)\n{\n    if (k == 0)\n        return 0;\n    if (treap[k].val == x)\n        return treap[treap[k].ls].size + 1;\n    else if (x > treap[k].val)\n        return treap[treap[k].ls].size + treap[k].freq + query_rank(treap[k].rs, x);\n    else\n        return query_rank(treap[k].ls, x);\n}\nint query_val(int k, int x)\n{\n    if (k == 0)\n        return 0;\n    if (x <= treap[treap[k].ls].size)\n        return query_val(treap[k].ls, x);\n    else if (x > treap[treap[k].ls].size + treap[k].freq)\n        return query_val(treap[k].rs, x - treap[treap[k].ls].size - treap[k].freq);\n    else\n        return treap[k].val;\n}\nint query_pre(int k, int x)\n{\n    int t = k, ans = 0;\n    while (t)\n    {\n        if (treap[t].val < x)\n            ans = treap[t].val, t = treap[t].rs;\n        else\n            t = treap[t].ls;\n    }\n    return ans;\n}\nint query_suf(int k, int x)\n{\n    int t = k, ans = 0;\n    while (t)\n    {\n        if (treap[t].val > x)\n            ans = treap[t].val, t = treap[t].ls;\n        else\n            t = treap[t].rs;\n    }\n    return ans;\n}\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cin >> n;\n    int opt, x;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> opt >> x;\n        switch (opt)\n        {\n        case 1:\n            insert(root, x);\n            break;\n        case 2:\n            del(root, x);\n            break;\n        case 3:\n            cout << query_rank(root, x) << '\\n';\n            break;\n        case 4:\n            cout << query_val(root, x) << '\\n';\n            break;\n        case 5:\n            cout << query_pre(root, x) << '\\n';\n            break;\n        case 6:\n            cout << query_suf(root, x) << '\\n';\n            break;\n        }\n    }\n    return 0;\n}\n```\n\n这样的Treap并非代码量最少的写法，但是便于理解，即便如此也比AVL树的实现少了100多行。\n\n\n\n# 后记\n\nTreap是一种非常有趣的数据结构，它并非像AVL树那样高度平衡，但是效率也不低，而且远比AVL树、红黑树好写。由于常数比较小，普通Treap的速度比Splay快。甚至在进行一些改进后Treap可以做到可持久化、分裂合并以及序列处理操作，是一种很强大的平衡树。\n\n\n\n学了大半天的Treap那就发一张树的图片好了。\n\n![200719Treap.jpg](https://i.loli.net/2020/07/19/usAjkBcWDYa4RSe.jpg)","tags":["数据结构"]},{"title":"HTML5基础知识","url":"/2020/07/17/HTML5_first_things_first/","content":"\n\nHTML即Hyper Text Markup Language（超文本标记语言），目前主流浏览器均支持HTML5。以下是一些HTML5最基本的概念。\n\n<!--more-->\n\n常用语句：\n\n- 声明：`<!DOCTYPPE>`\n\n  - HTML5：`<!DOCTYPPE html>`\n\n- `<head>`\n\n  -  `<title>` 显示网页标签的名字\n  -  `<link rel=\"stylesheet\" type=\"text/css\" href=\"\">` 外部样式表\n  -  内部样式表：\n\n  ```html\n  <style type=\"text/css\">\n  \tp{\n  \t\tcolor: #5C3317;<!-棕色->\n  \t}\n  </style>\n  ```\n\n- `<body>` \n\n  - 标题 `<h1>` 到`<h6>`逐渐变小 \n\n  - `<p>` 段落（结束后另起一行）\n\n  - `<a>` 超链接，用法：\n\n    `<a href=\"https://phlzy.github.io/\">blog</a>`\n\n  - `<img>` 图片，用法：\n\n    `<img src=\"images/html.png\">`\n\n  - `<br/>` 空标签（间距较小）\n  \n  - 格式化：\n  \n    ```html\n    <b>加粗</b>\n    <em>着重（斜体）</em>\n    <i>斜体</i>\n    <small>变小</small>\n    <strong>强调（变粗）</strong>\n    <sub>下标</sub>\n    <sup>上标</sup>\n    <ins>下划线</ins>\n    <del>删除线</del>\n    ```\n  - 内联样式表：`<a style=\"color: aqua\">` \n    \n\n### 元素标签\n\n**块：结束后会换行**\n\n标题 `<h1>` 等，段落 `<p>` 及列表 `ul` 等均为块元素\n\n**内联元素：结束后一般不会换行**\n\n**div元素：一般配合CSS样式作为组合HTML元素的容器使用**\n\n**span元素：内联元素，文本的容器**\n\n### 布局\n\n大致如下所示：\n\n```html\n<!DOCTYPE html>\n\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title>Index</title>\n    <style type=\"text/css\">\n        body{\n            margin: 0px;\n        }\n        #container{\n            width: 100%;\n            height: 950px;\n            background-color: antiquewhite;\n        }\n        #head{\n            width: 100%;\n            height: 10%;\n            background-color: darkgray;\n        }\n        #content_menu{\n            width: 30%;\n            height: 80%;\n            background-color: white;\n            float: right;\n        }\n        #content_body{\n            width: 70%;\n            height: 80%;\n            background-color: aqua;\n            float: left;\n        }\n        #bottom{\n            width: 100%;\n            height: 10%;\n            background-color: antiquewhite;\n            clear: both;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"container\">\n        <div id=\"head\">\n            \n        </div>\n        <div id=\"content_menu\">\n            \n        </div>\n        <div id=\"content_body\">\n\n        </div>\n        <div id=\"bottom\">\n\n        </div>\n    </div>\n\n</body>\n\n</html>\n```\n\n看完这些无聊的东西，是时候放松一下自己了\n\n![200717html.jpg](https://i.loli.net/2020/07/17/3wn4c2JAa5TRLYM.jpg)","tags":["前端"]},{"title":"最长不下降子序列（LIS）与最长公共子序列（LCS）","url":"/2020/07/16/LIS&LCS/","content":"\n\n\n总结一下线性动态规划的两个经典问题：最长不下降子序列（LIS）与最长公共子序列（LCS）。\n\n\n\n<!--more-->\n\n###  LIS回顾：（[模板题P1020](https://www.luogu.com.cn/problem/P1020)）\n\n提供一个序列，求最长不下降子序列（Longest Increasing Subsequence）：\n\n- 朴素的 $O(n^2)$ 做法：对每个元素，存储以该元素结尾的最长不下降子序列长度，从前往后递推。\n  - 思路简单，效率低下\n- $O(n\\log n)$ 做法：初始化一个空数组，将元素依次按照以下规则填入：\n  - 若数组为空或最后一个元素不大于新元素，直接将新元素push_back；\n  - 若数组最后一个元素大于新元素，查找数组中第一个大于新元素的元素并用新元素代替；\n  - 观察该流程可以发现，新数组是单调非递减的，类似于一个队列，该数组的长度就是LIS的长度，由于可以使用二分查找，时间复杂度优化到 $O(n\\log n)$。\n  - 正确性：第一类操作显然正确，不必多言。第二类操作替换数组内元素，不会改变其长度，因此对之前的结果不会产生影响，而后续如果会产生更长的子序列，接在新元素的后面也是更优的选择，也就是说被替换的元素同样不会对后续造成影响。\n- 二分查找\n  - `lower_bound(ForwardIterator beg,ForwardIterator end,const T& value,BinaryPredicate op)`（默认升序，op可以不加）：返回**第一个大于等于**value的元素位置，即**可插入元素值为value，且不破坏区间有序性**的位置。如果不存在这样的位置，返回end\n  - `upper_bound(ForwardIterator beg,ForwardIterator end,const T& value,BinaryPredicate op)`（默认升序，op可以不加）：返回**第一个大于**value的元素位置，即**可插入元素值为value，且不破坏区间有序性**的位置。如果不存在这样的位置，返回end\n  - 如果容器支持随机访问，以上两个函数的复杂度是对数的\n\n所以求LIS的核心代码大致是这样的：\n\n\n```c++\nint len = 1; \nd[1] = a[1];           \nfor (int i = 2; i <= n; ++i)\n{ \n    if (d[len] <= a[i])\n        d[++len] = a[i];\n    else\n    {\n        int p = upper_bound(d + 1, d + 1 + len, a[i]) - d;\n        d[p] = a[i];\n    }\n}\n```\n\nPS.LIS也可以用树状数组做\n\n### LCS：（[模板题P1439](https://www.luogu.com.cn/problem/P1439)）\n\n提供从1到n的两个排列 $P_1$、$P_2$，求它们的最长公共子序列（Longest Common Subsequence）：\n\n- $O(n^2)$ 的做法是直接DP，以 $i$ 表示 $P_1$ 的前 $i$ 位，以 $j$ 表示 $P_2$ 的前 $j$ 位，可以得到以下两个状态转移方程：\n  - $$dp[i][j]=\\max\\{dp[i][j],dp[i-1][j-1]+1\\}(P_1[i]=P_2[j])$$\n  - $$dp[i][j]=\\max\\{dp[i-1][j],dp[i][j-1]\\}(P_1[i]\\ne P_2[j])$$\n  - 会被卡掉\n  \n- $O(n\\log n)$ 做法：利用全排列的性质\n\n  - 由题可知，两个序列的元素种类相同，只是排列顺序不一样，因此可以以其中一个作为基准重新编号，如图所示：\n\n  | $P_1$  | B（2） | D（4） | C（3） | E（5） | A（1） |\n  | ------ | ------ | ------ | ------ | ------ | ------ |\n  | $P_2$  | C（3） | A（1） | E（5） | B（2） | D（4） |\n  | $P_1'$ | 1      | 2      | 3      | 4      | 5      |\n  | $P_2'$ | 3      | 5      | 4      | 1      | 2      |\n\n  - 这样重新标号后 $P_1'$ 序列是递增的，那么这个问题就转化为了求LIS的问题。\n\nP1439AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100009;\nint a[maxn], m[maxn], b[maxn], t[maxn], d[maxn], n;\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cin >> n;\n    for (int i = 1; i <= n; ++i)\n    {\n        cin >> a[i];\n        m[a[i]] = i;\n    }\n    for (int i = 1; i <= n; ++i)\n    {\n        cin >> b[i];\n        t[i] = m[b[i]];\n    }\n    int len = 1;\n    d[1] = t[1];\n    for (int i = 2; i <= n; ++i)\n    {\n        if (d[len] <= t[i])\n            d[++len] = t[i];\n        else\n        {\n            int p = upper_bound(d + 1, d + 1 + len, t[i]) - d;\n            d[p] = t[i];\n        }\n    }\n    cout << len << '\\n';\n    return 0;\n}\n```\n\n日常：\n\n![200716.jpg](https://i.loli.net/2020/07/16/SKHyueG5FdwRPNn.jpg)","tags":["洛谷","算法"]},{"title":"VSCode常用快捷键","url":"/2020/07/14/VSCode/","content":"\n写代码的时候不用鼠标才能达到最高的效率\n\n<!--more-->\n\n常用快捷键：\n\n\n|    快捷键    |      功能      |\n| :--------------------: | :--------------------: |\n|       Ctrl+Shift+P或F1       | 打开命令面板  |\n|       Ctrl+P       |      搜索文件      |\n|    Ctrl+Shift+W    |      关闭窗口      |\n|    Ctrl+Shift+N    |     打开新窗口     |\n|  Ctrl+X（不选中）  |      剪切本行      |\n|  Ctrl+C（不选中）  |      复制本行      |\n|    Alt+ ↑ 或 ↓ |   上移或下移本行   |\n| Shift+Alt + ↓ 或 ↑ | 向上或向下复制本行 |\n|    Ctrl+Shift+K    |      删除本行      |\n|     Ctrl+Enter     |   在下方插入一行   |\n|  Ctrl+Shift+Enter  |   在上方插入一行   |\n|  Ctrl+Shift+\\ | 移动到相匹配的括号 |\n|     Home / End     | 到本行的行首或行尾 |\n| Ctrl+Home / End |    到文件的头尾    |\n|     Ctrl+↑ / ↓     |   上下拖动滚动条   |\n| Ctrl+Shift+[或] |   折叠或展开区域   |\n|  Ctrl+K Ctrl+C |   将本行变成注释   |\n|  Ctrl+K Ctrl+U | 将本行注释变成代码 |\n|       Ctrl+M       | 通过tab移动焦点 |\n|       Ctrl+G       |     跳转到某行     |\n|         F8         |  定位到下一个错误  |\n|       Ctrl+F       |        查找        |\n|       Ctrl+H       |        替换        |\n|    （Shift+）F3    |    （上）下一个    |\n|       Ctrl+N       |        新建        |\n|       Ctrl+O       |        打开        |\n|      Ctrl+K S      |      全部保存      |\n\n[全部快捷键在此](https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf)\n\n\n\nVSC本身并不可怕，可怕的是它的主人\n\n![vsc](https://i.loli.net/2020/07/14/pGXAh7J5ZuU3vRg.jpg)","tags":["其它"]},{"title":"CF#655div2总结","url":"/2020/07/12/CF655div2/","content":"\n\n\n**几个月没打CF了，本来想拿这一场试试手感，虽然是比寒假菜了不少，但是似乎有很大的上分的希望，只可惜评测姬似乎罢工了导致Unrated。。。**\n\n\n\n<!--more-->\n\n## A. Omkar and Completion\n\n第一眼看上去不像水题的超级大水题，全部输出一个1000以内数字就好了。没啥好说的。\n\n## B. Omkar and Last Class of Math\n\n显而易见，如果 $n$ 是质数，输出 $1$ 和 $n-1$，否则输出 $n/k$ 与 $n-n/k$，其中 $k$ 是 $n$ 的最小质因数。\n\n这个规律很容易证明，考虑到 $t\\le 10$ 以及 $2\\le n \\le 10^9$，我写了个线性筛，预处理后如果是质数直接输出，如果是合数就从质数表里一个个遍历过去。虽然用bitset判断质数不会爆空间，但是由于数据范围太大，线性复杂度的预处理函数也占用了非常多的时间，最终以一次RE一次TE的失败而告终。\n\n回过头来看一下 $t$ 的大小，其实这题用最简单的 $O(\\sqrt{n})$ 的暴力法就可以完美解决。。。我裂开了\n\n## C. Omkar and Baseball\n\n又是一道看起来很难的水题。\n\n先画一些小序列找一下规律，可以发现，位置全错的一段序列重组一次就可以变为有序；如果在一段序列的中间只有一个元素的位置是对的，如果序列足够长的话至少需要两次；如果中间有多个分散的，也可以第一次将它们全部打乱，第二次直接排好。因此，对于一整段序列来说，重组次数一定不超过两次，其中0次的情况显然只有在已经有序的时候才符合，1次的情况是无序数列是连续的一段，其余情况都需要两次。\n\n## D. Omkar and Circle\n\n做完C以后说unrated了，时间也不早了，第二天还有考试，就去睡了。\n\n这个D题也不算难，画一个圈模拟一下可以发现，一圈上面取到的数一定是 $(n+1)/2$ 个，并且每个取到的元素之间都隔着一个不取的，也就是说只要把序列展开成 $[1,3,5,\\cdots ,n,2,4,6,\\cdots,n-1]$,然后用单调队列求出 $(n+1)/2$ 长度序列的最大元素和即可。\n\n最后用unsigned long long存答案。\n\n## E. Omkar and Last Floor\n\n看标签是尺取法，dp。有空仔细看一下。\n\n## F. Omkar and Modes\n\n连题解都看不明白。\n\n\n\n先放张图，E、F两题以后再补\n\n![200719CF655.jpg](https://i.loli.net/2020/07/19/LG8QrRlKepPOTFI.jpg)","tags":["CodeForces"]},{"title":"顺序表复习","url":"/2020/07/08/Linear_List/","content":"\n\n数据结构复习，顺序表及其几个成员函数。写的很丑。\n\n<!--more-->\n\n**代码：**\n\n```c++\n#include <iostream>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nconst int maxn = 1000;\ntemplate <typename T>\nvoid swap(T &_a, T &_b)\n{\n    T temp = _a;\n    _a = _b;\n    _b = temp;\n}\ntemplate <typename T>\nint bin_search(T arr[], int l, int r, T x) //ascending\n{\n    int mid;\n    while (l <= r)\n    {\n        mid = (l + r) / 2;\n        if (x == arr[mid])\n            return mid;\n        else if (x < arr[mid])\n            r = mid - 1;\n        else\n            l = mid + 1;\n    }\n}\nclass Linear_List //ascending\n{\npublic:\n    int arr[maxn + 1], elenum;\n    void insert(int x, int pos)\n    {\n        elenum++;\n        for (int i = elenum; i > pos; --i)\n            arr[i] = arr[i - 1];\n        arr[pos] = x;\n    }\n    void show()\n    {\n        for (int i = 1; i <= elenum; ++i)\n            cout << arr[i] << ' ';\n        cout << endl;\n    }\n    void reverse()\n    {\n        for (int i = 1; i <= elenum / 2; ++i)\n            swap(arr[i], arr[elenum + 1 - i]);\n    }\n    int find(int x)\n    {\n        for (int i = 1; i <= elenum; ++i)\n            if (arr[i] == x)\n                return i;\n        return 0;\n    }\n    void _push_back(int x)\n    {\n        arr[++elenum] = x;\n    }\n    /*\n    void sort(int l, int r)\n    {\n        int mid = arr[(l + r) / 2], i = l, j = r;\n        do\n        {\n            while (arr[i] < mid)\n                i++;\n            while (arr[j] > mid)\n                j--;\n            if (i <= j)\n                swap(arr[i++], arr[j++]);\n        } while (i <= j);\n        if (l < j)\n            sort(l, j);\n        if (i < r)\n            sort(i, r);\n    }\n    */\n};\n```\n\n**成员函数递归调用似乎会造成程序运行时错误**，因此暂时无法实现sort函数，函数指针也无法解决这个问题，可能是因为编译器隐式的将在类内定义的成员函数当做内联函数。以后有空再来尝试解决这一问题。\n\n\n\n![奈芙莲.jpg](https://i.loli.net/2020/07/08/gHR8SmCohAFMnvT.jpg)\n\n（奈芙莲也很可爱","tags":["大学课程"]},{"title":"记一次神奇的错误","url":"/2020/06/10/20-06-error/","content":"\n\n\n前段时间hexo博客又出了一些问题，今天终于修好了。\n\n\n\n<!--more-->\n\n先上图\n\n![1.png](https://i.loli.net/2020/06/10/LaMEJYDvVG6Udy7.png)\n\n很神奇的错误，在网上找了一些解决方法都没有成功，比如控制面板的凭据管理、修改yml文件等。\n\n后来发现是GitHub的邮箱验证出了问题，重新验证了一下以后就好了。\n\n具体原因以后有空再研究一下。\n\n放一张可怕的图：\n\n![2.jpg](https://i.loli.net/2020/06/10/kdgDu3spEbe2CQv.jpg)","tags":["随笔"]},{"title":"Dijkstra算法","url":"/2020/03/19/Dijkstra/","content":"\nDijkstra算法可以用于计算正权图的单源最短路，它同时适用于有向图和无向图，在 $n$ 个顶点，$m$ 条边的图中朴素的Dijkstra算法时间复杂度 $O(n^2)$，堆优化后可以达到 $O(m\\log n)$（稀疏图）。\n\n<!--more-->\n\n### 思路\n\n与求最小生成树的Prim算法类似，从选取的原点开始，进行以下操作：\n\n1. 将已经经过的点看作一个集合（done数组）；\n2. 将除了原点之外所有点到原点的距离设置为无穷大，把原点加入集合；\n3. 对于一个新加入集合的点，遍历这个点连接的所有边，把与这些边相连的另一个顶点的距离更新；\n4. 在集合之外的所有点中找到路径最短的一个，把它加入集合，并重复步骤3，直到所有点都加入了集合。\n\n维基上的这个动图真是很形象了：\n\n![dijkstra.gif](https://i.loli.net/2020/03/19/2BtcSNAj1yo3fJT.gif)\n\n\n\n优化也和Prim算法类似，也是用一个堆，具体想法是这样的：找出未进入集合中的距离最近的点时可以将点和距离绑定，这样就能用一个堆来维护。\n\n### 紫书代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 9, maxm = 2e5 + 9;\nconst int inf = 0x3f3f3f3f;\ntypedef vector<int> vi;\nstruct edge\n{\n    int from, to, dist;\n    edge(int u, int v, int d) : from(u), to(v), dist(d) {}\n};\nstruct HeapNode//适应STL的堆的排序方式\n{\n    int d, u;\n    bool operator<(const HeapNode &b) const\n    {\n        return d > b.d;\n    }\n};\nstruct dijkstra\n{\n    int n, m;\n    vector<edge> edg;\n    vi graph[maxn];\n    bool done[maxn];\n    int d[maxn], p[maxn];//p是最短路中的上一条弧\n    void init(int n)\n    {\n        this->n = n;\n        for (int i = 0; i <= n; ++i)\n            graph[i].clear();\n        edg.clear();\n    }\n    void add(int from, int to, int d)\n    {\n        edg.push_back(edge(from, to, d));\n        graph[from].push_back(edg.size() - 1);\n    }\n    void dij(int s)\n    {\n        priority_queue<HeapNode> pq;\n        for (int i = 0; i <= n; ++i)\n            d[i] = inf;\n        d[s] = 0;\n        memset(done, 0, sizeof(done));\n        pq.push((HeapNode){0, s});\n        while (!pq.empty())\n        {\n            HeapNode x = pq.top();\n            pq.pop();\n            int u = x.u;\n            if (done[u])//这个点在集合内了\n                continue;\n            done[u] = true;\n            for (int i = 0; i < graph[u].size(); ++i)\n            {\n                edge &e = edg[graph[u][i]];\n                if (d[e.to] > d[u] + e.dist)\n                {\n                    d[e.to] = d[u] + e.dist;\n                    p[e.to] = graph[u][i];\n                    pq.push((HeapNode){d[e.to], e.to});\n                }\n            }\n        }\n    }\n};\ndijkstra D;\nint main()\n{\n    int n, m, s;\n    scanf(\"%d%d%d\", &n, &m, &s);\n    D.init(n);\n    for (int i = 1; i <= m; ++i)\n    {\n        int u, v, w;\n        scanf(\"%d%d%d\", &u, &v, &w);\n        D.add(u, v, w);\n    }\n    D.dij(s);\n    for (int i = 1; i <= n; ++i)\n        printf(\"%d \", D.d[i]);\n    return 0;\n}\n```\n\n### 后记\n\n不太喜欢紫书的代码风格，还是要自己改一改模板。\n\n![dij2.jpg](https://i.loli.net/2020/03/19/4m6sByMfEv531JW.jpg)","tags":["图论"]},{"title":"快读模板","url":"/2020/03/16/fstread/","content":"\n\n### 快读\n\n据说 `cin` 大约能支持 $1,000,000$ 个数据的输入，`scanf` 的效率大约是 `cin` 的十倍，而快读大约是 `scanf` 的十倍。如果需要更快就要用 `fread`。\n\n<!--more-->\n\n### 快读\n\n```c++\ninline int read(){\n    int data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch)){\n   \tif (ch == '-')\n   \t    f = -1;\n   \tch = getchar();\n    }\n    while (isdigit(ch)){\n   \t    data = (data << 3) + (data << 1) + ch - '0';\n   \t    ch = getchar();\n    }\n    return f * data;\n}\n```\n\n据说 `isdigit` 比判断ASCII码来得快。\n\n**fread版**\n\n 版本1：\n\n```c++\nstruct FastIO {\n    static const int S = 1e7;\n    int wpos;\n    char wbuf[S];\n    FastIO() : wpos(0) {}\n    inline int xchar() {\n        static char buf[S];\n        static int len = 0, pos = 0;\n        if (pos == len)\n            pos = 0, len = fread(buf, 1, S, stdin);\n        if (pos == len) exit(0);\n        return buf[pos++];\n    }\n    inline int xuint() {\n        int c = xchar(), x = 0;\n        while (c <= 32) c = xchar();\n        for (; '0' <= c && c <= '9'; c = xchar()) x = x * 10 + c - '0';\n        return x;\n    }\n    inline int xint()\n    {\n        int s = 1, c = xchar(), x = 0;\n        while (c <= 32) c = xchar();\n        if (c == '-') s = -1, c = xchar();\n        for (; '0' <= c && c <= '9'; c = xchar()) x = x * 10 + c - '0';\n        return x * s;\n    }\n    inline void xstring(char *s)\n    {\n        int c = xchar();\n        while (c <= 32) c = xchar();\n        for (; c > 32; c = xchar()) * s++ = c;\n        *s = 0;\n    }\n    inline void wchar(int x)\n    {\n        if (wpos == S) fwrite(wbuf, 1, S, stdout), wpos = 0;\n        wbuf[wpos++] = x;\n    }\n    inline void wint(ll x)\n    {\n        if (x < 0) wchar('-'), x = -x;\n        char s[24];\n        int n = 0;\n        while (x || !n) s[n++] = '0' + x % 10, x /= 10;\n        while (n--) wchar(s[n]);\n        wchar('\\n');\n    }\n    inline void wstring(const char *s)\n    {\n        while (*s) wchar(*s++);\n    }\n    ~FastIO()\n    {\n        if (wpos) fwrite(wbuf, 1, wpos, stdout), wpos = 0;\n    }\n} io;\n```\n\n\n\n版本2：\n\n```c++\nstruct ios {\n    inline char read(){\n        static const int IN_LEN=1<<18|1;\n        static char buf[IN_LEN],*s,*t;\n        return (s==t)&&(t=(s=buf)+fread(buf,1,IN_LEN,stdin)),s==t?-1:*s++;\n    }\n\n    template <typename _Tp> inline ios & operator >> (_Tp&x){\n        static char c11,boo;\n        for(c11=read(),boo=0;!isdigit(c11);c11=read()){\n            if(c11==-1)return *this;\n            boo|=c11=='-';\n        }\n        for(x=0;isdigit(c11);c11=read())x=x*10+(c11^'0');\n        boo&&(x=-x);\n        return *this;\n    }\n} io;\n\nint main(){\n    io>>a>>b;\n}\n```\n\n\n\n版本3？？？：\n\n```c++\n#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\nchar buf[1<<23],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;\n\ninline int rd() {\n    int x=0,f=1;char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}\n    while(isdigit(ch)) x=x*10+(ch^48),ch=getchar();\n    return x*f;\n}\nvoid print(long long x) {\n    if(x>9) print(x/10);\n    *O++=x%10+'0';\n}\nfwrite(obuf,O-obuf,1,stdout);\n```\n\n\n\n### 快输\n\n版本1（递归）：\n\n```c++\n#define G(a) putchar(a+48)\ninline void write(int s){\n    if (s<0) G(-3),s=-s;\n    if (s>9) write(s/10);\n    G(s%10);\n}\n```\n\n\n\n版本2（循环）：\n\n```c++\n#define G(a) putchar(a+48)\ninline void write(int s){\n    int t=0,a[40];\n    if (s<0) G(-3),s=-s;\n    do {\n        a[++t]=s%10;\n    } while (t/=10);\n    while(t) \n        G(a[t--]);\n    putchar('');//看题目需要，可以加入\\n进行换行或者加入空格 \n}\n```\n\n\n\n当时SM.MS上不去所以放到了CSDN上，现在好了\n\n![fstread.jpg](https://i.loli.net/2020/07/20/UAnaQSyLIRkYl26.jpg)","tags":["模板"]},{"title":"最小生成树","url":"/2020/03/13/Minimum_Spanning_Tree/","content":"\n生成树（Spanning Tree）是连通图的一个极小连通子图，而最小生成树（Minimal Spanning Tree,MST）就是权值最小的生成树。最小生成树一般可以用Prim算法、Kruskal算法或[Borůvka算法](https://www.luogu.com.cn/blog/Tweetuzki/solution-p3366)求出。这里只写了前两种算法。[模板题：洛谷P3366](https://www.luogu.com.cn/problem/P3366)\n\n<!--more-->\n\n## 1.Prim\n\nPrim算法基于一种贪心的策略，即对于连通图的任意一个顶点，从该顶点出发的所有边中最短的一条一定属于最小生成树。这个策略显然是正确的，因为这条被选中的边的长度是该顶点和这张图除去该顶点的最小生成树的最小距离。\n\n具体实现的过程是先用邻接矩阵存边，然后初始化距离为最大值。任选一个顶点作为根，找到从该顶点发出的最短边并把这条边的另一个顶点并入最小生成树。然后重复寻找连接已有的最小生成树和其它顶点的最短边，依次选取新的顶点，直到所有的顶点都被选取。\n\n如果每次查找最短边都全部遍历一遍，时间复杂度是 $O(nm)$ 级别的，但是可以使用一个堆来存储已经走过的边的权值，避免重复计算，使时间复杂度降低到 $O(m\\log n)$。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, a, b) for (i = a; i <= b; ++i)\n#define drep(i, a, b) for (i = a; i >= b; --i)\ntypedef pair<int, int> pii;\nconst int maxn = 2e5 + 9;\nint i, k, n, m, cnt, sum, dis[10005], vis[10005];\nvector<int> edg[maxn], wgt[maxn];\ninline void add(int u, int v, int w)\n{\n    edg[u].push_back(v);\n    wgt[u].push_back(w);\n}\npriority_queue<pii, vector<pii>, greater<pii> > q;\ninline void prim()\n{\n    memset(dis, 127, sizeof(dis));\n    dis[1] = 0;\n    q.push(make_pair(dis[1], 1));\n    while (!q.empty() && cnt < n)\n    {\n        int d = q.top().first, u = q.top().second;\n        q.pop();\n        if (vis[u])\n            continue;\n        cnt++;\n        sum += d;\n        vis[u] = 1;\n        rep(i, 0, edg[u].size() - 1) if (wgt[u][i] < dis[edg[u][i]])\n        {\n            dis[edg[u][i]] = wgt[u][i];\n            q.push(make_pair(dis[edg[u][i]], edg[u][i]));\n        }\n    }\n}\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    rep(i, 1, m)\n    {\n        int a, b, c;\n        scanf(\"%d%d%d\", &a, &b, &c);\n        add(a, b, c);\n        add(b, a, c);\n    }\n    prim();\n    if (cnt == n) printf(\"%d\\n\", sum);\n    else puts(\"orz\");\n    return 0;\n}\n```\n\n\n\n## 2.Kruskal\n\nKruskal算法的策略也是依次选取最短边，但是它直接对边的长度进行排序，并使用并查集来判断是否需要选取这条边，如果这条边的两个顶点已经拥有公共祖先，说明这两个顶点已经存在于当前的最小生成树，所以不选取，否则就选取并且合并公共祖先。当所有的顶点拥有共同的公共祖先时最小生成树也就产生了。该算法的时间复杂度是 $O(m\\log m)$。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, a, b) for (i = a; i <= b; ++i)\n#define drep(i, a, b) for (i = a; i >= b; --i)\ntypedef pair<int, int> pii;\nconst int maxn = 2e5 + 9;\nconst int inf = 0x3f3f3f3f;\nstruct edg\n{\n    int x, y, w;\n    bool operator<(const edg &b) const\n    {\n        return w < b.w;\n    }\n};\nint n, m, father[maxn], i, ans;\nedg e[maxn];\nint find(int x)\n{\n    int t = x;\n    while (father[t] != t)\n        t = father[t];\n    father[x] = t;\n    return t;\n}\nvoid join(int x, int y)\n{\n    int tx = find(x), ty = find(y);\n    if (tx != ty)\n        father[tx] = ty;\n}\nint kruskal()\n{\n    rep(i, 1, n) father[i] = i;\n    rep(i, 1, m)\n    {\n        edg t = e[i];\n        if (find(t.x) == find(t.y))\n            continue;\n        join(t.x, t.y);\n        ans += t.w;\n    }\n    return ans;\n}\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    rep(i, 1, m) scanf(\"%d%d%d\", &e[i].x, &e[i].y, &e[i].w);\n    sort(e + 1, e + m + 1);\n    printf(\"%d\\n\", kruskal());\n    return 0;\n}\n```\n\n\n\nPrim算法更适合求稠密图的最小生成树，而Kruskal算法则更适合求稀疏图的最小生成树。\n\n![MST.jpg](https://i.loli.net/2020/03/13/O5gJTyZhsNrR12A.jpg)","tags":["图论"]},{"title":"扩展欧几里得算法","url":"/2020/02/25/Ex_GCD/","content":"\n\n扩展欧几里得算法可以找出一对整数 $(x,y)$，使得 $ax+by=\\gcd(a,b)$。\n\n<!--more-->\n\n首先放上欧几里得算法，就是小学数学中的辗转相除法求最大公约数：\n\n```c++\nint gcd(int a,int b){\n    return !b ? a : gcd(b, a % b);\n}\n```\n\n该算法的正确性是显而易见的。利用欧几里得算法可以在 $O(\\log n)$ 的时间中算出最大公约数。\n\n由裴蜀定理，可以得知该不定方程是有解的。\n\n下面来对式子 $ax+by=\\gcd(a,b)$ 做一点变形：$ax+by=\\gcd(a,b)=\\gcd(b,a\\mod b)$，有 $bx+(a\\mod b)y=bx+(a-\\lfloor \\frac a b \\rfloor b)y=\\gcd(b,a\\mod b)$，即 $ay+b(x-\\lfloor \\frac a b \\rfloor y)=\\gcd(b,a\\mod b)$，这意味着可以递归求解 $(x,y)$。这个递归过程和欧几里得算法的递归是一样的，在递归边界 $b=0$ 处，可以发现 $\\gcd(a,0)=a$，所以 $x=1,y=0$。\n\n以上过程可以得到这样的代码：（$d$ 是最大公约数）\n\n```c++\nvoid exgcd(int a, int b, int &d, int &x, int &y){\n    if (b == 0)\n        d = a, x = 1, y = 0;\n    else{\n        exgcd(b, a % b, d, y, x);\n        y -= x * (a / b);\n    }\n}\n```\n\n这就是扩展欧几里得算法，从代码中可以看到它包含了欧几里得算法，显然复杂度也没有改变。\n\n使用该算法可以解决 $ax+by=c$ 的整数解问题，首先判断 $\\gcd(a,b)$ 能否整除 $c$，如果不能那么一定不会有整数解，如果能整除就用exgcd算。\n\n**简单的例题：[洛谷P1082](https://www.luogu.com.cn/problem/P1082)**\n\n求关于 $x$ 的同余方程 $ax\\equiv 1(\\mod b)$ 的最小正整数解。\n\n对方程稍作变形，就可以利用exgcd了。由 $ax\\equiv 1(\\mod b)$ 可得 $ax-by=1$ ，由于 $y$ 的正负并没有影响，故等价于 $ax+by=1$，那么需要使 $\\gcd(a,b)=1$，即两数互质，这就是答案存在的前提，题目也已经保证了这一点。到这一步后就可以直接用了，最后得出的 $x$ 就是一个整数解，但它不一定是最小的，甚至不一定是整数，所以还需要再取模处理一下。\n\n这样解出的 $x$ 就是 $a$ 在模 $b$ 意义下的乘法逆元。也就是说，在模 $b$ 意义下如果除以 $a$ 很麻烦，那么可以乘上 $x$ 起到同样的效果。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nvoid exgcd(int a, int b, int &d, int &x, int &y)\n{\n    if (b == 0)\n        d = a, x = 1, y = 0;\n    else\n    {\n        exgcd(b, a % b, d, y, x);\n        y -= x * (a / b);\n    }\n}\nint main()\n{\n    int a, b, d, x, y;\n    cin >> a >> b;\n    exgcd(a, b, d, x, y);\n    cout << (x % b + b) % b;\n    return 0;\n}\n```\n\n","tags":["数论"]},{"title":"AVL树","url":"/2020/02/12/AVL_Tree/","content":"\n# 简介：\n\nAVL树是最先发明的自平衡二叉查找树。AVL树高度平衡，其任意节点左右子树的高度差不超过1。同时它也拥有普通二叉查找树的性质，即每个节点左子树上所有节点的值均小于根节点的值，右子树上所有节点的值均大于根节点的值，且不同节点的值均不同。\n\n<!--more-->\n\n# 实现过程\n**平衡因子：**每个节点左子树和右子树的高度差。若所有节点平衡因子的绝对值均不超过1则平衡。\n\n使用一个结构体保存节点的键值、频数、以该点为根的树的树高和大小以及左右子树。当树不平衡时，可以通过旋转使树平衡。\n\n```c++\nstruct AVL_node;\ntypedef AVL_node *AVL_Tree;\nstruct AVL_node\n{\n    int value, height, freq, size;\n    AVL_Tree ls, rs;\n    AVL_node() : value(0), height(1), freq(1), size(1), ls(nullptr), rs(nullptr) {}\n    AVL_node(int n) : value(n), height(1), freq(1), size(1), ls(nullptr), rs(nullptr) {}\n};\n```\n\n**不平衡情况1（左-左）：**\n\n![1](https://i.loli.net/2020/02/12/BYrixbevTfP8cR4.png)\n\n在插入1之前，树是平衡的，但是9的左子树比右子树高度大。在9的左子树的左子树插入1（或2，4，5）后，树不平衡了，这种左子树更高且向左子树的左子树插入节点的情况可以通过一次右旋来使树平衡。右旋使原来不平衡的根节点的左子树成为根节点，而原来的根节点成为新的右子树，原来左子树的右子树成为原来的根节点的左子树。容易证明，旋转后依旧具有二叉查找树的性质。\n\n![2](https://i.loli.net/2020/02/12/mz46SiMWg5lTcfJ.png)\n\n```c++\ninline void rotate_ls_ls(AVL_Tree &p)\n{\n    AVL_Tree q;\n    q = p->ls;\n    p->ls = q->rs;\n    q->rs = p;\n    update(p);\n    update(q);\n    p = q;\n}\n```\n**不平衡情况2（右-右）：**\n\n![3](https://i.loli.net/2020/02/12/f5eClWkqbJ7XywL.png)\n\n在插入13之前，树是平衡的，但是8的右子树比左子树高度大。在8的右子树的右子树插入13（或11）后，树不平衡了，这种右子树更高且向右子树的右子树插入节点的情况可以通过一次左旋来使树平衡。左旋使原来不平衡的根节点的右子树成为根节点，而原来的根节点成为新的左子树，原来右子树的左子树成为原来的根节点的右子树。同样，旋转后依旧具有二叉查找树的性质。\n\n![4](https://i.loli.net/2020/02/12/vhUgRs8SFj41HmV.png)\n```c++\ninline void rotate_rs_rs(AVL_Tree &p)\n{\n    AVL_Tree q;\n    q = p->rs;\n    p->rs = q->ls;\n    q->ls = p;\n    update(p);\n    update(q);\n    p = q;\n}\n```\n**不平衡情况3：（左-右）**\n\n![5](https://i.loli.net/2020/02/12/dRS1WHXAN7MlUhg.png)\n\n这种情况是在左子树更高的树的左子树的右子树插入节点，需要先进行一次左旋，再进行一次右旋。\n\n左旋：\n\n![6](https://i.loli.net/2020/02/12/9S1xL8N2FIvhuZA.png)\n\n右旋：\n\n![7](https://i.loli.net/2020/02/12/WgVKU1dbrEno9Ra.png)\n```c++\ninline void rotate_ls_rs(AVL_Tree &p)\n{\n    rotate_rs_rs(p->ls);\n    rotate_ls_ls(p);\n}\n```\n**不平衡情况4：（右-左）**\n\n与情况3相反，先进行一次右旋，再进行一次左旋。\n\n![8](https://i.loli.net/2020/02/12/6KXb74TNLQUO1RB.png)\n\n右旋：\n\n![9](https://i.loli.net/2020/02/12/V5JZvClKTzU8qcP.png)\n\n左旋：\n\n![10](https://i.loli.net/2020/02/12/2h8ktCgqNnZR3IW.png)\n```c++\ninline void rotate_rs_ls(AVL_Tree &p)\n{\n    rotate_ls_ls(p->rs);\n    rotate_rs_rs(p);\n}\n```\n\n**获取树的大小**\n\n```c++\ninline int get_size(AVL_Tree p)\n{\n    if (p == nullptr)\n        return 0;\n    return p->size;\n}\n```\n\n**获取树的高度**\n\n```c++\ninline int get_height(AVL_Tree p)\n{\n    if (p == nullptr)\n        return 0;\n    return p->height;\n}\n```\n\n**更新**\n\n```c++\ninline void update(AVL_Tree &p)\n{\n    p->size = get_size(p->ls) + get_size(p->rs) + p->freq;\n    p->height = max(get_height(p->ls), get_height(p->rs)) + 1;\n}\n```\n\n**插入**\n\n```c++\nvoid AVL_insert(AVL_Tree &p, int x)\n{\n    if (p == nullptr)\n    {\n        p = new AVL_node(x);\n        return;\n    }\n    if (p->value == x)//已经存在,频数+1\n    {\n        (p->freq)++;\n        update(p);\n        return;\n    }\n    if (p->value > x)\n    {\n        AVL_insert(p->ls, x);\n        update(p);\n        if (get_height(p->ls) - get_height(p->rs) == 2)//插到左边,左边更高\n        {\n            if (x < p->ls->value)\n                rotate_ls_ls(p);\n            else\n                rotate_ls_rs(p);\n        }\n    }\n    else\n    {\n        AVL_insert(p->rs, x);\n        update(p);\n        if (get_height(p->rs) - get_height(p->ls) == 2)//插到右边,右边更高\n        {\n            if (x > p->rs->value)\n                rotate_rs_rs(p);\n            else\n                rotate_rs_ls(p);\n        }\n    }\n    update(p);\n}\n```\n\n**删除数据**\n\n```c++\nvoid AVL_erase(AVL_Tree &p, int x)\n{\n    if (p == nullptr)\n        return;\n    if (p->value > x)\n    {\n        AVL_erase(p->ls, x);\n        update(p);\n        if (get_height(p->rs) - get_height(p->ls) == 2)//删左边，右边高\n        {\n            if (get_height(p->rs->rs) >= get_height(p->rs->ls))//见代码后注释\n                rotate_rs_rs(p);\n            else\n                rotate_rs_ls(p);\n        }\n    }\n    else if (p->value < x)\n    {\n        AVL_erase(p->rs, x);\n        update(p);\n        if (get_height(p->ls) - get_height(p->rs) == 2)\n        {\n            if (get_height(p->ls->ls) >= get_height(p->ls->rs))\n                rotate_ls_ls(p);\n            else\n                rotate_ls_rs(p);\n        }\n    }\n    else\n    {\n        if (p->freq > 1)\n        {\n            (p->freq)--;\n            update(p);\n            return;\n        }\n        if (p->ls && p->rs)\n        {\n            AVL_Tree q;\n            q = p->rs;\n            while (q->ls)\n                q = q->ls;\n            p->freq = q->freq;\n            p->value = q->value;\n            q->freq = 1; //删除q\n            AVL_erase(p->rs, q->value);\n            if (get_height(p->ls) - get_height(p->rs) == 2)\n            {\n                if (get_height(p->ls->ls) >= get_height(p->ls->rs))\n                    rotate_ls_ls(p);\n                else\n                    rotate_ls_rs(p);\n            }\n        }\n        else\n        {\n            AVL_Tree q;\n            q = p;\n            if (p->ls)\n                p = p->ls;\n            else if (p->rs)\n                p = p->rs;\n            else\n                p = nullptr;\n            delete q;\n            q = nullptr;\n        }\n    }\n    if (p == nullptr)\n        return;\n    update(p);\n}\n```\n\n第11行必须用$\\ge$，否则遇到如图的情况：\n\n![11](https://i.loli.net/2020/02/12/XuxmhoWtJvaCqwp.png)\n\n删去13后，先右旋再左旋，树仍然不是平衡的：\n\n![12](https://i.loli.net/2020/02/12/U4IajS9vukohHml.png)\n\n**通过值查找位次**\n\n```c++\nint get_rank(AVL_Tree p, int x)\n{\n    if (p->value == x)\n        return get_size(p->ls) + 1;\n    if (p->value > x)\n        return get_rank(p->ls, x);\n    return get_rank(p->rs, x) + get_size(p->ls) + p->freq;\n}\n```\n\n**通过位次查找值**\n\n```c++\nint get_val(AVL_Tree p, int r)\n{\n    if (get_size(p->ls) >= r)\n        return get_val(p->ls, r);\n    if (get_size(p->ls) + p->freq >= r)\n        return p->value;\n    return get_val(p->rs, r - get_size(p->ls) - p->freq);\n}\n```\n\n**查找前驱**\n\n```c++\nint get_pre(AVL_Tree p, int x)\n{\n    AVL_Tree ans = new AVL_node(-inf);\n    while (p)\n    {\n        if (p->value == x)\n        {\n            if (p->ls)\n            {\n                p = p->ls;\n                while (p->rs)\n                {\n                    p = p->rs;\n                }\n                ans = p;\n            }\n            break;\n        }\n        if (p->value < x && p->value > ans->value)\n            ans = p;\n        p = p->value < x ? p->rs : p->ls;\n    }\n    return ans->value;\n}\n```\n\n**查找后继**\n\n```c++\nint get_suf(AVL_Tree p, int x)\n{\n    AVL_Tree ans = new AVL_node(inf);\n    while (p)\n    {\n        if (p->value == x)\n        {\n            if (p->rs)\n            {\n                p = p->rs;\n                while (p->ls)\n                {\n                    p = p->ls;\n                }\n                ans = p;\n            }\n            break;\n        }\n        if (p->value > x && p->value < ans->value)\n            ans = p;\n        p = p->value < x ? p->rs : p->ls;\n    }\n    return ans->value;\n}\n```\n\n**中序遍历**\n\n```c++\nvoid output(AVL_Tree p)\n{\n    if(p==nullptr)\n        return;\n    output(p->ls);\n    for (int i = 1; i <= p->freq;i++)\n        printf(\"%d \", p->value);\n    output(p->rs);\n}\n```\n\nAVL树的插入、删除、查找都是$\\log$级别的复杂度，其中AVL树的查询和其它平衡树相比会更有优势，但是AVL树代码量比较大，总体速度也很一般，可以分裂合并，可持久化，但是比较难写。\n\n终于写完了，真是不容易。\n\n![v2-28825ec8201c53892205bfd8b41c97dd_hd.jpg](https://i.loli.net/2020/02/12/1scLYZaiKRt25N3.jpg)\n\n\n","tags":["数据结构"]},{"title":"洛谷P3369题解","url":"/2020/02/12/P3369-Solution/","content":"\n### 链接：[P3369](https://www.luogu.com.cn/problem/P3369)\n<!--more-->\n\n# 题解：\n题目要求用一个数据结构实现一些数的插入、删除、根据排名查找数、根据数值询问排名以及求前驱和后继，所以可以通过建一棵AVL树来实现。\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 0x7FFFFFFF;\nstruct AVL_node;\ntypedef AVL_node *AVL_Tree;\nstruct AVL_node\n{\n    int value, height, freq, size;\n    AVL_Tree ls, rs;\n    AVL_node() : value(0), height(1), freq(1), size(1), ls(nullptr), rs(nullptr) {}\n    AVL_node(int n) : value(n), height(1), freq(1), size(1), ls(nullptr), rs(nullptr) {}\n};\ninline int get_size(AVL_Tree p)\n{\n    if (p == nullptr)\n        return 0;\n    return p->size;\n}\ninline int get_height(AVL_Tree p)\n{\n    if (p == nullptr)\n        return 0;\n    return p->height;\n}\ninline void update(AVL_Tree &p)\n{\n    p->size = get_size(p->ls) + get_size(p->rs) + p->freq;\n    p->height = max(get_height(p->ls), get_height(p->rs)) + 1;\n}\ninline void rotate_ls_ls(AVL_Tree &p)\n{\n    AVL_Tree q;\n    q = p->ls;\n    p->ls = q->rs;\n    q->rs = p;\n    update(p);\n    update(q);\n    p = q;\n}\ninline void rotate_rs_rs(AVL_Tree &p)\n{\n    AVL_Tree q;\n    q = p->rs;\n    p->rs = q->ls;\n    q->ls = p;\n    update(p);\n    update(q);\n    p = q;\n}\ninline void rotate_ls_rs(AVL_Tree &p)\n{\n    rotate_rs_rs(p->ls);\n    rotate_ls_ls(p);\n}\ninline void rotate_rs_ls(AVL_Tree &p)\n{\n    rotate_ls_ls(p->rs);\n    rotate_rs_rs(p);\n}\nvoid AVL_insert(AVL_Tree &p, int x)\n{\n    if (p == nullptr)\n    {\n        p = new AVL_node(x);\n        return;\n    }\n    if (p->value == x)\n    {\n        (p->freq)++;\n        update(p);\n        return;\n    }\n    if (p->value > x)\n    {\n        AVL_insert(p->ls, x);\n        update(p);\n        if (get_height(p->ls) - get_height(p->rs) == 2)\n        {\n            if (x < p->ls->value)\n                rotate_ls_ls(p);\n            else\n                rotate_ls_rs(p);\n        }\n    }\n    else\n    {\n        AVL_insert(p->rs, x);\n        update(p);\n        if (get_height(p->rs) - get_height(p->ls) == 2)\n        {\n            if (x > p->rs->value)\n                rotate_rs_rs(p);\n            else\n                rotate_rs_ls(p);\n        }\n    }\n    update(p);\n}\nvoid AVL_erase(AVL_Tree &p, int x)\n{\n    if (p == nullptr)\n        return;\n    if (p->value > x)\n    {\n        AVL_erase(p->ls, x);\n        update(p);\n        if (get_height(p->rs) - get_height(p->ls) == 2)\n        {\n            if (get_height(p->rs->rs) >= get_height(p->rs->ls))\n                rotate_rs_rs(p);\n            else\n                rotate_rs_ls(p);\n        }\n    }\n    else if (p->value < x)\n    {\n        AVL_erase(p->rs, x);\n        update(p);\n        if (get_height(p->ls) - get_height(p->rs) == 2)\n        {\n            if (get_height(p->ls->ls) >= get_height(p->ls->rs))\n                rotate_ls_ls(p);\n            else\n                rotate_ls_rs(p);\n        }\n    }\n    else\n    {\n        if (p->freq > 1)\n        {\n            (p->freq)--;\n            update(p);\n            return;\n        }\n        if (p->ls && p->rs)\n        {\n            AVL_Tree q;\n            q = p->rs;\n            while (q->ls)\n                q = q->ls;\n            p->freq = q->freq;\n            p->value = q->value;\n            q->freq = 1; //to erase q;\n            AVL_erase(p->rs, q->value);\n            if (get_height(p->ls) - get_height(p->rs) == 2)\n            {\n                if (get_height(p->ls->ls) >= get_height(p->ls->rs))\n                    rotate_ls_ls(p);\n                else\n                    rotate_ls_rs(p);\n            }\n        }\n        else\n        {\n            AVL_Tree q;//防止内存泄漏\n            q = p;\n            if (p->ls)\n                p = p->ls;\n            else if (p->rs)\n                p = p->rs;\n            else\n                p = nullptr;\n            delete q;\n            q = nullptr;\n        }\n    }\n    if (p == nullptr)\n        return;\n    update(p);\n}\nint get_rank(AVL_Tree p, int x)\n{\n    if (p->value == x)\n        return get_size(p->ls) + 1;\n    if (p->value > x)\n        return get_rank(p->ls, x);\n    return get_rank(p->rs, x) + get_size(p->ls) + p->freq;\n}\nint get_val(AVL_Tree p, int r)\n{\n    if (get_size(p->ls) >= r)\n        return get_val(p->ls, r);\n    if (get_size(p->ls) + p->freq >= r)\n        return p->value;\n    return get_val(p->rs, r - get_size(p->ls) - p->freq);\n}\nint get_pre(AVL_Tree p, int x)\n{\n    AVL_Tree ans = new AVL_node(-inf);\n    while (p)\n    {\n        if (p->value == x)\n        {\n            if (p->ls)\n            {\n                p = p->ls;\n                while (p->rs)\n                {\n                    p = p->rs;\n                }\n                ans = p;\n            }\n            break;\n        }\n        if (p->value < x && p->value > ans->value)\n            ans = p;\n        p = p->value < x ? p->rs : p->ls;\n    }\n    return ans->value;\n}\nint get_suf(AVL_Tree p, int x)\n{\n    AVL_Tree ans = new AVL_node(inf);\n    while (p)\n    {\n        if (p->value == x)\n        {\n            if (p->rs)\n            {\n                p = p->rs;\n                while (p->ls)\n                {\n                    p = p->ls;\n                }\n                ans = p;\n            }\n            break;\n        }\n        if (p->value > x && p->value < ans->value)\n            ans = p;\n        p = p->value < x ? p->rs : p->ls;\n    }\n    return ans->value;\n}\nAVL_Tree root;\nint main()\n{\n    int n, op, x;\n    scanf(\"%d\", &n);\n    for (register int i = 1; i <= n; i++)\n    {\n        scanf(\"%d%d\", &op, &x);\n        switch (op)\n        {\n        case 1:\n            AVL_insert(root, x);\n            break;\n        case 2:\n            AVL_erase(root, x);\n            break;\n        case 3:\n            printf(\"%d\\n\", get_rank(root, x));\n            break;\n        case 4:\n            printf(\"%d\\n\", get_val(root, x));\n            break;\n        case 5:\n            printf(\"%d\\n\", get_pre(root, x));\n            break;\n        case 6:\n            printf(\"%d\\n\", get_suf(root, x));\n            break;\n        default:\n            break;\n        }\n    }\n    return 0;\n}\n```\n\n[今天才学会的AVL树](https://phlzy.github.io/2020/02/12/AVL_Tree/)","tags":["洛谷","2020寒假"]},{"title":"ST表(Sparse Table)","url":"/2020/02/01/Sparse_Table/","content":"\n# 简介：\n\nST表类似于树状数组和线段树，是一种用于解决RMQ（Range Minimum/Maximum Query，区间最值查询）问题的离线算法。\n与线段树相比，ST表预处理复杂度同为  $ O(nlogn) $ ，查询时间上，ST表为  $ O(1) $，线段树为  $ O(nlogn) $。\nST表的主体是一个二维数组  $ ST{_i}{_j} $ ，表示需要查询的数组的从下标  $ i $  到下标  $ i+2^j - 1 $  的最值。\n\n<!--more-->\n\n# 模板题[(P3865)](https://www.luogu.com.cn/problem/P3865)简述：\n\n给定一个长度为 $ N $ 的数列，和 $ M $ 次询问，求出每一次询问的区间内数字的最大值。\n\n## 输入:\n第一行包含两个整数 $ N $ ， $ M $ ，分别表示数列的长度和询问的个数。\n第二行包含 $ N $ 个整数（记为 $ a_i $ ），依次表示数列的第 $ i $ 项。\n接下来 $ M $ 行，每行包含两个整数 $ l_i $ ， $ r_i $ ，表示查询的区间为 $ [l_i,r_i] $ 。\n\n## 输出:\n输出包含 $ M $ 行，每行一个整数，依次表示每一次询问的结果。\n# 题解：\n\n首先，对输入数据进行预处理： $ ST{_i}{_j} $ 表示区间上从第 $ i $ 个位置（包括自己）开始，向后数 $ 2^j $ 个数中的最值；\n显然， $ ST{_i}{_0} $ 即为输入的数组本身，而 $ j>0 $ 时， $ ST{_i}{_j} $ 取其包含的两个小区间的最（大）值。\n由于ST表需要一层一层地生成，在预处理时要将某个长度的每一段都生成后再生成更长的段，其循环部分的书写比较特殊，将 $ j $ 写在 $ i $ 的外面看起来更为直观。\n在查询时，因为区间长度都是2的幂，需要先找到不大于查询区间的2的最大次幂，并以查询的区间的左端点为起点查询一次，再以查询的区间的右端点为终点查询一次，然后进行比较。这样可以保证在最少的查询次数下获得所求的最值。\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint ST[100001][21];\nint query(int left, int right)\n{\n    int k = log2(right - left + 1);\n    return max(ST[left][k], ST[right - (1 << k) + 1][k]);\n}\nint main()\n{\n    int n, m, left, right;\n    scanf(\"%d%d\", &n, &m);\n    for (register int i = 1; i <= n; i++)\n        scanf(\"%d\", &ST[i][0]);\n    for (register int j = 1; j <= 21; j++)\n        for (register int i = 1; i + (1 << j) - 1 <= n; i++)\n            ST[i][j] = max(ST[i][j - 1], ST[i + (1 << (j - 1))][j - 1]);\n    for (register int i = 1; i <= m; i++)\n    {\n        scanf(\"%d%d\", &left, &right);\n        printf(\"%d\\n\", query(left, right));\n    }\n    return 0;\n}\n```\n\n","tags":["数据结构"]}]