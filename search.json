[{"title":"首页-重要更新[置顶]","url":"/9999/12/31/main/","content":"\n**由于Windows10系统不稳定，存在一些未完成的文章丢失的情况，新文章将会发布在[我的CSDN博客](https://me.csdn.net/Pastafarian)上，本博客不定期更新，具体恢复时间待定。**\n\n<!--more-->\n\n\n![main](https://ipcounter.ihcr.top/?mode=2&mail=phlzy1@163.com&&gh=phlzy&lg=_Watson&strsize=15&pic=Chtholly&str=Talk%20is%20cheap.Show%20me%20the%20code.)\n\n##### [![](https://cfrating.ihcr.top/?user=_Watson&style=for-the-badge)](https://codeforces.com/profile/_Watson)\n##### [![](https://cfrating.ihcr.top/?user=Watson_2020&style=for-the-badge)](https://codeforces.com/profile/Watson_2020)\n\n\n博客中的[$\\LaTeX{}$](http://www.mohu.org/info/symbols/symbols.htm)[公式](https://blog.csdn.net/garfielder007/article/details/51646604)可能需要一些时间来加载。\n\n![rainbow](https://i.loli.net/2020/02/02/FaQY4pvPuTi2W9S.png)\n\n- [$\\mathcal{Kuangbin}$](https://vjudge.net/article/187)\n- [洛谷模板题](https://www.luogu.com.cn/paste/w3ez5yjz)\n\n| 时间       | 成就      |\n| ---------- | --------- |\n| 2019.11.6  | 做完NOJ   |\n| 2019.11.24 | 洛谷橙名  |\n| 2020.1.15  | 洛谷AC100 |\n| 2020.7.14  | 洛谷AC200 |\n\n\n","tags":["其它"]},{"title":"test","url":"/2020/09/01/test0901/","content":"\n\n\n测试一下\n\n\n\n<!--more-->\n\n\n测试\n","tags":["其它"]},{"title":"有趣的图论和数据结构等","url":"/2020/08/31/2020-8-index/","content":"\n\n\n计划每天学一个新东西，比赛多的时候就写简单的或者不重要的，别的就在比赛少的时候写。反正是写给自己看，有些有趣的数据结构也就写一写当做娱乐好了。\n\n\n\n<!--more-->\n\n|                        内容（原计划）                        |    更新版    |\n| :----------------------------------------------------------: | :----------: |\n|        [LCA](https://phlzy.github.io/2020/08/14/LCA/)        |              |\n| [DFS序，树链剖分](https://phlzy.github.io/2020/08/18/path_decomposition/) |              |\n|  [左偏树](https://phlzy.github.io/2020/08/16/Leftist_Tree/)  |              |\n|                            扫描线                            |              |\n|                        ~~各种生成树~~                        | 计算几何基础 |\n| [zkw线段树](https://phlzy.github.io/2020/08/19/zkw_Segment_Tree/) |              |\n|                            划分树                            |              |\n|                      ~~可持久化线段树~~                      |   旋转卡壳   |\n|                            伸展树                            |              |\n|                        ~~FHQ-Treap~~                         |   半平面交   |\n|                           ~~斜堆~~                           |  Lucas定理   |\n|                          ~~点分治~~                          |   排列组合   |\n|                          ~~树套树~~                          |              |\n|                           ~~LCT~~                            |              |\n|                          ~~Tarjan~~                          |              |\n|                          ~~网络流~~                          |              |\n\n\n\n顺便放上[模板的链接](https://phlzy.github.io/2020/08/12/Template/)\n\n[踩过的坑](https://phlzy.github.io/2020/08/19/Tips/)\n\n\n\n![阿尔托莉雅](https://i.loli.net/2020/08/19/38fVQGqbd6BZKIe.jpg)\n\n\n\n## 8月23日大更新\n\n两场组队练习赛下来已经可以发现目前我们队的几个弱点，结合我个人的情况需要修改一下接下来一段时间的训练方向：\n\n1. 队友的图论能力很强，对字符串科技的了解也远高于我，所以我目前不必在这两方面花太多时间\n2. 计算几何和数论是我们都不太擅长的地方，也是接下来我需要注重的地方\n3. 对数据结构的考察更侧重于灵活运用而不是深入了解，所以可持久化数据结构和别的黑科技就先不去看了\n4. 快而准确的翻译也非常重要\n5. 虽然我们切水题的速度比较快，但是细节方面可以做的更好，并且我的手速和代码能力也需提高\n\n综上所述，我接下来需要：\n\n- 练一练大模拟题\n- 继续多打cf和ATCoder\n- 计算几何\n- 数论、概率论\n- 剩余时间（重要性递减）\n  - 英语（反正也要考六级了）\n  - 数据结构科技\n  - DP\n  - 博弈论\n  - 图论（树上操作，网络流等）\n  - 字符串（自动机，后缀科技）\n\n","tags":["其它"]},{"title":"关于游泳","url":"/2020/08/31/swim/","content":"\n\n是时候，该为我近十五年的游泳运动生涯画上句号了。\n\n\n\n<!--more-->\n\n昨天晚上快要打cf的比赛的时候，学校游泳队的队长大哥问我脚蹼尺码，当时比较忙没有马上回复，直到打完比赛在微信上打字的时候，我突然意识到，这将近15年的游泳运动生涯，似乎是真的结束了。\n\n退出校游泳队的想法并不是昨天突然萌生的，而是在几个月前早就有了，当时由于受到疫情影响游泳队一个学期都没有训练，我也没有提出这个想法。吴清源说的“不搏二兔”我觉得非常有道理，既然我选择将几乎全部业余时间用于ACM的训练，每周一个上午的游泳训练也自然需要放弃了。\n\n虽然我从未真正从心里喜欢过游泳这项运动，小时候也曾多次寻找机会试图放弃，但是毕竟是比较专业的练了五六年，最近几年也有几次比赛需要参加，说完全没有感情也是不可能的。当年在体育场的体能训练、备战市运会的一天双练、打酱油的迎春杯省赛等场景仍然历历在目。大学游泳队的氛围也很好，我在之前的训练中对我们学校游泳队的水平可以说非常了解，作为游泳队的主力，这样退役让我心怀愧疚，但是我必须这么做。\n\n三四年前我虽然已经很久没有训练，但是在自己调整了不到一周后，我的50米自由泳依然可以冲到28秒，还是可以带领团队拿到金牌。自由泳并不是我小时候练的主项，但是三年前的我，称一句“宝刀未老”，应该也不算太过。可是大半年前，在校队训练了几次的我50米自由泳仍然无法游进30秒，虽然客观上泳池规格、出发形式以及赛程都对成绩有影响，但是我的状态确实是不复当年了。又过了大半年，以我目前的竞技状态，也只能在校队中表现一下，如果代表学校外出比赛，必然是没有什么希望的。\n\n本来我的游泳运动生涯可能在几年前选择了学业就早早结束了，但是比赛总是阴魂不散，说不定什么时候，就要重新回去训练一下，应付比赛了。这一次，应该是真的结束了。\n\n还记得小时候父亲逼我坚持练游泳，他不止一次对我说，他并不希望我今后成为职业运动员，但是希望我能够熟练掌握游泳的技能，并获得强健的体魄。在他看来，学会游泳不仅多了一项求生的工具，也多了一种爱好、多掌握了一种门技术。从某种角度来说，他说的并没有问题，但是仔细想想，似乎也并不是那么回事。如今我确实掌握了各种游泳的技术，可能在人群中，能在泳池中超过我的人不到千分之一，但是这只是在泳池的理想环境中，如果在洪水中、海里或是任何未知的水域中，我和绝大多数普通人并没有太大的区别。在湍急的水流中，即便是奥运冠军也不能保证自己的安全。游泳的技能在这十多年中，也并没有给我带来多少好处，除了大一上学期免去了体育锻炼课与30次打卡，就是那几块几乎毫无价值的奖牌，剩下能让我长久铭记的，可能是十年前两次急性肠胃炎的滋味。\n\n对别人来说，游泳代表的可能是夏日的清凉，是暑假的悠闲，是玩水的快乐，而这些对我来说几乎都没有。我并不喜欢去游泳，我更喜欢待在家里，做我想做的事情。\n\n有人觉得，被ACM束缚的大学生活，很亏。我觉得不然。高中的时候比较喜欢化学，也曾希望未来从事化学方面的工作，是因为学习化学的时候我可以感受到化学的美，感受到自然规律的巧妙。由于种种原因，我最终也没有选择化学相关的专业，当年的梦想现在已经用来追忆了。在学习其它科目的过程中，我并不能感受到那种知识的美妙之处，直到接触到了这些算法与数据结构，这是与化学不同的美，是人类用智慧创造出的精妙理论之美。我终于和当年一样，在学习知识的时候能够重新给自己正向的反馈，而不是觉得在浪费自己的生命。\n\n人的生命非常有限，我也只是一个普通人，我很清楚的知道想达到像Tarjan、Dijkstra这样的成就几乎是不可能的，我只希望，我能在我愿意研究的领域中，留下一点探索的痕迹，在未来有和我同样兴趣的人探索到这个地方的时候，能够欣慰的说，原来从前也有这样的一个人和我一样走到了这里，看到了这里的奥秘。如果能够做到这样，我想我生命的价值也就达到了。\n\n总是有人说什么艺多不压身，说到底还是在欺骗自己，人的时间是有限的，搞的好像自己会了很多东西，学一身三脚猫功夫，什么事情都做不好，还让自己看起来很忙很努力，真是毫无意义。几百年前还有所谓的“全才”，后来就没有了，也证明了这个观点。国内有理论计算机科学方向的大学非常少，我也不想在我不感兴趣的东西上浪费我的时间，所以我今后也并不怎么想读研。以后怎样，就随他去吧。\n\n一想到以后可以少做一件不怎么感兴趣的事，多了一些时间追求目前的理想，也就畅快了不少。理想屈服于现实的感受，真的不怎么样，我也不希望再体会一次。\n\n![hikaru](https://i.loli.net/2020/08/31/Vr8IknRaj2SvfGx.png)\n\n在这里放这张图真是再合适不过了","tags":["随笔"]},{"title":"AtCoder Beginner Contest 177","url":"/2020/08/29/ABC177/","content":"\n\n\n虽然题目很水，但是。。。\n\n\n\n<!--more-->\n\n## A\n\n显然\n\n```c++\nll a, b, c;\ncin >> a >> b >> c;\nif (b * c >= a)\n    cout << \"Yes\" << endl;\nelse\n    cout << \"No\" << endl;\n```\n\n## B\n\n看数据范围，直接暴力\n\n```c++\nstring s, t;\ncin >> s >> t;\nint ans = inf;\nint a = s.length(), b = t.length();\nfor (int i = 0; i < a; ++i)\n{\n    int cnt = 0;\n    if (i + b - 1 >= a)\n        break;\n    for (int j = 0; j < b; ++j)\n        if (s[i + j] != t[j])\n            cnt++;\n    ans = min(ans, cnt);\n}\n```\n\n## C\n\n式子都给你了，无脑前缀和，居然Wa了两发，真的傻逼\n\n```c++\nint n;\nread(n);\nfor (int i = 1; i <= n; ++i)\n{\n    read(a[i]);\n    s[i] = (s[i - 1] + a[i]);\n}\nll ans = 0;\nfor (int i = 1; i < n; ++i)\n{\n    ans += a[i] * ((s[n] - s[i]) % mod) % mod;\n    ans %= mod;\n}\ncout << ans % mod << endl;\n```\n\n算前缀和的时候不要取模，这种地方也能错也是没谁了\n\n## D\n\n并查集裸题，求最大集合的大小\n\n```c++\nint fa[maxn], a[maxn];\nint findfa(int x)\n{\n    return fa[x] == x ? x : fa[x] = findfa(fa[x]);\n}\nvoid join(int x, int y)\n{\n    int fx = findfa(x), fy = findfa(y);\n    if (fx != fy)\n        fa[fx] = fy;\n}\nmap<int, int> mp;\nsigned main()\n{\n    int m, n;\n    read(m), read(n);\n    for (int i = 1; i <= m; ++i)\n        fa[i] = i;\n    for (int i = 1; i <= n; ++i)\n    {\n        int u, v;\n        read(u), read(v);\n        join(u, v);\n    }\n    int ans = 0;\n    for (int i = 1; i <= m; ++i)\n    {\n        findfa(i);\n        mp[fa[i]]++;\n        ans = max(ans, mp[fa[i]]);\n    }\n    cout << ans << endl;\n    return 0;\n}\n```\n\n自己写的时候路径压缩还写错了一次，虽然很快就改对了\n\n## E\n\n虽然秒出了正解，但是一直没调对。。。\n\n显然，如果是 `pairwise coprime` 的，说明任意两个不同元素不会有相同质因子，那么用欧拉筛先找出范围内所有质因子然后进行一遍匹配，如果某个质因子匹配到的元素个数超过一个就说明不符合条件。剩下两种情况直接 $O(n)$ 跑一遍就好了。\n\n稍微观察一下就可以发现，上面的匹配过程和埃氏筛的原理差不多，复杂度是 $O(n\\log n)$ 的，没有任何问题。\n\n所以，为什么我在一个小时中尝试了各种写法，但是一次都没过呢？\n\n我居然用欧拉筛找的是 $[1,\\sqrt n]$ 区间中的质数！\n\n真服了。\n\n还有，这题会爆int。\n\n```c++\nconst int maxn = 1e6 + 9;\nbitset<maxn> num;\nvector<int> prime;\ninline void init(int n)\n{\n    for (int i = 2; i <= n; ++i)\n    {\n        if (!num[i])\n            prime.push_back(i);\n        for (int j = 0; j < prime.size(); ++j)\n        {\n            if (i * prime[j] >= n)\n                break;\n            num[i * prime[j]] = 1;\n            if (i % prime[j] == 0)\n                break;\n        }\n    }\n}\nvector<ll> v;\nunordered_map<ll, int> ump;\nint main()\n{\n    init(1000000);\n    int sz = prime.size();\n    int n;\n    ll maxx = 0;\n    read(n);\n    bool flag = true;\n    for (int i = 1; i <= n; ++i)\n    {\n        ll x;\n        maxx = max(maxx, x);\n        read(x);\n        ump[x]++;\n        v.emplace_back(x);\n    }\n    for (int i = 0; i < sz; ++i)\n    {\n        int tot = 0;\n        for (int j = 1;; ++j)\n        {\n            if (1LL * j * prime[i] > 1LL * maxx)\n                break;\n            tot += ump[j * prime[i]];\n        }\n        if (tot > 1)\n        {\n            flag = false;\n            break;\n        }\n    }\n    if (flag)\n    {\n        cout << \"pairwise coprime\" << endl;\n        return 0;\n    }\n    ll g = v[0];\n    for (int i = 1; i < n; ++i)\n        g = __gcd(g, v[i]);\n    if (g == 1)\n        cout << \"setwise coprime\" << endl;\n    else\n        cout << \"not coprime\" << endl;\n    return 0;\n}\n```\n\n这也从侧面证明了队友的重要性。当局者迷，旁观者清，要是有队友在场这种题可能十分钟就过了。\n\n当然，总是出这种傻逼错误也是很需要反省的。\n\n第二天回来一看，这题不仅可以这样做，甚至连 $O(n\\sqrt n)$ 的暴力做法也能过，这就更让人恼火了。\n\n## F\n\n有趣的题目，有趣的做法。\n\n有人用两棵线段树做，也有人用一个 `map` 和一个 `multiset`。下面的这份代码看得我似懂非懂，过两天回头再来看看。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nmap<int, int> m;\nmultiset<int> s;\nint main(){\n    int h, w, a, b;\n    cin >> h >> w;\n    for (int i = 0; i < w; i++)\n        m[i] = i, s.insert(0);\n    for (int i = 0; i < h; i++){\n        cin >> a >> b;\n        a--;\n        auto pos = m.lower_bound(a);\n        int mx = -1;\n        while (pos != m.end() && pos->first <= b){\n            mx = max(mx, pos->second);\n            int x = pos->first - pos->second;\n            s.erase(s.find(x));\n            m.erase(pos++);\n        }\n        if (mx != -1 && b < w){\n            s.insert(b - mx);\n            m[b] = mx;\n        }\n        cout << (s.empty() ? -1 : *s.begin() + i + 1) << endl;\n    }\n    return 0;\n}\n```\n\n根据代码大概可以知道 `multiset` 中存储的是最短水平移动距离，`map` 中的可能是水平移动的起点，并不是很确定。\n\n## 总结\n\n最近两场ABC都是至少可以过5题的，但是目标并没有达到。\n\n虽然ABC大部分题目难度很低，但是刷水题并不是没有意义，多打打这样的比赛可以提升速度与debug能力，也能巩固一些基础知识，还能维持一下比赛的状态。\n\n组队赛告一段落，我们最终排名第四，有点危险。\n\nCCF认证还有两个星期，不知道考什么，这两天还是先全面发展，看看图论和数学好了。这种考试也不可能考很难的数据结构之类的东西。\n\n暑假只剩最后一场cf，差32分上蓝。能不能完成之前立的flag，就看这次的发挥了。虽然说正常发挥的话只要把前三题比较快的过掉，基本就能达到目的了，但是我的状态波动也很大，结果如何还未尝可知。\n\n不管怎样，上蓝是迟早的事，新学期要到了，立一个新的flag，学期结束前上紫。\n\n让我们拭目以待。\n\n![83590230](https://i.loli.net/2020/08/30/nw3GJg8kPUKSBZV.jpg)","tags":["AtCoder"]},{"title":"Splay区间操作","url":"/2020/08/29/Splay_beta/","content":"\n前几天打比赛没时间写博客，这两天终于可以更新了。\n\nSplay虽然常数大，但是其Splay函数拥有一些神奇的性质，可以实现一些别的平衡树难以完成的操作，如序列翻转等。\n\n\n\n<!--more-->\n\n## 区间翻转\n\n有一个序列 $[1,n]$，每次翻转其中的 $[l,r]$，有 $q$ 次操作。\n\n如果直接模拟，复杂度 $O(qn)$。\n\n像AVL树、旋转式Treap、替罪羊树等常见的平衡树很难用来维护序列，因为如果对序列建树，需要修改的区间在平衡树中可能会分散在多个位置，不仅修改起来很复杂还无法发挥出平衡树的优势。而Splay的自我调整过程可以将待修改区间挤到一个子树中，就可以发挥出平衡树的优势了。\n\n具体来说，由于Splay操作每次将一个结点旋转到根结点，那么我们先把结点 $l-1$ Splay到根结点，显然区间 $[l,n]$ 现在就位于根结点的右子树了，然后再把结点 $r+1$ Splay到根结点的右儿子，那么 $r+1$ 的左子树就是区间 $[l,r]$ 了，我们只需要对这个子树的根打标记并像线段树一样传递标记即可实现区间翻转。复杂度 $O(q\\log n)$。\n\n代码如下：（[模板题P3391](https://www.luogu.com.cn/problem/P3391)）\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 1e5 + 9;\n\nstruct node\n{\n    int fa, sz, cnt, val, tag;\n    int son[2];\n    //node(){}\n};\nnode tree[maxn];\nint ori[maxn], root, wz;\ninline bool which(int x)\n{\n    return x == tree[tree[x].fa].son[1]; //left:0 right:1\n}\ninline void update(int x)\n{\n    if (x == 0)\n        return;\n    tree[x].sz = tree[x].cnt;\n    if (tree[x].son[0])\n        tree[x].sz += tree[tree[x].son[0]].sz;\n    if (tree[x].son[1])\n        tree[x].sz += tree[tree[x].son[1]].sz;\n}\ninline void push_down(int x)\n{\n    if (x && tree[x].tag)\n    {\n        tree[tree[x].son[0]].tag ^= 1;\n        tree[tree[x].son[1]].tag ^= 1;\n        swap(tree[x].son[0], tree[x].son[1]);\n        tree[x].tag = 0;\n    }\n}\ninline void rotate(int x)\n{\n    int f = tree[x].fa, gf = tree[f].fa;\n    push_down(x), push_down(f); //* push down the tags\n    bool w = which(x);\n    tree[f].son[w] = tree[x].son[w ^ 1];\n    tree[tree[f].son[w]].fa = f; //* conect son\n    tree[f].fa = x;\n    tree[x].fa = gf;\n    tree[x].son[w ^ 1] = f; //* conect father\n    if (gf != 0)\n        tree[gf].son[tree[gf].son[1] == f] = x; //* update grandpa\n    update(f);\n}\nvoid splay(int x, int to)\n{\n    while (tree[x].fa != to)\n    {\n        int y = tree[x].fa;\n        if (tree[y].fa != to)\n            rotate(which(x) == which(y) ? y : x);\n        rotate(x);\n    }\n    if (to == 0)\n        root = x; //! very important\n}\nint build(int l, int r, int fa)\n{\n    if (l > r)\n        return 0;\n    int mid = (l + r) >> 1;\n    int now = ++wz;\n    tree[now].fa = fa;\n    tree[now].cnt = 1;\n    tree[now].val = ori[mid];\n    tree[now].sz = 1;\n    tree[now].son[0] = build(l, mid - 1, now);\n    tree[now].son[1] = build(mid + 1, r, now);\n    update(now);\n    return now;\n}\nint find_val(int x)\n{\n    int now = root;\n    while (1)\n    {\n        push_down(now);\n        if (x <= tree[tree[now].son[0]].sz)\n            now = tree[now].son[0];\n        else\n        {\n            x -= tree[tree[now].son[0]].sz + 1;\n            if (x == 0)\n                return now;\n            now = tree[now].son[1];\n        }\n    }\n}\nvoid reverse(int x, int y)\n{\n    int l = find_val(x - 1), r = find_val(y + 1);\n    splay(l, 0);\n    splay(r, l);\n    int pos = tree[root].son[1];\n    pos = tree[pos].son[0];\n    tree[pos].tag ^= 1;\n}\nvoid show(int now)\n{\n    push_down(now); //* dfs\n    if (tree[now].son[0])\n        show(tree[now].son[0]);\n    if (tree[now].val != -inf && tree[now].val != inf)\n        cout << tree[now].val << ' ';\n    if (tree[now].son[1])\n        show(tree[now].son[1]);\n}\nsigned main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    std::cout.tie(0);\n    int n, m, x, y;\n    cin >> n >> m;\n    ori[1] = -inf, ori[n + 2] = inf;\n    for (int i = 1; i <= n; ++i)\n        ori[i + 1] = i;\n    root = build(1, n + 2, 0);\n    for (int i = 1; i <= m; i++)\n    {\n        cin >> x >> y;\n        reverse(x + 1, y + 1);\n    }\n    show(root);\n    return 0;\n}\n```\n\n由于是序列操作，不需要逐个插入元素，类似线段树的建树过程即可。\n\n","tags":["数据结构"]},{"title":"Splay（伸展树）","url":"/2020/08/21/Splay/","content":"\n# 简介：\n\n本来这是一个月前写的文章，但是系统出毛病了没保存上，只好重新写一下了，也算是加深印象吧。网上关于splay和treap的博客非常多，但是代码实现一些人用的是指针，一些人的node不保存父亲结点，还有一些代码风格非常鬼畜，所以还是需要存一份适合自己的模板和教程。\n\n“平衡二叉树还有很多其他的变种……或许其中最有趣的要数 Sleator 和 Tarjan 提出的‘伸展树’，它可以‘自我调整’。伸展树不需要明确的平衡条件（如颜色）来维持平衡。替代的是，每次存取时‘伸展操作’（涉及旋转）在树内执行。在一棵有 n 个结点的树上，每个操作的摊还代价是 $O(\\lg n)$。”——《算法导论》\n\n<!--more-->\n\n# 基本性质：\n\n与AVL树类似，splay维持平衡也需要多种旋转的组合。这里将左旋操作称为Zag，右旋操作称为Zig。\n\n正如上文所说，splay没有明确的平衡条件，取而代之的是其特有的splay（伸展）操作：每次访问splay的时候都进行一次该操作，使得目标结点旋转到根节点。在多次伸展下，树的形态会自然趋向于平衡，所以很多人说“有事没事splay一下”就是这个道理。\n\n# 具体实现：\n\n## 1、准备工作\n\n### 存储结构\n\n```c++\nstruct node\n{\n    int v;//值\n    int fa;//父亲\n    int ch[2];//左右儿子\n    int size;//结点大小\n    int sum;//子树大小\n} tree[N];\n```\n\n非常普通，没什么好说的。\n\n## 2、重要功能\n\n### update\n\n更新结点大小\n\n```c++\ninline void update(int x)\n{\n    tree[x].sum = tree[tree[x].ch[0]].sum + tree[tree[x].ch[1]].sum + tree[x].size;\n}\n```\n\n### 确定自己的位置\n\n```c++\ninline bool findd(int x)\n{\n    return tree[tree[x].fa].ch[0] == x ? 0 : 1;\n}\n```\n\n是左儿子返回0，右儿子返回1。\n\n### connect\n\n```c++\ninline void connect(int x, int fa, int son)\n{\n    tree[x].fa = fa;\n    tree[fa].ch[son] = x;\n}\n```\n\n重新确立父子关系\n\n### rotate\n\n搬一下写Treap的文章里的图\n\n![200719rotate.png](https://i.loli.net/2020/07/19/KX6iGy8ZTHAD4pY.png)\n\n由于splay是要把结点旋转上去，所以只要知道自己的位置就自动确定了是左旋还是右旋，那么只需要一个函数就可以完成了：\n\n```c++\ninline void rotate(int x)\n{\n    int Y = tree[x].fa;\n    int R = tree[Y].fa;\n    int Yson = findd(x);\n    int Rson = findd(Y);\n    int B = tree[x].ch[Yson ^ 1];\n    connect(B, Y, Yson);\n    connect(Y, x, Yson ^ 1);\n    connect(x, R, Rson);\n    update(Y), update(x);\n}\n```\n\n### splay\n\n最重要的操作，将这个结点旋转到根部：\n\n1. 如果父亲是根，直接旋转一次\n2. 如果自己和父亲、祖父在同一条直线上，先把父亲转上去（自己也会上去），再把自己转上去，如图：\n\n![200721zigzig.png](https://i.loli.net/2020/08/04/swcuRnGSrO8I4yE.png)\n\n![200721zagzag.png](https://i.loli.net/2020/08/04/ztgJxXUDCcsQB3S.png)\n\n3. 如果自己和父亲、祖父不在同一条直线上，把自己转上去两次，如图：\n\n![200721zagzig.png](https://i.loli.net/2020/08/04/czBh2THp7KQIlAk.png)\n\n![200721zigzag.png](https://i.loli.net/2020/08/04/jDClxS6BTztiXLu.png)\n\n显然splay操作只会使树变得更平衡。\n\n```c++\ninline void splay(int x, int to)\n{\n    to = tree[to].fa;\n    while (tree[x].fa != to)\n    {\n        int y = tree[x].fa;\n        if (tree[y].fa == to)\n            rotate(x);\n        else if (findd(x) == findd(y))\n            rotate(y), rotate(x);\n        else\n            rotate(x), rotate(x);\n    }\n}\n```\n\n### 插入\n\n利用BST的性质找到插入位置，然后splay上去。\n\n```c++\ninline int newpoint(int v, int fa)\n{\n    tree[++tot].fa = fa;\n    tree[tot].v = v;\n    tree[tot].sum = tree[tot].size = 1;\n    return tot;\n}\ninline void ins(int x)\n{\n    int cur = tree[0].ch[1];\n    if (tree[0].ch[1] == 0)\n    {\n        newpoint(x, 0);\n        tree[0].ch[1] = tot;\n    }\n    else\n    {\n        while (1)\n        {\n            ++tree[cur].sum;\n            if (tree[cur].v == x)\n            {\n                ++tree[cur].size;\n                splay(cur, tree[0].ch[1]);\n                return;\n            }\n            int nxt = x < tree[cur].v ? 0 : 1;\n            if (!tree[cur].ch[nxt])\n            {\n                int p = newpoint(x, cur);\n                tree[cur].ch[nxt] = p;\n                splay(p, tree[0].ch[1]);\n                return;\n            }\n            cur = tree[cur].ch[nxt];\n        }\n    }\n}\n```\n\n\n\n### 删除\n\n先找到这个值，这个时候已经splay到根了，删除就比较方便。\n\n```c++\ninline int find(int v)\n{\n    int cur = tree[0].ch[1];\n    while (1)\n    {\n        if (tree[cur].v == v)\n        {\n            splay(cur, tree[0].ch[1]);\n            return cur;\n        }\n        int nxt = v < tree[cur].v ? 0 : 1;\n        if (!tree[cur].ch[nxt])\n            return 0;\n        cur = tree[cur].ch[nxt];\n    }\n}\ninline void del(int x)\n{\n    int pos = find(x);\n    if (!pos)\n        return;\n    if (tree[pos].size > 1)\n    {\n        --tree[pos].size;\n        --tree[pos].sum;\n    }\n    else\n    {\n        if (!tree[pos].ch[0] && !tree[pos].ch[1])\n            tree[0].ch[1] = 0;\n        else if (!tree[pos].ch[0])\n        {\n            tree[0].ch[1] = tree[pos].ch[1];\n            tree[tree[0].ch[1]].fa = 0;\n        }\n        else\n        {\n            int left = tree[pos].ch[0];\n            while (tree[left].ch[1])\n                left = tree[left].ch[1];\n            splay(left, tree[pos].ch[0]);\n            connect(tree[pos].ch[1], left, 1);\n            connect(left, 0, 1);\n            update(left);\n        }\n    }\n}\n```\n\n\n\n### 根据值查询排名\n\n与删除类似，由于会splay到最上面，计算左子树大小就好了。\n\n```c++\ninline int get_rank(int v)\n{\n    int pos = find(v);\n    return tree[tree[pos].ch[0]].sum + 1;\n}\n```\n\n\n\n### 根据排名查找值\n\n与AVL树类似\n\n```c++\ninline int get_val(int x)\n{\n    int cur = tree[0].ch[1];\n    while (1)\n    {\n        int used = tree[cur].sum - tree[tree[cur].ch[1]].sum;\n        if (x > tree[tree[cur].ch[0]].sum && x <= used)\n        {\n            splay(cur, tree[0].ch[1]);\n            return tree[cur].v;\n        }\n        if (x < used)\n            cur = tree[cur].ch[0];\n        else\n            x -= used, cur = tree[cur].ch[1];\n    }\n}\n```\n\n\n\n### 查询前驱/后继\n\n唯二不需要伸展的操作。由于是数组中建的树，实现难度远远低于AVL树。\n\n```c++\ninline int prev(int v)\n{\n    int cur = tree[0].ch[1];\n    int ans = -inf;\n    while (cur)\n    {\n        if (tree[cur].v < v && tree[cur].v > ans)\n            ans = tree[cur].v;\n        if (v > tree[cur].v)\n            cur = tree[cur].ch[1];\n        else\n            cur = tree[cur].ch[0];\n    }\n    return ans;\n}\ninline int succ(int v)\n{\n    int cur = tree[0].ch[1];\n    int ans = inf;\n    while (cur)\n    {\n        if (tree[cur].v > v && tree[cur].v < ans)\n            ans = tree[cur].v;\n        if (v < tree[cur].v)\n            cur = tree[cur].ch[0];\n        else\n            cur = tree[cur].ch[1];\n    }\n    return ans;\n}\n```\n\n\n\n## 3、完整代码（以[P3369](https://www.luogu.com.cn/problem/P3369)为例）\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\n\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 1e5 + 9;\ntemplate <typename T>\ninline void write(T x)\n{\n    if (x == 0)\n        putchar('0');\n    if (x < 0)\n        x = -x, putchar('-');\n    static int sta[36];\n    int tot = 0;\n    while (x > 0)\n        sta[tot++] = x % 10, x /= 10;\n    while (tot)\n        putchar(sta[--tot] + 48);\n}\nstruct node\n{\n    int v;\n    int fa;\n    int ch[2];\n    int size;\n    int sum;\n} tree[maxn];\nint tot;\ninline void update(int x)\n{\n    tree[x].sum = tree[tree[x].ch[0]].sum + tree[tree[x].ch[1]].sum + tree[x].size;\n}\ninline bool findd(int x)\n{\n    return tree[tree[x].fa].ch[0] == x ? 0 : 1;\n}\ninline void connect(int x, int fa, int son)\n{\n    tree[x].fa = fa;\n    tree[fa].ch[son] = x;\n}\ninline void rotate(int x)\n{\n    int Y = tree[x].fa;\n    int R = tree[Y].fa;\n    int Yson = findd(x);\n    int Rson = findd(Y);\n    int B = tree[x].ch[Yson ^ 1];\n    connect(B, Y, Yson);\n    connect(Y, x, Yson ^ 1);\n    connect(x, R, Rson);\n    update(Y), update(x);\n}\ninline void splay(int x, int to)\n{\n    to = tree[to].fa;\n    while (tree[x].fa != to)\n    {\n        int y = tree[x].fa;\n        if (tree[y].fa == to)\n            rotate(x);\n        else if (findd(x) == findd(y))\n            rotate(y), rotate(x);\n        else\n            rotate(x), rotate(x);\n    }\n}\ninline int newpoint(int v, int fa)\n{\n    tree[++tot].fa = fa;\n    tree[tot].v = v;\n    tree[tot].sum = tree[tot].size = 1;\n    return tot;\n}\ninline void ins(int x)\n{\n    int cur = tree[0].ch[1];\n    if (tree[0].ch[1] == 0)\n    {\n        newpoint(x, 0);\n        tree[0].ch[1] = tot;\n    }\n    else\n    {\n        while (1)\n        {\n            ++tree[cur].sum;\n            if (tree[cur].v == x)\n            {\n                ++tree[cur].size;\n                splay(cur, tree[0].ch[1]);\n                return;\n            }\n            int nxt = x < tree[cur].v ? 0 : 1;\n            if (!tree[cur].ch[nxt])\n            {\n                int p = newpoint(x, cur);\n                tree[cur].ch[nxt] = p;\n                splay(p, tree[0].ch[1]);\n                return;\n            }\n            cur = tree[cur].ch[nxt];\n        }\n    }\n}\ninline int find(int v)\n{\n    int cur = tree[0].ch[1];\n    while (1)\n    {\n        if (tree[cur].v == v)\n        {\n            splay(cur, tree[0].ch[1]);\n            return cur;\n        }\n        int nxt = v < tree[cur].v ? 0 : 1;\n        if (!tree[cur].ch[nxt])\n            return 0;\n        cur = tree[cur].ch[nxt];\n    }\n}\ninline void del(int x)\n{\n    int pos = find(x);\n    if (!pos)\n        return;\n    if (tree[pos].size > 1)\n    {\n        --tree[pos].size;\n        --tree[pos].sum;\n    }\n    else\n    {\n        if (!tree[pos].ch[0] && !tree[pos].ch[1])\n            tree[0].ch[1] = 0;\n        else if (!tree[pos].ch[0])\n        {\n            tree[0].ch[1] = tree[pos].ch[1];\n            tree[tree[0].ch[1]].fa = 0;\n        }\n        else\n        {\n            int left = tree[pos].ch[0];\n            while (tree[left].ch[1])\n                left = tree[left].ch[1];\n            splay(left, tree[pos].ch[0]);\n            connect(tree[pos].ch[1], left, 1);\n            connect(left, 0, 1);\n            update(left);\n        }\n    }\n}\ninline int get_rank(int v)\n{\n    int pos = find(v);\n    return tree[tree[pos].ch[0]].sum + 1;\n}\ninline int get_val(int x)\n{\n    int cur = tree[0].ch[1];\n    while (1)\n    {\n        int used = tree[cur].sum - tree[tree[cur].ch[1]].sum;\n        if (x > tree[tree[cur].ch[0]].sum && x <= used)\n        {\n            splay(cur, tree[0].ch[1]);\n            return tree[cur].v;\n        }\n        if (x < used)\n            cur = tree[cur].ch[0];\n        else\n            x -= used, cur = tree[cur].ch[1];\n    }\n}\ninline int prev(int v)\n{\n    int cur = tree[0].ch[1];\n    int ans = -inf;\n    while (cur)\n    {\n        if (tree[cur].v < v && tree[cur].v > ans)\n            ans = tree[cur].v;\n        if (v > tree[cur].v)\n            cur = tree[cur].ch[1];\n        else\n            cur = tree[cur].ch[0];\n    }\n    return ans;\n}\ninline int succ(int v)\n{\n    int cur = tree[0].ch[1];\n    int ans = inf;\n    while (cur)\n    {\n        if (tree[cur].v > v && tree[cur].v < ans)\n            ans = tree[cur].v;\n        if (v < tree[cur].v)\n            cur = tree[cur].ch[0];\n        else\n            cur = tree[cur].ch[1];\n    }\n    return ans;\n}\nint main()\n{\n    int n;\n    read(n);\n    while (n--)\n    {\n        int op, x;\n        read(op), read(x);\n        if (op == 1)\n            ins(x);\n        else if (op == 2)\n            del(x);\n        else if (op == 3)\n        {\n            write(get_rank(x));\n            putchar('\\n');\n        }\n        else if (op == 4)\n        {\n            write(get_val(x));\n            putchar('\\n');\n        }\n        else if (op == 5)\n        {\n            write(prev(x));\n            putchar('\\n');\n        }\n        else\n        {\n            write(succ(x));\n            putchar('\\n');\n        }\n    }\n    return 0;\n}\n\n```\n\n平衡树最基本的操作就都实现了。splay的复杂度是均摊 $O(\\log n)$ 的，不太适合可持久化。\n\n\n\n# 后记\n\n以后还需要写一下splay处理序列问题。\n\n\n\n![83758942](https://i.loli.net/2020/08/20/fEji9Aco5JlFSeL.jpg)\n\n\n\nFGO    アナスタシア・ニコラエヴナ・ロマノヴァ","tags":["数据结构"]},{"title":"经验总结（更新中）","url":"/2020/08/19/Tips/","content":"\n\n在这里总结一些踩过的坑以及一些小技巧。\n\n\n\n<!--more-->\n\n-  容易犯错的地方（fst原因大全）\n   1. 数组大小有时候会是 $2\\times 10^5$ 甚至是 $5\\times 10^5$，不要想当然直接开 `maxn=1e5+9`，运气好的话在pretest中RE了还能查出来，要是运气不好过了pretest那就等着fst吧\n   2. 初始化的时候尽量写 `maxx=-inf,minn=inf` 这样的极端数据，无脑初始化为 `0` 是一个坏习惯\n   3. 不开 `long long` 见祖宗，被坑了无数次了\n   4. `double` 的精度并没有想象的那么高，用的时候要小心\n-  小优化\n   \n   1.  读01矩阵这样的东西用 `scanf(\"%c\",&x)` 比用 `scanf(\"%1d\",&x)` 稍微快一点\n-  一些经验\n   1.  指针和宏定义稍有不慎就会出奇怪的毛病且非常难以调试，用不好就不要用\n   2.  不要吃饱了撑着写一堆 `register` 变量或者位运算，有时候编译器自己会优化的，多用 `register` 并不一定使程序变快，甚至可能会负优化；多用位运算也不一定会变快，出错的概率倒是大大增加\n   3.  想不出做法的时候试试暴力，有奇效\n   4.  不只是序列可以分块做，图也是可以分块的\n   5.  单调栈非常有用（被这东西坑了两次了）\n- 容易忘记的小知识点\n\n   1. 斐波那契数列通项公式 $\\large f_n=\\dfrac{(\\frac{1+\\sqrt 5}{2})^n-(\\frac{1-\\sqrt 5}{2})^n}{\\sqrt 5}$\n\n   2. 在只含加法和乘法的式子中，如果最后的运算结果需要对p取模，那么可以在运算过程中随便取模\n   \n      \n\n\n\n","tags":["其它"]},{"title":"非递归式线段树","url":"/2020/08/19/zkw_Segment_Tree/","content":"\n\n\n递归式线段树非常好用，但是常数大，极端情况下可能会被卡掉。非递归式线段树更像是树状数组，常数小，代码也短，当然功能也稍微弱了一点。最近看了几遍zkw的PPT，了解了一下非递归式线段树，感觉对线段树的理解又深了一点。\n\n<!--more-->\n\n先来观察一下这个图：\n\n![完全二叉树](https://i.loli.net/2020/08/19/r8dn2KQy9zm1Ytx.png)\n\n上面是一棵完全二叉树，结点序号用红色标出，黑色的是序号的二进制表示。我们可以发现一个规律：父亲结点的二进制表示是两个儿子的二进制表示的前缀。普通的递归式线段树写法也正是利用了这个性质，所以有 `tree[p]=tree[p<<1]+tree[p<<1|1]` 的写法。\n\n所以有人认为线段树和Trie是一个东西，其实也是有道理的。只不过平时常用的Trie不是二叉树，而是26叉树罢了。\n\n那么递归写法的 `build` 和 `update` 函数都是递归到底部后 `push_up`，如果不采用递归我们就需要更充分利用上面说的前缀性质：直接将数据按顺序存在叶子里面，然后不断除2往上跳就好了。\n\n如果这样的就必须要是一棵完全二叉树，所以空间要足够大，直接和普通的一样四倍就没问题了。\n\n具体实现以后再写。\n\n用的是标记永久化。\n\n目前看来zkw线段树可以像递归式线段树一样做到：\n\n- 单点修改\n- 区间修改（加上一个数）\n- 单点查询\n- 区间查询（和、最值等）\n\n但是似乎不能做到：\n\n- 维护两种运算，如 [这道题](https://www.luogu.com.cn/problem/P3373)\n\n搬个模板：\n\n```c++\n#include <iostream>\n#include<cstdio>\n#define ll long long\nusing namespace std;\nint n,m;\nll a[400005],mark[400005];\nll bit,lb;\ninline int getlong(int k)//查询结点第几层\n{\n    int i=0;\n    while(k>>=1)i++;\n    return i;\n}\ninline int put(int k,int t)//修改\n{\n    int tmp=1<<(lb-getlong(k));\n    while(k>>=1)\n        a[k]+=t*tmp;\n    return 0;\n}\ninline ll get1(ll k)//查询\n{\n    ll tmp=1<<(lb-getlong(k));//tmp有多少叶节点就加几倍\n    ll re=a[k]+mark[k]*tmp;\n    do\n    {\n        k>>=1;\n        re+=mark[k]*tmp;\n    }while(k);\n    return re;\n}\ninline ll get(ll s,ll t)//区间查询\n{\n    ll re=0;\n    for(s=s+bit-1,t=t+bit+1;s^t^1;s>>=1,t>>=1)//s-1和t+1变开区间，s+bit和t+bit到对应叶节点\n    {\n        if(!(s&1))\n            re+=get1(s^1);//*(1<<(lb-getlong(s)));\n        if(t&1)\n            re+=get1(t^1);//*(1<<(lb-getlong(t)));\n    }\n    return re;\n}\ninline int change(ll s,ll t,ll k)//区间修改\n{\n    for(s=s+bit-1,t=t+bit+1;s^t^1;s>>=1,t>>=1)\n    {\n        //int tmp;\n        if(!(s&1))\n        {\n            mark[s^1]+=k;//*(1<<(lb-getlong(s)));\n            put(s^1,k);\n        }\n        if(t&1)\n        {\n            mark[t^1]+=k;//*(1<<(lb-getlong(t)));\n            put(t^1,k);\n        }\n    }\n    return 0;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin>>n>>m;\n    for(bit=1;bit-2<n;bit<<=1);\n    lb=getlong(bit);\n    for(int i=bit+1;i<=bit+n;i++)\n        cin>>a[i];\n    for(int i=bit-1;i;i--)\n    {\n        a[i]=a[i<<1]+a[i<<1|1];//( i*2==i<<1) , (i*2+1==i<<1|1)\n        //a[i<<1]-=a[i];a[i<<1|1]-=a[i];\n    }\n    for(int i=1;i<=m;i++)\n    {\n        ll aa,b,c,d;\n        cin>>aa;\n        if(aa==2)\n        {\n            cin>>b>>c;//cout<<b<<' '<<c<<' '<<get(b,c)<<endl;\n            cout<<get(b,c)<<endl;\n            for(int i=1;i<=n+bit;i++)cout<<get1(i)<<' ';cout<<endl;\n        }\n        else\n        {\n            cin>>b>>c>>d;change(b,c,d);\n            //cout<<b<<' '<<c<<' '<<d<<endl;\n            for(int i=1;i<=n+bit;i++)cout<<get1(i)<<' ';cout<<endl;\n        }\n    }\n\n    return 0;\n}\n```\n\n[PPT链接](https://wenku.baidu.com/view/0c1bbba40029bd64783e2cca.html)\n\n顺便放三篇有趣的文章以后看看：\n\n- [JAVA实现线段树](https://www.luogu.com.cn/blog/AldonahZero/solution-p3372)\n- [试图用珂朵莉树水过线段树](https://www.luogu.com.cn/blog/aaronlee/solution-p3372-1)\n- [指令集优化暴力](https://www.luogu.com.cn/blog/yurzhang/solution-p3372)\n\n![63770148](https://i.loli.net/2020/08/19/YKg7CRX2eQn648a.jpg)\n\n难得看到有人画兰朵露可","tags":["数据结构"]},{"title":"树链剖分","url":"/2020/08/18/path_decomposition/","content":"\n\n\n树链剖分，就是把一棵树分成一些链，然后就可以用数据结构来维护。\n\n\n\n<!--more-->\n\n# 重链剖分\n\n## DFS序\n\n在对一棵树进行DFS的时候每经过一个新的结点就记录它的编号，这样就可以得到一个排列，称为DFS序。\n\n由于是用DFS的方式遍历这棵树，我们可以得到这样的性质：\n\n- 每个点的子树对应DFS序上一段连续的区间\n  - 若进入点 $x$ 的时间是 $DFS_x$，离开点 $x$ 的时间是 $DFS_x+size_x-1$\n\n那么可以用线段树之类的东西来维护这个子树，可以做到 $O(\\log n)$ 复杂度完成：\n\n- 将一个点的子树所有点权加上一个值\n- 查询一个点的子树内点权最小值\n- 查询一个点的子树内的点权和\n\n如果没有DFS序为了完成上面的操作可能需要这样：每个结点维护点权、子树大小、子树点权和、子树点权最小值以及一个lazy-tag。似乎也是可以做的但是比较麻烦。\n\n## 轻重链\n\n如果我们在上面的基础上需要支持以下两个操作：\n\n- 修改单点点权\n- 查询两点路径上最小点权\n\n第二个操作用上面的原始做法是很难完成的，因为区间查询很难做到。\n\n所以需要把树上问题转化成序列问题。先引入**轻链**和**重链**的概念：\n\n对于**非叶结点** $x$，设其**最大的子树**对应的**子结点**为 $y$，则将边 $(x,y)$ 称为重边，其余的边为轻边。\n\n重边形成的链即为重链。\n\n那么可以得到以下几条性质：\n\n- 如果边 $(x,y)$ 是轻边，$size_x\\ge2size_y$ \n  - 显而易见，如果是轻边说明至少有两个子树，并且 $y$ 不是唯一最大的子树\n- 重链的起点是根结点或轻边的终点（轻儿子）\n- 一个点到根的路径上，轻边数量的级别是 $O(\\log n)$ \n- 重链的条数是 $O(\\log n)$ \n- 可以将树上的一条路径划分为 $O(\\log n)$ 条重链\n\n## 实现\n\n首先当然是存图，现在觉得链式前向星还是挺好用的\n\n```c++\nint head[maxn], to[maxn], nxt[maxn], tot = 0;\ninline void add(int u, int v)\n{\n    to[++tot] = v;\n    nxt[tot] = head[u];\n    head[u] = tot;\n}\n```\n\n先进行一次DFS，求出每个结点的子树大小和重儿子\n\n```c++\nint son[maxn], id[maxn], fa[maxn], cnt, dep[maxn], sz[maxn], top[maxn];\nint w[maxn], wt[maxn];\nvoid dfs1(int p, int f, int d)\n{\n    dep[p] = d;\n    fa[p] = f;\n    sz[p] = 1;\n    int maxson = -1;\n    for (int i = head[p]; i; i = nxt[i])\n    {\n        int y = to[i];\n        if (y == f)\n            continue;\n        dfs1(y, p, d + 1);\n        sz[p] += sz[y];\n        if (sz[y] > maxson)//son数组放重儿子\n            son[p] = y, maxson = sz[y];\n    }\n}\n```\n\n再进行一次DFS记录DFS序，到一个点时先访问重儿子再访问其余儿子\n\n```c++\nvoid dfs2(int p, int topf)\n{\n    id[p] = ++cnt;\n    wt[cnt] = w[p];\n    top[p] = topf;\n    if (son[p] == 0)\n        return;\n    dfs2(son[p], topf);\n    for (int i = head[p]; i; i = nxt[i])\n    {\n        int y = to[i];\n        if (y == fa[p] || y == son[p])\n            continue;\n        dfs2(y, y);\n    }\n}\n```\n\n\n\n   -  对于一条重链，链上的点在DFS 序中一定相邻\n   -  一条重链对应DFS 序中一段区间\n\n\n\n做好准备工作以后放进线段树。\n\n区间和查询：\n\n```c++\nint query(int l, int r)\n{\n    int ans = 0;\n    while (top[l] != top[r])\n    {\n        if (dep[top[l]] < dep[top[r]])\n            swap(l, r);\n        ans += tree.query(1, 1, n, id[top[l]], id[l]);\n        ans %= mod;\n        l = fa[top[l]];\n    }\n    if (dep[l] > dep[r])\n        swap(l, r);\n    ans += tree.query(1, 1, n, id[l], id[r]);\n    return ans % mod;\n}\n```\n\n区间修改：\n\n```c++\nvoid update(int l, int r, int k)\n{\n    k %= mod;\n    while (top[l] != top[r])\n    {\n        if (dep[top[l]] < dep[top[r]])\n            swap(l, r);\n        tree.update(1, 1, n, id[top[l]], id[l], k);\n        l = fa[top[l]];\n    }\n    if (dep[l] > dep[r])\n        swap(l, r);\n    tree.update(1, 1, n, id[l], id[r], k);\n}\n```\n\n子树和查询：\n\n```c++\ninline int qson(int p)\n{\n    return tree.query(1, 1, n, id[p], id[p] + sz[p] - 1);\n}\n```\n\n子树修改：\n\n```c++\ninline void upson(int p, int k)\n{\n    tree.update(1, 1, n, id[p], id[p] + sz[p] - 1, k);\n}\n```\n\n树链剖分代码写错极难调试，有时候出一点小错误甚至也能过数据不强的测试点，非常难受。\n\n操作细节部分日后再补，今天就先把这个能用的模板搞出来：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\n\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 2e5 + 9;\n\nint n, m, root, mod;\nint head[maxn], to[maxn], nxt[maxn], tot = 0;\ninline void add(int u, int v)\n{\n    to[++tot] = v;\n    nxt[tot] = head[u];\n    head[u] = tot;\n}\n\nint son[maxn], id[maxn], fa[maxn], cnt, dep[maxn], sz[maxn], top[maxn];\nint w[maxn], wt[maxn];\n\nstruct segtree\n{\n    int tree[maxn << 2], tag[maxn << 2];\n    void push_up(int p)\n    {\n        tree[p] = (tree[p << 1] + tree[p << 1 | 1]) % mod;\n    }\n    void build(int p, int l, int r)\n    {\n        tag[p] = 0;\n        if (l == r)\n        {\n            tree[p] = wt[l] % mod;\n            return;\n        }\n        int mid = (l + r) >> 1;\n        build(p << 1, l, mid);\n        build(p << 1 | 1, mid + 1, r);\n        push_up(p);\n    }\n    void flag(int p, int l, int r, int k)\n    {\n        tag[p] = (tag[p] + k) % mod;\n        tree[p] += k * (r - l + 1);\n        tree[p] %= mod;\n    }\n    void push_down(int p, int l, int r)\n    {\n        int mid = (l + r) >> 1;\n        flag(p << 1, l, mid, tag[p]);\n        flag(p << 1 | 1, mid + 1, r, tag[p]);\n        tag[p] = 0;\n    }\n    void update(int p, int l, int r, int ul, int ur, int k)\n    {\n        if (ul <= l && ur >= r)\n        {\n            tree[p] += k * (r - l + 1);\n            tag[p] += k;\n            tree[p] %= mod;\n            tag[p] %= mod;\n            return;\n        }\n        push_down(p, l, r);\n        int mid = (l + r) >> 1;\n        if (ul <= mid)\n            update(p << 1, l, mid, ul, ur, k);\n        if (ur > mid)\n            update(p << 1 | 1, mid + 1, r, ul, ur, k);\n        push_up(p);\n    }\n    int query(int p, int l, int r, int qx, int qy)\n    {\n        if (qx <= l && qy >= r)\n            return tree[p];\n        int ans = 0, mid = (l + r) >> 1;\n        push_down(p, l, r);\n        if (qx <= mid)\n            ans += query(p << 1, l, mid, qx, qy), ans %= mod;\n        if (qy > mid)\n            ans += query(p << 1 | 1, mid + 1, r, qx, qy), ans %= mod;\n        return ans;\n    }\n};\nsegtree tree;\n\nvoid dfs1(int p, int f, int d)\n{\n    dep[p] = d;\n    fa[p] = f;\n    sz[p] = 1;\n    int maxson = -1;\n    for (int i = head[p]; i; i = nxt[i])\n    {\n        int y = to[i];\n        if (y == f)\n            continue;\n        dfs1(y, p, d + 1);\n        sz[p] += sz[y];\n        if (sz[y] > maxson)\n            son[p] = y, maxson = sz[y];\n    }\n}\n\nvoid dfs2(int p, int topf)\n{\n    id[p] = ++cnt;\n    wt[cnt] = w[p];\n    top[p] = topf;\n    if (son[p] == 0)\n        return;\n    dfs2(son[p], topf);\n    for (int i = head[p]; i; i = nxt[i])\n    {\n        int y = to[i];\n        if (y == fa[p] || y == son[p])\n            continue;\n        dfs2(y, y);\n    }\n}\n\nint query(int l, int r)\n{\n    int ans = 0;\n    while (top[l] != top[r])\n    {\n        if (dep[top[l]] < dep[top[r]])\n            swap(l, r);\n        ans += tree.query(1, 1, n, id[top[l]], id[l]);\n        ans %= mod;\n        l = fa[top[l]];\n    }\n    if (dep[l] > dep[r])\n        swap(l, r);\n    ans += tree.query(1, 1, n, id[l], id[r]);\n    return ans % mod;\n}\n\nvoid update(int l, int r, int k)\n{\n    k %= mod;\n    while (top[l] != top[r])\n    {\n        if (dep[top[l]] < dep[top[r]])\n            swap(l, r);\n        tree.update(1, 1, n, id[top[l]], id[l], k);\n        l = fa[top[l]];\n    }\n    if (dep[l] > dep[r])\n        swap(l, r);\n    tree.update(1, 1, n, id[l], id[r], k);\n}\n\ninline int qson(int p)\n{\n    return tree.query(1, 1, n, id[p], id[p] + sz[p] - 1);\n}\n\ninline void upson(int p, int k)\n{\n    tree.update(1, 1, n, id[p], id[p] + sz[p] - 1, k);\n}\n\nsigned main()\n{\n    read(n), read(m), read(root), read(mod);\n    int op, u, v, k;\n    for (int i = 1; i <= n; ++i)\n        read(w[i]);\n    for (int i = 1; i < n; ++i)\n    {\n        read(u), read(v);\n        add(u, v), add(v, u);\n    }\n    dfs1(root, 0, 1);\n    dfs2(root, root);\n    tree.build(1, 1, n);\n    while (m--)\n    {\n        read(op);\n        if (op == 1)\n        {\n            read(u), read(v), read(k);\n            update(u, v, k);\n        }\n        else if (op == 2)\n        {\n            read(u), read(v);\n            cout << query(u, v) << '\\n';\n        }\n        else if (op == 3)\n        {\n            read(u), read(k);\n            upson(u, k);\n        }\n        else\n        {\n            read(u);\n            cout << qson(u) << '\\n';\n        }\n    }\n    return 0;\n}\n```\n\n其实树链剖分的函数也可以封装进结构体，但是代码耗时增加了将近30%，感觉有点亏。\n\n# 长链剖分\n\n重链剖分选择的是子树大小最大的儿子，长链剖分选择的是子树高度最大的儿子。一些情况下这两种是一样的。长链剖分的复杂度在很多时候并没有重链剖分优秀，因此比较少见，具体内容可以在[HaHaTa的这篇博客](http://hahata.org/193/)中了解。\n\n![83686942](https://i.loli.net/2020/08/19/VCHMpkNei5nmBI4.jpg)\n\n雪花ラミィ\n\n","tags":["图论"]},{"title":"左偏树","url":"/2020/08/16/Leftist_Tree/","content":"\n\n\n普通二叉堆支持 $O(\\log n)$ 插入，$O(\\log n)$ 删除堆顶，$O(1)$ 查询堆顶，但美中不足的是不支持合并。左偏树是一种可并堆，除了满足上面的操作外还可以做到 $O(\\log n)$ 合并。\n\n<!--more-->\n\n## 性质\n\n一棵左偏树满足以下几条性质：（以小根堆为例）\n\n- 是一棵二叉树\n- 每个结点维护两个值，分别是数据大小 $val$ 和到子树中最近叶子结点的距离 $dis$\n  - 所以叶子结点的 $dis$ 必定为 $0$\n- 父亲结点的 $val$ 必然小于其左右儿子的 $val$（堆性质）\n- 左儿子的 $dis$ 不小于右儿子的 $dis$（左偏性质）\n  - 父亲结点的 $dis$ 必定比右儿子的 $dis$ 大 $1$\n  - 如果一个结点没有左儿子，那它一定是叶子结点\n\n根据上面的性质可以得到一个推论：结点数为 $n$ 的左偏树中最大的 $dis$ 不超过 $\\log(n+1)-1$，极端情况是左偏树成为一棵满二叉树。这个推论的逆命题也是成立的，如果最大 $dis$ 为 $k$，那么至少有 $2^{k+1}-1$ 个结点。\n\n## 合并\n\n先看左偏树最核心的 `merge` 操作：（以小根堆为例）\n\n首先，如果有一个待合并的左偏树是空的，那么返回另一个就好了。\n\n然后考虑一般情况，假设两棵左偏树分别是A与B，默认A的根结点键值小于B的（如果不是就swap一下）。那么我们取A的根为新树的根，然后合并A的右子树和B。\n\n合并了A的右子树和B后如果左偏性质被破坏了，那么就swap左右子树，并更新父亲的 $dis$。\n\n一直这样下去，就可以把两棵树合并了，根据上面的推论可以得出最坏情况的复杂度是 $O(\\log n_A +\\log n_B)$，非常优秀。\n\n## 其他操作\n\n太晚了明天再写\n\n## 实现\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\n\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 1e5 + 9;\n\nstruct Tree\n{\n    int dis, val, root, ls, rs;\n};\n\nstruct Leftist_Tree\n{\n    Tree lt[maxn];\n    int merge(int x, int y)\n    {\n        if (!x || !y)\n            return x + y;\n        if (lt[x].val > lt[y].val || (lt[x].val == lt[y].val && x > y))\n            swap(x, y);\n        lt[x].rs = merge(lt[x].rs, y);\n        if (lt[lt[x].ls].dis < lt[lt[x].rs].dis)\n            swap(lt[x].ls, lt[x].rs);\n        lt[lt[x].ls].root = x;\n        lt[lt[x].rs].root = x;\n        lt[x].root = x;\n        lt[x].dis = lt[lt[x].rs].dis + 1;\n        return x; //root\n    }\n    int find(int x)\n    {\n        return lt[x].root == x ? x : lt[x].root = find(lt[x].root);\n    }\n    int top(int x)\n    {\n        return lt[x].val;\n    }\n    void pop(int x)\n    {\n        lt[x].val = -1;\n        lt[lt[x].ls].root = lt[x].ls;\n        lt[lt[x].rs].root = lt[x].rs;\n        lt[x].root = merge(lt[x].ls, lt[x].rs);\n    }\n};\nLeftist_Tree t;\n\nsigned main()\n{\n    int n, m;\n    read(n), read(m);\n    t.lt[0].dis = -1;\n    for (int i = 1; i <= n; ++i)\n    {\n        t.lt[i].root = i;\n        read(t.lt[i].val);\n    }\n    while (m--)\n    {\n        int op, x, y;\n        read(op);\n        if (op == 1)\n        {\n            read(x), read(y);\n            if (t.lt[x].val == -1 || t.lt[y].val == -1)\n                continue;\n            int fx = t.find(x), fy = t.find(y);\n            if (fx != fy)\n            {\n                int p = t.merge(fx, fy);\n                t.lt[fx].root = p;\n                t.lt[fy].root = p;\n            }\n        }\n        else\n        {\n            read(x);\n            if (t.lt[x].val == -1)\n                puts(\"-1\");\n            else\n            {\n                cout << t.top(t.find(x)) << '\\n';\n                t.pop(t.find(x));\n            }\n        }\n    }\n    return 0;\n}\n```\n\n","tags":["数据结构"]},{"title":"LCA","url":"/2020/08/14/LCA/","content":"\n\n\n在有根树中，最近公共祖先（**L**east **C**ommon **A**ncestors）是两个结点最近的的公共祖先，也是最深的一个。\n\n\n\n<!--more-->\n\n\n\n随便找一棵有根树，在里面随便找两个不同结点A、B，求它们的最近公共祖先C，有以下几种方法：\n\n## 1. 暴力\n\n- 先从A、B中深度大的一个向上走，直到两个深度一样。\n- 如果这时候遇到了另一个，那么直接找到了；如果没有相遇，两个同时往上走，直到遇见为止。\n- 正确性显然，复杂度 $O(nq)$\n\n当然了，这样必然会T。\n\n## 2. 倍增\n\n暴力的问题在于每次往上走的步长都是1，效率低下，所以可以先走一大步，如果过头了就回来缩小步长，否则继续向前走。\n\n复杂度 $O((n+q)\\log n)$，比较优秀，也是很常用的做法。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\n\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 5e5 + 9;\n\nstruct node\n{\n    int to, nxt;\n};\nnode e[maxn << 1];\nint head[maxn], num;\nvoid add(int u, int v)\n{\n    e[++num].to = v;\n    e[num].nxt = head[u];\n    head[u] = num;\n}\nint depth[maxn], fa[maxn][22], lg[maxn];\nvoid dfs(int pos, int f)\n{\n    fa[pos][0] = f;\n    depth[pos] = depth[f] + 1;\n    for (int i = 1; i <= lg[depth[pos]]; ++i)\n        fa[pos][i] = fa[fa[pos][i - 1]][i - 1];\n    for (int i = head[pos]; i; i = e[i].nxt)\n        if (e[i].to != f)\n            dfs(e[i].to, pos);\n}\nint lca(int x, int y)\n{\n    if (depth[x] < depth[y])\n        swap(x, y);\n    while (depth[x] > depth[y])\n    {\n        x = fa[x][lg[depth[x] - depth[y]] - 1];\n    }\n    if (x == y)\n        return x;\n    for (int k = lg[depth[x]] - 1; k >= 0; --k)\n        if (fa[x][k] != fa[y][k])\n            x = fa[x][k], y = fa[y][k];\n    return fa[x][0];\n}\n\nsigned main()\n{\n    int n, m, s;\n    read(n), read(m), read(s);\n    for (int i = 1; i < n; ++i)\n    {\n        int x, y;\n        read(x), read(y);\n        add(x, y), add(y, x);\n    }\n    for (int i = 1; i <= n; ++i)\n        lg[i] = lg[i - 1] + (1 << lg[i - 1] == i);\n    dfs(s, 0);\n    for (int i = 1; i <= m; ++i)\n    {\n        int x, y;\n        read(x), read(y);\n        cout << lca(x, y) << '\\n';\n    }\n    return 0;\n}\n```\n\n## 3. ST表\n\n同样对树进行一次 dfs，求出结点顺序和深度然后用ST表维护区间中深度最小结点的位次。\n\n复杂度 $O(n\\log n+q)$，动态点分治在线求LCA比较有用。\n\n详细内容以后再补。\n\n## 4. 树链剖分\n\n不会树剖，大概是这样做的：\n\n对树进行轻重链剖分，每次沿重链向上跳，直到两个节点的 top 相同，此时 dep 较小的就是LCA。\n\n复杂度 $O(n+q\\log n)$，这种做法的另一个好处在于可以结合别的线性数据结构把树上的信息转化为链上的信息。\n\n详细内容以后再补。\n\n## 5. Tarjan算法\n\n把询问分别挂在两节点上，然后对整棵树做一次 dfs ，用并查集维护每个节点当前深度最小的祖先。\n\n复杂度 $O(n+q)$，唯一一个线性复杂度的，但是似乎很少用。\n\n详细内容以后再补。\n\n![83613096](https://i.loli.net/2020/08/15/QvCZyBsRS8PKoeL.jpg)\n\n没看过Fate，但是这个阿尔托莉雅真可爱\n\n","tags":["图论"]},{"title":"分块","url":"/2020/08/13/block/","content":"\n\n\n分块是一种很暴力的思想，总是可以莫名其妙的乱搞掉一些题目。莫队算法就是建立在分块的基础上，所以还是有必要学一下分块。\n\n\n\n\n<!--more-->\n\n简单的说**分块**就是把整个序列分成若干个连续的块，每个块包含一段比较短的区间。可以用分块做很多事情，比如像线段树一样对区间进行修改查询。\n\n由均值不等式可以得出，一般块的长度分为 $\\sqrt {len}$ 比较合适。\n\n所以如果要用树形的结构表示，大概是这样的：\n\n![分块](https://i.loli.net/2020/08/13/ZMYCoQ8ylg4jrk5.png)\n\n可见无论原来的序列有多长，这个树形结构的高度永远都是3，因此它的复杂度远远不如线段树的 $O(n\\log n)$，而是 $O(n\\sqrt n)$。所幸在大部分情况下这个根号复杂度也是可以接受的。\n\n由于这个思想非常暴力，代码实现也比较容易理解：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\n\nconst int maxn = 1e5 + 9;\n\nint ans[maxn], fa[maxn], a[maxn];\nint st[maxn], ed[maxn], sz[maxn], tag[maxn];\nint n, m, sq;\n\nvoid change(int x, int y)\n{\n    int l = fa[x], r = fa[y];\n    for (int i = x; i <= min(y, ed[l]); ++i)\n    {\n\n    }\n    if (l != r)\n    {\n        for (int i = st[r]; i <= y; ++i)\n        {\n\n        }\n    }\n    for (int i = l + 1; i < r; ++i)\n    {\n\n    }\n}\n\nint query(int x, int y)\n{\n    int res = 0, l = fa[x], r = fa[y];\n    for (int i = x; i <= min(y, ed[l]); ++i)\n    {\n        \n    }\n    if (l != r)\n    {\n        for (int i = st[r]; i <= y; ++i)\n\n    }\n    for (int i = l + 1; i < r; ++i)\n    {\n\n    }\n    return res;\n}\n\nsigned main()\n{\n\n    read(n), read(m);\n    sq = sqrt(n);\n    for (int i = 1; i < +n; ++i)\n        read(s[i]);\n    for (int i = 1; i <= sq; ++i)\n    {\n        st[i] = n / sq * (i - 1) + 1;\n        ed[i] = n / sq * i;\n    }\n    ed[sq] = n;\n    for (int i = 1; i <= sq; ++i)\n        for (int j = st[i]; j <= ed[i]; ++j)\n            fa[j] = i;\n    for (int i = 1; i <= sq; ++i)\n        sz[i] = ed[i] - st[i] + 1;\n    \n\n    return 0;\n}\n```\n\n大概可以搞出这样的一个模板。\n\n但是可能会出现一些很玄学的问题。\n\n比如 [P3870 [TJOI2009]开关](https://www.luogu.com.cn/problem/P3870) 这样写总有两个点过不去，怎么都调不对，不知道为什么，但是稍微改变一下写法就能过了：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 1e5 + 9;\n\nint n, m;\nint sq;\nint q[maxn];\nbool tag[maxn];\nbool k[maxn];\nint sum[maxn];\n\nvoid opt1(int l, int r)\n{\n    for (int i = l; i <= min(r, q[l] * sq); i++)\n    {\n        sum[q[i]] -= (k[i] ^ tag[q[i]]);\n        k[i] ^= 1;\n        sum[q[i]] += (k[i] ^ tag[q[i]]);\n    }\n    if (q[l] != q[r])\n    {\n        for (int i = (q[r] - 1) * sq + 1; i <= r; i++)\n        {\n            sum[q[i]] -= (k[i] ^ tag[q[i]]);\n            k[i] ^= 1;\n            sum[q[i]] += (k[i] ^ tag[q[i]]);\n        }\n    }\n    for (int i = q[l] + 1; i < q[r]; i++)\n    {\n        tag[i] ^= 1;\n        sum[i] = sq - sum[i];\n    }\n}\nint opt2(int l, int r)\n{\n    int s = 0;\n    for (int i = l; i <= min(r, q[l] * sq); i++)\n    {\n        s += (k[i] ^ tag[q[i]]);\n    }\n    if (q[l] != q[r])\n    {\n        for (int i = (q[r] - 1) * sq + 1; i <= r; i++)\n        {\n            s += (k[i] ^ tag[q[i]]);\n        }\n    }\n    for (int i = q[l] + 1; i < q[r]; i++)\n    {\n        s += sum[i];\n    }\n    return s;\n}\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    sq = sqrt(n);\n    for (int i = 1; i <= n; i++)\n    {\n        q[i] = (i - 1) / sq + 1;\n    }\n    while (m--)\n    {\n        int opt, l, r;\n        scanf(\"%d%d%d\", &opt, &l, &r);\n        if (opt == 0)\n        {\n            opt1(l, r);\n        }\n        else\n        {\n            printf(\"%d\\n\", opt2(l, r));\n        }\n    }\n    return 0;\n}\n```\n\n这就非常令人难以理解。\n\n线段树就比这个靠谱得多。我还是更喜欢线段树。\n\n虽然分块这种做法看起来很丑陋，但是有时候还是挺有用的，所以先了解一下。\n\n\n\n\n\n最近比赛的状态依然不好。\n\n![83510923](https://i.loli.net/2020/08/14/rLgvUPjmKEsSThI.jpg)","tags":["数据结构"]},{"title":"模板（更新中）","url":"/2020/08/12/Template/","content":"\n\n\n# 模板\n\n<!--more-->\n\n\n## 字符串\n\n### KMP\n\n```c++\n/*a:模式串 s:待匹配串*/\nchar s[maxn], a[maxn];\nint nxt[maxn], lena, lens;\nvoid getnext(){\n    nxt[0] = -1, nxt[1] = 0;\n    for (int i = 2, k; i <= lena; ++i){\n        k = nxt[i - 1];\n        while (k != -1 && a[k + 1] != a[i])\n            k = nxt[k];\n        nxt[i] = k + 1;\n    }\n}\nvoid kmp(){\n    for (int i = 1, k = 0; i <= lens; ++i){\n        while (k != -1 && s[i] != a[k + 1])\n            k = nxt[k];\n        k++;\n        if (k == lena)//匹配成功\n            k = nxt[k];\n    }\n}\nint main(){\n    scanf(\"%s\", s + 1);\n    scanf(\"%s\", a + 1);\n    a[0] = s[0] = '$';//否则strlen函数失效\n    lena = strlen(a) - 1, lens = strlen(s) - 1;\n    getnext();\n    kmp();\n}\n```\n\n### AC自动机\n\n常数巨大需要修改\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst int INF = 0x3f3f3f3f;\nconst int maxn = 1e6 + 9;\nstruct Trie\n{\n    int next[500010][26], fail[500010], end[500010];\n    int root, L;\n    int newnode()\n    {\n        for (int i = 0; i < 26; i++)\n            next[L][i] = -1;\n        end[L++] = 0;\n        return L - 1;\n    }\n    void init()\n    {\n        L = 0;\n        root = newnode();\n    }\n    void insert(char buf[])\n    {\n        int len = strlen(buf);\n        int now = root;\n        for (int i = 0; i < len; i++)\n        {\n            if (next[now][buf[i] - 'a'] == -1)\n                next[now][buf[i] - 'a'] = newnode();\n            now = next[now][buf[i] - 'a'];\n        }\n        end[now]++;\n    }\n    void build()\n    {\n        queue<int> Q;\n        fail[root] = root;\n        for (int i = 0; i < 26; i++)\n            if (next[root][i] == -1)\n                next[root][i] = root;\n            else\n            {\n                fail[next[root][i]] = root;\n                Q.push(next[root][i]);\n            }\n        while (!Q.empty())\n        {\n            int now = Q.front();\n            Q.pop();\n            for (int i = 0; i < 26; i++)\n                if (next[now][i] == -1)\n                    next[now][i] = next[fail[now]][i];\n                else\n                {\n                    fail[next[now][i]] = next[fail[now]][i];\n                    Q.push(next[now][i]);\n                }\n        }\n    }\n    int query(char buf[])\n    {\n        int len = strlen(buf);\n        int now = root;\n        int res = 0;\n        for (int i = 0; i < len; i++)\n        {\n\n            now = next[now][buf[i] - 'a'];\n            int temp = now;\n            while (temp != root)\n            {\n                res += end[temp];\n                end[temp] = 0;\n                temp = fail[temp];\n            }\n        }\n        return res;\n    }\n    void debug()\n    {\n        for (int i = 0; i < L; i++)\n        {\n            printf(\"id = %3d,fail = %3d,end = %3d,chi = [\", i, fail[i], end[i]);\n            for (int j = 0; j < 26; j++)\n                printf(\"%2d\", next[i][j]);\n            printf(\"]\\n\");\n        }\n    }\n};\nchar buf[maxn];\nTrie ac;\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    ac.init();\n    for (int i = 0; i < n; i++)\n    {\n        scanf(\"%s\", buf);\n        ac.insert(buf);\n    }\n    ac.build();\n    scanf(\"%s\", buf);\n    printf(\"%d\\n\", ac.query(buf));\n    return 0;\n}\n```\n\n### Manacher\n\n待修改\n\n```c++\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nchar str[11000005],str_new[11000005];\nint p[22000020],len;\nvoid init()\n{\n    int t=2;\n    len=strlen(str);\n    str_new[0]='@';\n    str_new[1]='#';\n    for(int i=0; i<len; i++)\n    {\n        str_new[t++]=str[i];\n        str_new[t++]='#';\n    }\n    str_new[t]='$';\n}\nvoid Manacher()\n{\n    memset(p,0,sizeof(p));\n    int mid,ans=0,r=0;\n    for(int i=1;i<len*2+2;i++)\n    {\n        if(i<r)\n            p[i]=p[2*mid-i]<(r-i)?p[2*mid-i]:r-i;\n        else\n            p[i]=1;\n        for(;str_new[i-p[i]]==str_new[i+p[i]];p[i]++);\n        if(i+p[i]>r)\n            mid=i,r=i+p[i];\n        if(p[i]>ans)\n            ans=p[i];\n    }\n    printf(\"%d\\n\",--ans);\n}\nint main()\n{\n    scanf(\"%s\",str);\n    init();\n    Manacher();\n    return 0;\n}\n```\n\n## 图论\n\n### MST-Kruskal\n\n```c++\nstruct edge{\n    int x, y, w;\n    bool operator<(const edge &b) const{\n        return w < b.w;\n    }\n};\nint n, m, fa[maxn], k;\nint find(int x)\n{\n    return fa[x] == x ? x : fa[x] = find(fa[x]);\n}\nvoid join(int x, int y){\n    int tx = find(x), ty = find(y);\n    if (tx != ty)\n        fa[tx] = ty;\n}\nedge e[maxn];\nvoid kruskal(){\n    for (int i = 1; i <= n; ++i)\n        fa[i] = i;\n    sort(e + 1, e + m + 1);\n    for (int i = 1; i <= m; ++i){\n        edge t = e[i];\n        if (find(t.x) == find(t.y))\n            continue;\n        join(t.x, t.y);\n    }\n}\n```\n\n### 树链剖分\n\n```c++\nint n, m, root, mod;\nint head[maxn], to[maxn], nxt[maxn], tot = 0;\ninline void add(int u, int v)\n{\n    to[++tot] = v;\n    nxt[tot] = head[u];\n    head[u] = tot;\n}\n\nint son[maxn], id[maxn], fa[maxn], cnt, dep[maxn], sz[maxn], top[maxn];\nint w[maxn], wt[maxn];\n\nstruct segtree\n{\n    int tree[maxn << 2], tag[maxn << 2];\n    void push_up(int p)\n    {\n        tree[p] = (tree[p << 1] + tree[p << 1 | 1]) % mod;\n    }\n    void build(int p, int l, int r)\n    {\n        tag[p] = 0;\n        if (l == r)\n        {\n            tree[p] = wt[l] % mod;\n            return;\n        }\n        int mid = (l + r) >> 1;\n        build(p << 1, l, mid);\n        build(p << 1 | 1, mid + 1, r);\n        push_up(p);\n    }\n    void flag(int p, int l, int r, int k)\n    {\n        tag[p] = (tag[p] + k) % mod;\n        tree[p] += k * (r - l + 1);\n        tree[p] %= mod;\n    }\n    void push_down(int p, int l, int r)\n    {\n        int mid = (l + r) >> 1;\n        flag(p << 1, l, mid, tag[p]);\n        flag(p << 1 | 1, mid + 1, r, tag[p]);\n        tag[p] = 0;\n    }\n    void update(int p, int l, int r, int ul, int ur, int k)\n    {\n        if (ul <= l && ur >= r)\n        {\n            tree[p] += k * (r - l + 1);\n            tag[p] += k;\n            tree[p] %= mod;\n            tag[p] %= mod;\n            return;\n        }\n        push_down(p, l, r);\n        int mid = (l + r) >> 1;\n        if (ul <= mid)\n            update(p << 1, l, mid, ul, ur, k);\n        if (ur > mid)\n            update(p << 1 | 1, mid + 1, r, ul, ur, k);\n        push_up(p);\n    }\n    int query(int p, int l, int r, int qx, int qy)\n    {\n        if (qx <= l && qy >= r)\n            return tree[p];\n        int ans = 0, mid = (l + r) >> 1;\n        push_down(p, l, r);\n        if (qx <= mid)\n            ans += query(p << 1, l, mid, qx, qy), ans %= mod;\n        if (qy > mid)\n            ans += query(p << 1 | 1, mid + 1, r, qx, qy), ans %= mod;\n        return ans;\n    }\n};\nsegtree tree;\n\nvoid dfs1(int p, int f, int d)\n{\n    dep[p] = d;\n    fa[p] = f;\n    sz[p] = 1;\n    int maxson = -1;\n    for (int i = head[p]; i; i = nxt[i])\n    {\n        int y = to[i];\n        if (y == f)\n            continue;\n        dfs1(y, p, d + 1);\n        sz[p] += sz[y];\n        if (sz[y] > maxson)\n            son[p] = y, maxson = sz[y];\n    }\n}\n\nvoid dfs2(int p, int topf)\n{\n    id[p] = ++cnt;\n    wt[cnt] = w[p];\n    top[p] = topf;\n    if (son[p] == 0)\n        return;\n    dfs2(son[p], topf);\n    for (int i = head[p]; i; i = nxt[i])\n    {\n        int y = to[i];\n        if (y == fa[p] || y == son[p])\n            continue;\n        dfs2(y, y);\n    }\n}\n\nint query(int l, int r)\n{\n    int ans = 0;\n    while (top[l] != top[r])\n    {\n        if (dep[top[l]] < dep[top[r]])\n            swap(l, r);\n        ans += tree.query(1, 1, n, id[top[l]], id[l]);\n        ans %= mod;\n        l = fa[top[l]];\n    }\n    if (dep[l] > dep[r])\n        swap(l, r);\n    ans += tree.query(1, 1, n, id[l], id[r]);\n    return ans % mod;\n}\n\nvoid update(int l, int r, int k)\n{\n    k %= mod;\n    while (top[l] != top[r])\n    {\n        if (dep[top[l]] < dep[top[r]])\n            swap(l, r);\n        tree.update(1, 1, n, id[top[l]], id[l], k);\n        l = fa[top[l]];\n    }\n    if (dep[l] > dep[r])\n        swap(l, r);\n    tree.update(1, 1, n, id[l], id[r], k);\n}\n\ninline int qson(int p)\n{\n    return tree.query(1, 1, n, id[p], id[p] + sz[p] - 1);\n}\n\ninline void upson(int p, int k)\n{\n    tree.update(1, 1, n, id[p], id[p] + sz[p] - 1, k);\n}\n\nsigned main()\n{\n    read(n), read(m), read(root), read(mod);\n    int op, u, v, k;\n    for (int i = 1; i <= n; ++i)\n        read(w[i]);\n    for (int i = 1; i < n; ++i)\n    {\n        read(u), read(v);\n        add(u, v), add(v, u);\n    }\n    dfs1(root, 0, 1);\n    dfs2(root, root);\n    tree.build(1, 1, n);\n    while (m--)\n    {\n        read(op);\n        if (op == 1)\n        {\n            read(u), read(v), read(k);\n            update(u, v, k);\n        }\n        else if (op == 2)\n        {\n            read(u), read(v);\n            cout << query(u, v) << '\\n';\n        }\n        else if (op == 3)\n        {\n            read(u), read(k);\n            upson(u, k);\n        }\n        else\n        {\n            read(u);\n            cout << qson(u) << '\\n';\n        }\n    }\n    return 0;\n}\n```\n\n\n\n## 计算几何\n\n`const double eps = 1e-8;`\n\n### 点\n\n```c++\nint sgn(double x){\n    if (fabs(x) < eps) return 0;\n    if (x < 0) return -1;\n    return 1;\n}\nstruct point{\n    double x, y;\n    point() {}\n    point(double x, double y) : x(x), y(y) {}\n    point operator+(const point &p) const {\n        point new_p(x + p.x, y + p.y);\n        return new_p;\n    }\n    point operator-(const point &p) const {\n        point new_p(x - p.x, y - p.y);\n        return new_p;\n    }\n    point operator|(const double &p) const {\n        point new_p(x * p, y * p);\n        return new_p;\n    }\n    point operator/(const double &p) const {\n        point new_p(x / p, y / p);\n        return new_p;\n    }\n    bool operator==(const point &p) const {\n        return sgn(x - p.x) == 0 && sgn(y - p.y) == 0;\n    }\n    double operator*(const point &p) const {\n        return x * p.x + y * p.y;\n    }\n    double operator^(const point &p) const {\n        return x * p.y - y * p.x;\n    }\n    double len() {\n        return sqrt(x * x + y * y);\n    }\n    void print() {\n        cout << x << ' ' << y << '\\n';\n    }\n};\ndouble dist(const point &a, const point &b){\n    return sqrt((a - b) * (a - b));\n}\ntypedef point vec;\n```\n\n### 二维凸包\n\n#### Graham算法\n\n```c++\nconst int maxn = 1e5 + 10;\npoint pt[maxn];\nint Stack[maxn], top;\nbool _cmp(point p1, point p2){\n    double tmp = (p1 - pt[0]) ^ (p2 - pt[0]);\n    if (sgn(tmp) > 0)\n        return true;\n    else if (sgn(tmp) == 0 && sgn(dist(p1, pt[0]) - dist(p2, pt[0])) <= 0)\n        return true;\n    else\n        return false;\n}\nvoid Graham(int n)\n{\n    point p0;\n    int k = 0;\n    p0 = pt[0];\n    for (int i = 1; i < n; i++){\n        if ((p0.y > pt[i].y) || (p0.y == pt[i].y && p0.x > pt[i].x)){\n            p0 = pt[i];\n            k = i;\n        }\n    }\n    swap(pt[k], pt[0]);\n    sort(pt + 1, pt + n, _cmp);\n    if (n == 1){\n        top = 1;\n        Stack[0] = 0;\n        return;\n    }\n    if (n == 2){\n        top = 2;\n        Stack[0] = 0;\n        Stack[1] = 1;\n        return;\n    }\n    Stack[0] = 0;\n    Stack[1] = 1;\n    top = 2;\n    for (int i = 2; i < n; i++){\n        while (top > 1 && \n               sgn((pt[Stack[top - 1]] - pt[Stack[top - 2]]) ^ (pt[i] - pt[Stack[top - 2]])) <= 0)\n            top--;\n        Stack[top++] = i;\n    }\n}\n```\n\n## 数据结构\n\n### 线段树\n\n```c++\nint a[maxn];\n\nstruct segtree\n{\n    int tree[maxn << 2], tag[maxn << 2];\n    void push_up(int p)\n    {\n        tree[p] = tree[p << 1] + tree[p << 1 | 1];\n    }\n    void build(int p, int l, int r)\n    {\n        tag[p] = 0;\n        if (l == r)\n        {\n            tree[p] = a[l];\n            return;\n        }\n        int mid = (l + r) >> 1;\n        build(p << 1, l, mid);\n        build(p << 1 | 1, mid + 1, r);\n        push_up(p);\n    }\n    void flag(int p, int l, int r, int k)\n    {\n        tag[p] += k;\n        tree[p] += k * (r - l + 1);\n    }\n    void push_down(int p, int l, int r)\n    {\n        int mid = (l + r) >> 1;\n        flag(p << 1, l, mid, tag[p]);\n        flag(p << 1 | 1, mid + 1, r, tag[p]);\n        tag[p] = 0;\n    }\n    void update(int p, int l, int r, int ul, int ur, int k)\n    {\n        if (ul <= l && ur >= r)\n        {\n            tree[p] += k * (r - l + 1);\n            tag[p] += k;\n            return;\n        }\n        push_down(p, l, r);\n        int mid = (l + r) >> 1;\n        if (ul <= mid)\n            update(p << 1, l, mid, ul, ur, k);\n        if (ur > mid)\n            update(p << 1 | 1, mid + 1, r, ul, ur, k);\n        push_up(p);\n    }\n    int query(int p, int l, int r, int qx, int qy)\n    {\n        if (qx <= l && qy >= r)\n            return tree[p];\n        int ans = 0, mid = (l + r) >> 1;\n        push_down(p, l, r);\n        if (qx <= mid)\n            ans += query(p << 1, l, mid, qx, qy);\n        if (qy > mid)\n            ans += query(p << 1 | 1, mid + 1, r, qx, qy);\n        return ans;\n    }\n};\n```\n\n### 划分树\n\n静态区间第 $k$ 小\n\n```c++\nconst int maxn = 2e5 + 9;\n\nint tree[30][maxn];\nint sorted[maxn];\nint toleft[30][maxn];\n\nvoid build(int l, int r, int dep)\n{\n    if (l == r)\n        return;\n    int mid = (l + r) >> 1;\n    int same = mid - l + 1;\n    for (int i = l; i <= r; ++i)\n        if (tree[dep][i] < sorted[mid])\n            same--;\n    int lpos = l, rpos = mid + 1;\n    for (int i = l; i <= r; ++i)\n    {\n        if (tree[dep][i] < sorted[mid])\n            tree[dep + 1][lpos++] = tree[dep][i];\n        else if (tree[dep][i] == sorted[mid] && same > 0)\n        {\n            tree[dep + 1][lpos++] = tree[dep][i];\n            same--;\n        }\n        else\n            tree[dep + 1][rpos++] = tree[dep][i];\n        toleft[dep][i] = toleft[dep][l - 1] + lpos - l;\n    }\n    build(l, mid, dep + 1);\n    build(mid + 1, r, dep + 1);\n}\nint query(int l, int r, int x, int y, int dep, int k)\n{\n    if (x == y)\n        return tree[dep][x];\n    int mid = (l + r) >> 1;\n    int cnt = toleft[dep][y] - toleft[dep][x - 1];\n    if (cnt >= k)\n    {\n        int newx = l + toleft[dep][x - 1] - toleft[dep][l - 1];\n        int newy = newx + cnt - 1;\n        return query(l, mid, newx, newy, dep + 1, k);\n    }\n    else\n    {\n        int newy = y + toleft[dep][r] - toleft[dep][y];\n        int newx = newy - (y - x - cnt);\n        return query(mid + 1, r, newx, newy, dep + 1, k - cnt);\n    }\n}\nsigned main()\n{\n    int n, m;\n    read(n), read(m);\n    //memset(tree, 0, sizeof(tree));\n    for (int i = 1; i <= n; ++i)\n    {\n        read(tree[0][i]);\n        sorted[i] = tree[0][i];\n    }\n    sort(sorted + 1, sorted + n + 1);\n    build(1, n, 0);\n    while (m--)\n    {\n        int l, r, k;\n        read(l), read(r), read(k);\n        cout << query(1, n, l, r, 0, k) << '\\n';\n    }\n    return 0;\n}\n```\n\n### 左偏树\n\n可并堆\n\n```c++\nconst int maxn = 1e5 + 9;\n\nstruct Tree\n{\n    int dis, val, root, ls, rs;\n};\n\nstruct Leftist_Tree\n{\n    Tree lt[maxn];\n    int merge(int x, int y)\n    {\n        if (!x || !y)\n            return x + y;\n        if (lt[x].val > lt[y].val || (lt[x].val == lt[y].val && x > y))\n            swap(x, y);\n        lt[x].rs = merge(lt[x].rs, y);\n        if (lt[lt[x].ls].dis < lt[lt[x].rs].dis)\n            swap(lt[x].ls, lt[x].rs);\n        lt[lt[x].ls].root = x;\n        lt[lt[x].rs].root = x;\n        lt[x].root = x;\n        lt[x].dis = lt[lt[x].rs].dis + 1;\n        return x; //root\n    }\n    int find(int x)\n    {\n        return lt[x].root == x ? x : lt[x].root = find(lt[x].root);\n    }\n    int top(int x)\n    {\n        return lt[x].val;\n    }\n    void pop(int x)\n    {\n        lt[x].val = -1;\n        lt[lt[x].ls].root = lt[x].ls;\n        lt[lt[x].rs].root = lt[x].rs;\n        lt[x].root = merge(lt[x].ls, lt[x].rs);\n    }\n};\nLeftist_Tree t;\n\nsigned main()\n{\n    int n, m;\n    read(n), read(m);\n    t.lt[0].dis = -1;\n    for (int i = 1; i <= n; ++i)\n    {\n        t.lt[i].root = i;\n        read(t.lt[i].val);\n    }\n    while (m--)\n    {\n        int op, x, y;\n        read(op);\n        if (op == 1)\n        {\n            read(x), read(y);\n            if (t.lt[x].val == -1 || t.lt[y].val == -1)\n                continue;\n            int fx = t.find(x), fy = t.find(y);\n            if (fx != fy)\n            {\n                int p = t.merge(fx, fy);\n                t.lt[fx].root = p;\n                t.lt[fy].root = p;\n            }\n        }\n        else\n        {\n            read(x);\n            if (t.lt[x].val == -1)\n                puts(\"-1\");\n            else\n            {\n                cout << t.top(t.find(x)) << '\\n';\n                t.pop(t.find(x));\n            }\n        }\n    }\n    return 0;\n}\n```\n\n\n\n## 优化\n\n### 普通快读\n\n```c++\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\n```\n\n### 究极版\n\n```c++\nchar nc()\n{\n    static char buf[100000], *p1, *p2;\n    return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++;\n}\ninline int read()\n{\n    register int x = 0;\n    register char a = nc();\n    while (a < '0' || a > '9')\n        a = nc();\n    while (a >= '0' && a <= '9')\n        x = x * 10 + a - '0', a = nc();\n    return x;\n}\nchar pbuf[10000000], *pp = pbuf;\ninline void write(int x)\n{\n    static int sta[35];\n    register int top = 0;\n    if (!x)\n        sta[++top] = 0;\n    while (x)\n        sta[++top] = x % 10, x /= 10;\n    while (top)\n        *pp++ = sta[top--] ^ '0';\n}\n```\n\n输入用法：`int n=read()`\n\n输出用法：\n\n```c++\nfor(int i=1;i<=n;++i)\n\twrite(ans[i]), *pp++ = '\\n';//答案后面换行或者空格\nfwrite(pbuf, 1, pp - pbuf, stdout);//最后用这个\n```\n\n","tags":["模板"]},{"title":"CF#663div2总结","url":"/2020/08/10/CF663div2/","content":"\n帽子戏法！\n\n<!--more-->\n\n## A\n\n本来是一眼题，结果因为前一天做了一道求异或和的题，把这里的 `or` 也都看成 `xor` 了，浪费 $5$ 分钟。**首杀**。\n\n## B\n\n也是水题，结果看成只需要满足一条从左上角到右下角的路线，先打了个DFS+剪枝，发现第三个样例输出是3，代码看起来也没什么问题，就又写了个 $O(mn)$ 的DP，发现第三个样例输出还是3。。。然后才发现是题目读错了。浪费 $50$ 分钟。**梅开二度**。\n\n## C\n\n很简单的组合数学题，推到4就已经很清楚了，$S_n=n\\cdot S_{n-1}+(n-2)[(n-1)!-S_{n-1}]$，整理一下可以得到 $S_n=(n-2)(n-1)!+2S_{n-1}$，甚至可以得到通项公式 $S_n=n!-2^{n-1}$。但是把模数看成了数据范围，$O(n)$ 的递推式列出来以后还想了半天怎么优化复杂度，浪费 $5$ 分钟。**帽子戏法**。\n\n## D\n\n前三道题已经浪费了一个小时了，留给D的时间已经不多了，虽然D的性质也很显然，排除 $\\min(m,n)\\ge 4$ 的和 $\\min(m,n)=1$ 的情况以后随便什么状压DP之类的都可以做的，但是最后还是来不及调了，遗憾。\n\n## E\n\n根本来不及看，虽然看了估计也做不出来，好像是树剖之类的题。\n\n\n\n一共两个小时的比赛，理解错题意导致浪费一个小时，那还比个P。最近几场CF会做的题总是不能全过，经常因为各种奇怪的原因做不完或者做错。这也不是要提高算法之类的的能力了，或许要多做做各种题目提升一下审题能力和代码能力，尤其是手速和debug速度。如果能稳定发挥的话上个蓝名应该已经不是问题了。\n\n\n\n状态什么时候能好呢。。。\n\n![83493912](https://i.loli.net/2020/08/10/r3efvqXE7OjP5wL.jpg)\n\n","tags":["CodeForces"]},{"title":"2020暑假训练整合（已完结）","url":"/2020/08/09/2020Summer/","content":"\n7月20日开始暑假训练\n\n<!--more-->\n\n**由于CSDN比较稳定，每天的题解笔记之类放在CSDN上**\n\n- 7月20日 STL、分治、贪心等\n  - [2020暑期训练1](https://blog.csdn.net/Pastafarian/article/details/107474375)\n- 7月21日 基础DP\n  - [2020暑期训练2](https://blog.csdn.net/Pastafarian/article/details/107512800)\n- 7月22日 基础数据结构\n  - [2020暑期训练3](https://blog.csdn.net/Pastafarian/article/details/107543109)\n- 7月23日 数论\n  - [2020暑期训练4](https://blog.csdn.net/Pastafarian/article/details/107593890)\n- 7月26日 DP优化\n  - [2020暑期训练5](https://blog.csdn.net/Pastafarian/article/details/107620694)\n- 7月27日 图论\n  - [2020暑期训练6](https://blog.csdn.net/Pastafarian/article/details/107645822)\n- 7月28日 字符串\n  - [2020暑期训练7](https://blog.csdn.net/Pastafarian/article/details/107694716)\n- 7月29日 计算几何基础\n  -   [2020暑期训练8](https://blog.csdn.net/Pastafarian/article/details/107764056)\n- 7月31日 组合数学\n  - [2020暑期训练9](https://blog.csdn.net/Pastafarian/article/details/107788906)\n- 8月2日 概率\n  - [2020暑期训练10](https://blog.csdn.net/Pastafarian/article/details/107885231)\n\n[以及慢慢更新的模板整理](https://phlzy.github.io/2020/08/12/Template/)\n\n![200723.jpg](https://i.loli.net/2020/07/23/Cx7nHkT4QsElFOj.jpg)\n\n","tags":["其它"]},{"title":"洛谷8月月赛Idiv2","url":"/2020/08/08/LGR-074div2/","content":"\n和上次一样先口胡一些思路，等题解出了以后再做完善。\n\n<!--more-->\n\n## A&B\n\nA没啥好说的，直接上代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint num[600];\nsigned main()\n{\n    int k;\n    ll x;\n    cin >> k >> x;\n    num[k + 1] = 1;\n    int cnt = 0;\n    while (x)\n    {\n        num[++cnt] += x % 10;\n        x /= 10;\n        if (num[cnt] > 9)\n        {\n            num[cnt + 1] += num[cnt] / 10;\n            num[cnt] %= 10;\n        }\n    }\n    if (num[cnt + 1] > 0)\n        cnt++;\n    for (int i = max(k + 1, cnt); i > 0; --i)\n        cout << num[i];\n    return 0;\n}\n```\n\nB找一下规律：\n\n- 全 `0` 的时候直接结束；\n- 其中一个为 `0` 的时候用 `0` 去乘大数，另一个数字除完向下取整；\n- 两个相等的时候：\n  - 一起减一下就好了\n  - 或者先把一个除成 `0`，再处理另一个\n- 其他情况：\n  - 乘除一次把两个变成一样的\n  - 或者像上面一样先把一个除成 `0`，再处理另一个\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nsigned main()\n{\n    ll a, b, c, d;\n    cin >> a >> b >> c >> d;\n    if (a * b == 0)\n    {\n        if (a == b)\n            cout << 0;\n        else\n            cout << d;\n        return 0;\n    }\n    if (a == b)\n        cout << min(c, d + d);\n    else\n        cout << min(c + d, d + d);\n    return 0;\n}\n```\n\n这次的AB非常简单。\n\n## C\n\n很明显是按位处理，但是被我写挂了：\n\n- $m$ 的最大范围达到了 $2^{30}\\times 10^6$，很明显用 `long long`，结果脑子一抽写了 `__int128_t`，又顺便写了个输出函数，将问题大大复杂化；\n- 解法是统计每一位的 `1` 的个数，顺便算出最小需要的 $m$ 大小，如果大于询问的 $m$ 直接输出 `-1`，否则从高位到低位进行dfs，搜到的第一个答案就是最大的 $k$；\n- 然后我好像又双叒叕死在搜索上了。\n\n附上怎么都调不对的代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\nint tmp[100];\ntemplate <typename T>\ninline void write(T x)\n{\n    int cnt = 0;\n    if (x < 0)\n    {\n        x = -x;\n        putchar('-');\n    }\n    do\n    {\n        tmp[++cnt] = x % 10;\n    } while (x /= 10);\n    while (cnt)\n        putchar('0' + tmp[cnt--]);\n    putchar('\\n');\n}\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 1e5 + 9;\nint tot[35], tot1[35];\n__int128_t ret, m, num[35][2], mintot;\nbool vis[35];\nvoid dfs(int d, __int128_t sum)\n{\n    if (d < 0)\n    {\n        for (int i = 0; i <= 30; ++i)\n            if (vis[i])\n                ret += ((__int128_t)1 << i);\n        return;\n    }\n    if (sum > m || ret != 0)\n    {\n        //write(ret);\n        return;\n    }\n    //write(sum);\n    vis[d] = true;\n    dfs(d - 1, sum + num[d - 1][1]);\n    vis[d] = false;\n    dfs(d - 1, sum + num[d - 1][0]);\n    return;\n}\nsigned main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"data.txt\",\"w\",stdout);\n    //std::ios::sync_with_stdio(false);\n    //std::cin.tie(0);\n    //std::cout.tie(0);\n    ull n, q, a;\n    read(n);\n    for (int i = 1; i <= n; ++i)\n    {\n        read(a);\n        for (int j = 0; j <= 30; ++j)\n            if (a >> j & 1)\n                tot[j]++;\n    }\n    mintot = 0;\n    for (int j = 0; j <= 30; ++j)\n    {\n        num[j][1] = (__int128_t)(1 << j) * (__int128_t)(n - tot[j]);\n        num[j][0] = (__int128_t)(1 << j) * (__int128_t)tot[j];\n        mintot += min((__int128_t)(1 << j) * (__int128_t)tot[j], (__int128_t)(1 << j) * (__int128_t)(n - tot[j]));\n    }\n    //write(mintot);\n    read(q);\n    while (q--)\n    {\n        read(m);\n        if (m < mintot)\n        {\n            puts(\"-1\");\n            continue;\n        }\n        for (int i = 0; i <= 30; ++i)\n            vis[i] = false;\n        ret = 0;\n        dfs(31, 0);\n        ret = ((m >> 31) << 31) + ret;\n        write(ret);\n    }\n    //fclose(stdin);\n    //fclose(stdout);\n    return 0;\n}\n```\n\n\n\n## D\n\n第一眼看到的想法：既然是树，就可以从叶子结点开始一层一层处理，先把所有连接叶子结点的边权求出来，然后把叶子结点全部摘掉并重复上一步过程。\n\n当然这样做肯定是不对的：\n\n![200808.png](https://i.loli.net/2020/08/08/Y6kJL4IsQofepHz.png)\n\n比方说这个图按照这个做法就是不可行的。\n\n所以应该还是要根据父亲结点的值做一些调整。\n\n具体解法等官方题解出来再说，这题我也没写代码。\n\n要多练练搜索了，DP和简单的图论也要做一做。\n\n![83492606.jpg](https://i.loli.net/2020/08/08/hWmVtilwrdPRgox.jpg)","tags":["洛谷"]},{"title":"CF1399D题解","url":"/2020/08/07/CF1399D-Solution/","content":"\n构造，模拟？[链接](https://codeforces.com/problemset/problem/1399/D) [或者在洛谷看](https://www.luogu.com.cn/problem/CF1399D)\n\n<!--more-->\n\n比赛的时候做出来了，后来看了很多题解发现我的理解似乎比较独特，就记录一下（做法本质上是一样的）。\n\n我们可以让一个点根据原序列的内容进行移动，将这个问题转化为下面的形式：\n\n假设在平面直角坐标系中有一个点坐标为 $(x,y)$，当走到序列的下一个元素时，如果是 `0` 该点就移动到 $(x+1,y-1)$ 处，如果是 `1` 该点就移动到 $(x+1,y+1)$ 处。为了便于模拟，我们让这个点的初始状态位于原点。\n\n显然，这个点的运动轨迹是一条折线，而且终点在 $(n,num_1-num_0)$。$k$ 的最小值就是折线最高点和最低点之间的距离。这 $k$ 个子序列也可以用它们的纵坐标来表示，画个图稍作推导即可得出。\n\n代码如下：\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 9;\nint ans[maxn];\nunordered_map<int, int> mp;\nint main()\n{\n    int T;\n    scanf(\"%d\", &T);\n    while (T--)\n    {\n        int n, x;\n        scanf(\"%d\", &n);\n        mp.clear();\n        int h = 0, maxx = 0, minn = 0, cnt = 0;\n        for (int i = 1; i <= n; ++i)\n        {\n            scanf(\"%1d\", &x);\n            if (x == 1)\n                h++;\n            else\n                h--;\n            if (h > 0)\n            {\n                if (h > maxx)\n                    mp[h] = ++cnt, maxx = h;//更新最高点高度\n                ans[i] = h;\n                if (x == 0)\n                    ans[i]++;\n            }\n            else if (h < 0)\n            {\n                if (h < minn)\n                    mp[h] = ++cnt, minn = h;//更新最低点高度\n                ans[i] = h;\n                if (x == 1)\n                    ans[i]--;\n            }\n            else\n            {\n                if (x == 1)\n                    ans[i] = -1;\n                else\n                    ans[i] = 1;\n            }\n        }\n        printf(\"%d\\n\", cnt);\n        for (int i = 1; i <= n; ++i)\n            printf(\"%d \", mp[ans[i]]);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n```\n","tags":["CodeForces"]},{"title":"【胡思乱想】如果给Trie增加索引","url":"/2020/08/04/nonsense-index-trie/","content":"\n[P1019单词接龙](https://www.luogu.com.cn/problem/P1019)是一个DFS的题，但是前几天看了AC自动机的东西总觉得可以结合Trie来搞一搞，所以就把这个奇怪的想法写下来了。\n\n**注意：本文只是随手记下突然产生的一个想法，因此内容质量可能非常低！**\n\n<!--more-->\n\n比方说有以下这7个单词，然后从字母a开始接龙：\n\n1. egg\n2. ksi\n3. simple\n4. apple\n5. kk\n6. eioua\n7. abba\n\n我们可以先构建一棵Trie，把单词按顺序插进去，就像这样：\n\n![200804101901.jpg](https://i.loli.net/2020/08/04/mcplDiXs72HjKwJ.jpg)\n\n这是普通的Trie的构造过程，我们可以对其结点进行以下魔改：\n\n```c++\nstruct node\n{\n    int son[26];\n    int isword, cnt, index[maxn];//或许用vector更好\n    node()\n    {\n        cnt = 0;\n        isword = 0;\n        memset(son, 0, sizeof(son));\n        memset(index, 0, sizeof(index));\n    }\n};\n```\n\n在结点中加入一个索引，当所有单词插入完毕后，进行检验：\n\n从第一个单词的最后一个字母开始，检查能否连接到新的单词头上（包括自己）\n\n然后Trie就会变成这样：\n\n![200804101902.jpg](https://i.loli.net/2020/08/04/2j4BdICiTkJYZR5.jpg)\n\n这样我们的DFS会比较容易，但是也有一个弊端：我们可能难以统计单词的经过次数。\n\n为了解决这个问题，可以把所有不是从叶子结点的索引全部放到叶子结点，由于叶子结点有 `isword` 标记可以判断单词是哪一个，就可以统计次数了。也就是说把上图第二个索引改为 `6->8` 即可。\n\n但是我认为这样做的时间复杂度非常差，并且这个在叶子结点增加了索引的Trie似乎也没有其他有趣的功能。这个看起来并没有什么用的东西可能真的没有什么用。\n\n这个做法理论上应该是可行的，但是比写DFS麻烦太多了，所以我也没有去实现，就在这里记录一下我的想法好了。\n\n顺便附上DFS代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 1e5 + 9;\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\nint vis[21];\nstring t[21], str;\nint check(string a, string b)\n{\n    for (int i = a.size() - 1; i >= 0; i--)\n    {\n        if (a[i] == b[0])\n        {\n            int len = i;\n            for (int j = 0; j < b.size(); j++)\n            {\n                if (a[len] == b[j])\n                    len++;\n                else\n                    break;\n            }\n            if (len == a.size())\n                return len - i;\n        }\n    }\n    return 0;\n}\nint n, ans = 0;\nvoid dfs(int dul, string a)\n{\n    ans = max(ans, (int)a.size() - dul);\n    for (int i = 1; i <= n; i++)\n    {\n        if (vis[i] > 1)\n            continue;\n        int d = check(a, t[i]);\n        if (d == 0)\n            continue;\n        vis[i]++;\n        dfs(dul + d, a + t[i]);\n        vis[i]--;\n    }\n    return;\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"data.txt\",\"w\",stdout);\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n        cin >> t[i];\n    cin >> str;\n    dfs(0, str);\n    cout << ans << '\\n';\n    //fclose(stdin);\n    //fclose(stdout);\n    return 0;\n}\n```\n\n这篇乱七八糟的文章就不放图了\n\n最后修改于2020-08-06","tags":["其它"]},{"title":"单调队列优化DP等","url":"/2020/08/02/P2034P2627/","content":"\n\n\n### 算法简介\n\n以[P2034 选择数字](https://www.luogu.com.cn/problem/P2034)和[P2627 [USACO11OPEN]Mowing the Lawn G](https://www.luogu.com.cn/problem/P2627)为例（双倍经验）总结一下单调队列优化DP和一些其它的东西。\n\n<!--more-->\n\n## 单调队列优化\n\n给出 $n$ 个非负整数，选若干个数，其中不能有超过 $k$ 个连续的数被选，需要使选出的数字和最大。也就是说，连续的 $k+1$ 个数中必然会被丢掉至少一个。\n\n显然我们只要让被丢掉的数的和最小，用总和减去这个最小值就能求出答案了。因此最初的状态转移方程是这样的：\n\n$$dp[i]=num[i]+\\min(dp[i-1],dp[i-2],\\cdots,dp[i-k])$$\n\n其中 $dp[i]$ 就表示如果丢掉第 $i$ 个数，前 $i$ 个数中被丢掉的总和。\n\n这样做的时间复杂度是 $O(nk)$，在这题的数据范围下几乎不可能通过。\n\n因此我需要对这个过程进行优化，上面做法浪费时间的原因在于求区间最小值的时候重复了很多次，可以用单调队列把这些多余的过程优化掉。\n\n构造一个从队首到队尾单调递增的单调队列，每次将新元素入队前把比它大的元素全部从队尾弹出，放入新元素，再把与当前位置距离超过 $k$ 的从队首弹出。这样每次计算 $dp[i]$ 的时候只需要从队首拿出元素加上去就可以了。\n\n代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst int INF = 0x3f3f3f3f;\nconst int maxn = 1e5 + 9;\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\nstruct node\n{\n    ull sum;\n    int n;\n    node() { sum = 0, n = 0; }\n    node(ull a, int b) : sum(a), n(b) {}\n};\ndeque<node> dq;\null dp[maxn];\nint main()\n{\n    int n, k;\n    read(n), read(k);\n    ull sum = 0, ans = 0;\n    dq.push_back(node(0, 0));\n    for (int i = 1; i <= n; ++i)\n    {\n        read(dp[i]);\n        sum += dp[i];\n        if (!dq.empty())\n            dp[i] += dq.front().sum;\n        while (!dq.empty() && dq.back().sum >= dp[i])\n            dq.pop_back();\n        dq.push_back(node(dp[i], i));\n        while (!dq.empty() && dq.front().n < i - k)\n            dq.pop_front();\n    }\n    for (int i = n - k; i <= n; ++i)\n        ans = max(ans, sum - dp[i]);\n    cout << ans << '\\n';\n    return 0;\n}\n```\n\n其中 `dq.push_back(node(0, 0));` 是必要的，否则dp数列从一开始就会错掉。\n\n\n\n当然，在 $k$ 非常小的时候，就不需要用单调队列，直接用上面的状态转移方程就好了。\n\n## 线段树优化\n\n因为要查询区间最小值，所以直接用线段树来维护，代替单调队列，代码更长更难写，复杂度由 $O(n)$ 退化到 $O(n\\log k)$，虽然完全可以解决这个问题，但是显然被单调队列全方位吊打。\n\n## 最短路\n\n这个做法是在题解里看到的，非常有意思：\n\n由于数据范围是 $0\\lt k \\le n \\le 1\\times 10^5$，$O(n\\log^2 k)$ 也可以过。我们事先设置一个超级起点和一个超级终点，从超级起点开始走向 $1\\cdots k$ 的点，每走到点 $i$ 就走向 $i+1\\cdots 1+k+1$ 的点，直到走进超级终点为止。由于连边的操作是一个点向一个区间连边，所以依然可以使用线段树来优化，再用Dijkstra算法求最短路即可。\n\n显然这个做法比线段树优化更为复杂，速度也更慢，但是这个转化问题的思路还是比较有意义的。\n\n![200802.jpg](https://i.loli.net/2020/08/02/theHfoBYdK1JyDF.jpg)\n\n这个好像是儿子的壁纸？","tags":["洛谷"]},{"title":"Educational Round 92总结","url":"/2020/07/31/CFedu92/","content":"\n每次打比赛总是会理解错题意。\n\n[题解部分在CSDN上也发了](https://blog.csdn.net/Pastafarian/article/details/107686440)\n\n<!--more-->\n\n# A. LCM Problem\n水题，显然 $2\\times a\\le \\mathrm{lcm}(a,b) \\; , \\;b\\le \\mathrm{lcm}(a,b)$，那么就做完了。\n# B. Array Walk\n很明显是个DP，但是我调了好久才对，还是太菜了。\n推导过程如下：\n首先对于 $z=0$ 的情况，显然最终结果是 $dp_0=max_0=\\sum_{i=1}^{k+1}a_i$\n所以可以建一个前缀和数组。\n\n$z=1$的时候除了不仅可以像上面那样走，还可以选择在路程中间后退一次或者在末端后退一次。在中间后退使得路径长度减少2，中间有连续的两个块会被经过两次；在末端后退会路径长度减少1，路径的倒数第二个块经过两次。于是可以再开一个数组记录到当前位置为止的最大相邻块值的和，即$m[i] = \\max(m[i - 1], a[i - 1] + a[i])$\n那么 $max_1=\\max(pre[k-1] + m[k-1], pre[k]  + a[k-1])$\n显然，$dp_1=\\max(dp_0,max_1)$\n\n$z\\ge2$ 的时候以此类推，可以得到 $dp_i=\\max(dp_{i-1},max_i)$ 以及\n$max_i=\\max(pre[k + 1 - 2 \\times i] + i \\times m[k + 1 - 2 \\times i], pre[k + 2 - 2 \\times i] + (i - 1) \\times m[k + 2 - 2 \\times i] + a[k + 1 - 2 \\times i])$\n\n于是这题就做完了，复杂度 $O(k)$。\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst int INF = 0x3f3f3f3f;\nconst int maxn = 1e5 + 9;\ninline int read()\n{\n    int data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    return f * data;\n}\nint arr[maxn], pre[maxn], m[maxn];\n\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"data.txt\",\"w\",stdout);\n    //std::ios::sync_with_stdio(false);\n    //std::cin.tie(0);\n    int T;\n    T = read();\n    while (T--)\n    {\n        memset(m, 0, sizeof(m));\n        int n = read(), k = read(), z = read();\n        for (int i = 1; i <= n; ++i)\n        {\n            arr[i] = read();\n            pre[i] = pre[i - 1] + arr[i];\n            m[i] = max(m[i - 1], arr[i - 1] + arr[i]);\n        }\n        int ans = pre[k + 1], tmp;\n        for (int i = 1; i <= z; ++i)\n        {\n            if (k < 2 * i - 1)\n                break;\n            tmp = max(pre[k + 1 - 2 * i] + i * m[k + 1 - 2 * i], pre[k + 2 - 2 * i] + (i - 1) * m[k + 2 - 2 * i] + arr[k + 1 - 2 * i]);\n            ans = max(ans, tmp);\n        }\n        cout << ans << '\\n';\n    }\n    //fclose(stdin);\n    //fclose(stdout);\n    return 0;\n}\n```\n# C. Good String\n比赛的时候理解错了题意，试了二分和尺取法结果都过不了样例。第二天再看发现题目读错了。。。。。\n显然，满足题目要求的左移和右移后相同的序列只可能是两种：\n\n1. 所有的元素全部相同\n2. 两个不同元素交替循环，如 `0101010101`\n\n可以发现，如果序列长度是奇数那么必须是第一种\n由于所有字符都是数字，可以把所有组合都枚举一遍计算好串长度最大值，再用总长度减一下就行了\n这题到这里也就做完了\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst int INF = 0x3f3f3f3f;\nconst int maxn = 1e5 + 9;\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\nstring s;\nint calc(int x, int y)\n{\n    int ans = 0;\n    for (int i = 0; i < s.length(); ++i)\n        if (s[i] - '0' == x)\n        {\n            ans++;\n            swap(x, y);\n        }\n    if (x != y && ans & 1)\n        ans--;\n    return ans;\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"data.txt\",\"w\",stdout);\n    //std::ios::sync_with_stdio(false);\n    //std::cin.tie(0);\n    int T;\n    read(T);\n    while (T--)\n    {\n        cin >> s;\n        int ans = 0;\n        for (int i = 0; i <= 9; ++i)\n            for (int j = 0; j <= 9; ++j)\n                ans = max(ans, calc(i, j));\n        cout << s.length() - ans << '\\n';\n    }\n    //fclose(stdin);\n    //fclose(stdout);\n    return 0;\n}\n\n```\n# D. Segment Intersections\n又是一个题面令人费解的题，并且比C难多了。\n分类讨论很复杂，尤其两条线段不相交的情况。\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\nll n, k, l1, l2, r1, r2;\nint main()\n{\n    int t;\n    read(t);\n    while (t--)\n    {\n        read(n), read(k), read(l1), read(r1), read(l2), read(r2);\n        ll ans = 1e18;\n        if (max(l1, l2) <= min(r1, r2))\n        {\n            ll rem = max((ll)0, k - n * (min(r1, r2) - max(l1, l2)));\n            ll mp = n * (abs(l1 - l2) + abs(r1 - r2));\n            ans = min(rem, mp) + max((ll)0, rem - mp) * 2;\n        }\n        else//不相交\n        {\n            ll inv = max(l1, l2) - min(r1, r2);//间隔\n            for (int i = 1; i <= n; ++i)\n            {\n                ll tmp = i * inv;//补上间隔\n                ll mp = (max(r1, r2) - min(l1, l2)) * i;//最大长度\n                tmp += min(k, mp) + max((ll)0, k - mp) * 2;//调整\n                ans = min(ans, tmp);\n            }\n        }\n        cout << ans << '\\n';\n    }\n}\n```\n照着题解的kotlin代码写了一份c++的\n# E. Calendar Ambiguity\n由题，$x\\times d+y\\equiv y\\times d+x \\pmod w$，变形可得：\n$(x-y)\\times(d-1)\\equiv 0\\pmod w$\n那么就很明显了，既然 $d$ 和 $w$ 都已知了，$x-y$ 一定是 $\\frac{w}{\\gcd(w,d-1)}$ 的整数倍。接下来等差数列求和就可以解决了。\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\nll m, d, w;\nint main()\n{\n    int t;\n    read(t);\n    while (t--)\n    {\n        read(m), read(d), read(w);\n        ll w2 = w / __gcd(d - 1, w);\n        ll md = min(m, d);\n        ll cnt = md / w2;\n        ll ans = (2 * md - w2 * (cnt + 1)) * cnt / 2;\n        cout << ans << '\\n';\n    }\n}\n```\n\n# 总结\n\n以我目前的水平，前五题应该是可以做出来的，即便像D这样的题比赛的时候调不出来，做对四题也是应该的。这一场做出四题基本能进1000，五题就能进500，可以涨一大波分。但是最终的结果不尽人意，主要还是因为这种题目做的还不够多。CF这种类型的题目一般不需要任何算法，仅仅是对暴力模拟的一点优化而已，因此还是要做一些div2的BCD题来熟练一下。\n\n![200731.jpg](https://i.loli.net/2020/07/31/WTIi26RS54fwm8n.jpg)\n\n","tags":["CodeForces"]},{"title":"洛谷7月月赛div2","url":"/2020/07/25/LGR-073div2/","content":"\n在出题解之前口胡了一些思路，现在把之前想错的和没写的补上。\n\n<!--more-->\n\n## A&B\n\nA二分答案，不卡精度，很简单；\n\nB算一下前缀和，后面计算取模的时候注意一下顺序，也没什么问题。\n\n*没什么问题*\n\n## C\n\n应该是一个DP，容易发现每一列在旋转的时候是不会变的，而上下是否颠倒与其旋转次数奇偶有关，所以可以判断能否做出目标形状，最少次数应该是从某个边缘开始逐渐还原的顺序需要的次数。没写代码不知道这个思路对不对。\n\n*观察到的性质没有问题，确实需要利用这个性质来解题，但是需要转化后通过计算逆序对的方法求解。*\n\n## D\n\n写这篇文章就是为了记下看到D题以后我的胡思乱想。\n\n看到单点修改先想到树状数组，但是显然没法完成区间排序判断。区间排序会打乱元素顺序，那么差分就没有用，每次排序用时 $(r-l)\\log(r-l)$，太长，考虑用一个map之类的东西存放，这样如果重复元素多的话会好一点。但是这样做显然是不行的，首先不可能每次把区间的一堆东西丢进map，这样比直接排序还慢，而如果用类似前缀和的思想，开 $n$ 个map，那不仅空间会爆炸，map的复制也是个问题。因为要有序，所以不能用hash。\n\n第二个想法是用珂朵莉树，每次查询区间的时候把没有的区间放进set，有的区间split掉得到要求的区间，但是这样同样需要很多的map，并且复杂度不见得优秀到哪里去，估计也是不行的。\n\n然后想如果搞一棵树去存序列的点的话也是修改比较方便，判断操作是很麻烦的，还是需要维护序列的数据结构，或许可以把线段树的结构修改一下，下面的叶子存储数据，在上面建一个类似于平衡树的结构？不知道有什么神奇的结构可以搞这样的序列。\n\n*本题的正解是线段树与哈希，需要将一个区间哈希成一个值，非常巧妙。从来没有想过还可以有这样的做法。*\n\n8月月赛快来了，7月236pts，下次希望能超过250pts。\n\n![200725.jpg](https://i.loli.net/2020/07/25/NGbP53ZU69HFqOa.jpg)","tags":["洛谷"]},{"title":"CF#658div2总结","url":"/2020/07/24/CF658div2/","content":"\n这场除了E比较难，其他题都比较简单，可惜比赛的时候思路并没有很清晰。\n\n<!--more-->\n\n## A&B\n\nA水题。B稍微想一下，第一个遇到多于一个的堆的人可以掌控之后的局势，必然获胜，也很容易。\n\n## C\n\nC给的积分居然比B还低，就离谱。\n\n不过C也确实很简单，应该先看Hard Version，就比较容易想出先全部推平再转化的做法，先看Easy Version反而有一种被误导的感觉。\n\n比赛的时候看到序列翻转就像中了邪一样去想Splay，这种比赛平时连线段树都不会考，会考Splay？\n\n题解写在CSDN上：[CF1382C（1381A）Prefix Flip](https://blog.csdn.net/Pastafarian/article/details/107562596)\n\n## D\n\nD的转化倒是非常巧妙，归并的性质似乎没有那么容易看出来，虽然看出来以后正确性是非常容易证明的。转化成DP以后就没有难度了，最简单的01背包。\n\n题解写在CSDN上：[CF1382D（1381B）Unmerge](https://blog.csdn.net/Pastafarian/article/details/107568308)\n\n## E\n\n只有E题的构造比较难，毕竟也是div1的C，\\*2500的题了，改天有空的时候好好学一下。\n\n\n\n过了C大概能进1000，再过D能进500，思路并不复杂，也都是我会的算法，为什么比赛的时候就做不出来？以后需要每天做一两道div1的AB题开拓一下思维了。\n\n\n\n今天的比赛不能再掉分了\n\n![200724.jpg](https://i.loli.net/2020/07/24/UPnsZ3ykSA1RIDl.jpg)","tags":["CodeForces"]},{"title":"单调栈","url":"/2020/07/20/Monotone_Stack/","content":"\n## 简介：\n\n顾名思义，单调栈中的元素是单调的，规定其单调性由**出栈顺序**决定，即栈顶元素最小的单调栈是单调递增栈，反之则是单调递减栈。\n\n<!--more-->\n\n## 单调栈原理\n\n例如有一个单调递增栈，要把4，2，3，6，1，5这6个数放进去，其运行过程如图所示：\n\n![200720MS.png](https://i.loli.net/2020/07/20/VQN1ESyAT2Wpagj.png)\n\n可见，每当新元素加入时都会把比它小的元素一个个弹出，直到栈顶元素比它大或栈空为止。这个维护单调性的操作和单调队列有些相似。\n\n单调栈这个数据结构虽然看起来很蠢，但是却能优化一些算法，例如在一个数列中找到每个数后面第一个比它大的数据的位置，暴力算法的复杂度是 $O(n^2)$，对于随机数据可能会表现比较好，但是如果某一个测试数据是单调递减的序列，暴力算法一定会被卡掉，而使用单调栈是稳定的 $O(n)$，这是一个非常大的进步。\n\n\n## 具体实现（模板题[P5788](https://www.luogu.com.cn/problem/P5788)）\n\nSTL的栈就很好用，没必要手写。用递增的单调栈从后往前过一遍就可以了。\n\n### AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 3e6 + 9;\nint n, a[maxn], ans[maxn];\nstack<int> s;\ninline int read()//数据有点多，cin会TLE\n{\n    int data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    return f * data;\n}\nint main()\n{\n    n = read();\n    for (int i = 1; i <= n; ++i)\n        a[i] = read();\n    for (int i = n; i > 0; --i)\n    {\n        while (!s.empty() && a[s.top()] <= a[i])\n            s.pop();\n        if (!s.empty())\n            ans[i] = s.top();\n        s.push(i);\n    }\n    for (int i = 1; i <= n; ++i)\n        cout << ans[i] << ' ';\n    return 0;\n}\n```\n\n![200720ms.jpg](https://i.loli.net/2020/07/20/yRQ6YscEXWt7JOa.jpg)\n\n这个瓶子也算是个栈？","tags":["数据结构"]},{"title":"洛谷P2671题解","url":"/2020/07/19/P2671-Solution/","content":"\n\n\n[P2671求和](https://www.luogu.com.cn/problem/P2671) 前缀和，数学推导\n\n<!--more-->\n\n这题比较复杂，以下是部分思路：\n\n1. 数据范围很大，要用 `long long` 存储，算一次取模一次，并且算法的时间复杂度不能超过 $O(n\\log n)$；\n   -  最简单的想法是 $O(n^3)$ 的暴力，稍作分析可以优化为 $O(n^2)$，但是显然这两种方法在这里都不管用\n   -  但是以上分析的过程可以得到一个**非常重要的结论**：$y$ 的值并不需要我们知道\n   -  在两个大小不同而奇偶性相同的数之间必然存在一个偶数是这两个数的平均数\n2. 由上一条可以发现，数字对应的编号的意义在于计算 $(x+z)\\times (number\\_x+number\\_z)$ 以及根据奇偶性分组，而颜色也需要另行分组，因此可以分为不多于 $2\\times m$ 种\n3. 在每组中求这些乘积的和，使用分配率以后可以发现，$x\\times number\\_x$ 与 $z\\times number\\_z$ 可以在读入的时候直接算出，因此只需要算 $\\sum (x\\times number\\_z+z\\times number\\_x)$，这个求和可以化成 $\\sum _{i=1}^n x_i\\times (\\sum _{j=1}^n number\\_z_j)-x_i\\times number\\_x_i$ 之类的东西，从而在 $O(n)$ 时间内求出\n\n\n\n大致的思路就是这样，以下是代码的一种写法\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e5 + 9;\nconst int mod = 10007;\n\ninline ll read()\n{\n    ll data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    return f * data;\n}\n\nint num[maxn], col[maxn];\nll ans, f[maxn][2][4];\n//f[][0][]:颜色  f[][1][]:奇偶\nint main()\n{\n    int n = read(), m = read();\n    for (int i = 1; i <= n; i++)\n        num[i] = read() % mod;\n    for (int i = 1; i <= n; i++)\n        col[i] = read() % mod;\n    for (int i = 1; i <= n; i++)\n    {\n        (ans += (f[col[i]][i % 2][0] * (i % mod) * (num[i] % mod)) % mod) %= mod;\n        (ans += f[col[i]][i % 2][1]) %= mod;\n        (ans += ((i % mod) * f[col[i]][i % 2][2]) % mod) %= mod;\n        (ans += ((num[i] % mod) * f[col[i]][i % 2][3]) % mod) %= mod;\n        (f[col[i]][i % 2][0] += 1) %= mod;\n        //满足条件个数\n        (f[col[i]][i % 2][1] += (i % mod) * (num[i] % mod)) %= mod;\n        //sum z*number_z\n        (f[col[i]][i % 2][2] += num[i] % mod) %= mod;\n        //sum z\n        (f[col[i]][i % 2][3] += i % mod) %= mod;\n        //sum number_z\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n\n```\n\n这题真是让人头大。。。\n\n![200719P2671.jpg](https://i.loli.net/2020/07/19/bloA8djRuJw2GgX.jpg)","tags":["洛谷"]},{"title":"Treap（树堆）","url":"/2020/07/19/Treap/","content":"\n# 简介：\n\n“如果将一个含n个元素的集合插入到一棵二叉搜索树中，所得到的的树可能会相当不平衡，从而导致查找时间很长……随机构造二叉搜索树是趋向于平衡的……可以采用一种策略是先随机排列这些元素，然后按照排列的顺序将它们插入到树中……一棵Treap树就是一棵更改了结点排序方式的二叉搜索树”——《算法导论》\n\n<!--more-->\n\n# 基本性质：\n\n顾名思义，Treap是Tree与Heap的结合体，二叉搜索树功能强大但是容易退化，而堆则具有完全二叉树的性质，Treap兼具二者优点，从而保持平衡。\n\n显然，为了保持搜索树的性质，Treap中的元素不能像堆一样放，依然需要遵循BST的规则，因此对于每个元素需要引入一个随机数作为维持堆的性质的依据。对于每个节点，满足以下三个性质：\n\n1. 如果ls是root的左孩子，val[ls]<val[root]；\n2. 如果rs是root的右孩子，val[rs]>val[root]；\n3. 如果s是root的后代，rnd[u]>rnd[root]（小根堆）\n\n\n\n# 具体实现：\n\n## 1、准备工作\n\n### 存储结构\n\n```c++\nstruct node{\n    int ls, rs, val, size, rnd, freq;\n} treap[maxn];\n```\n\n数组存Treap，没什么好说的，和AVL树相比多了一个值rnd\n\n### 随机数生成\n\n可以用自带的 `rand()` 函数，但是据说容易被卡，所以也可以自己写。\n\n## 2、重要功能\n\n### 更新信息\n\n```c++\ninline void update(int k) \n{\n    treap[k].size = treap[treap[k].ls].size + treap[treap[k].rs].size + treap[k].freq;\n}\n```\n\n### 旋转\n\n对于一棵BST，可以发现以下两种旋转结点的方式可以不改变结点排列规则而改变树的结构，所以Treap可以通过这两种方式使结点满足堆的性质。\n\n![200719rotate.png](https://i.loli.net/2020/07/19/KX6iGy8ZTHAD4pY.png)\n\n- 左旋：\n\n\t1. 取出根的右子树，即图中提取出C的过程\n\t2. 用根的右子树的左子树替换根的右子树，即图中F—>A的过程\n\t3. 用根替换被取出的右子树的左子树，即图中下移A点使其变成C的左子树的过程\n\t4. 更新数据\n\n\n```c++\ninline void rotate_l(int &k)\n{\n    int t = treap[k].rs;\n    treap[k].rs = treap[t].ls;\n    treap[t].ls = k;\n    treap[t].size = treap[k].size;\n    update(k);\n    k = t;\n}\n```\n\n- 右旋：\n\n  1.  取出根的左子树，即图中提取出B的过程\n  2. 用根的左子树的右子树替换根的左子树，即图中E—>A的过程\n  3. 用根替换被取出的左子树的右子树，即图中下移A点使其变成B的右子树的过程\n  4. 更新数据\n\n```c++\ninline void rotate_r(int &k)\n{\n    int t = treap[k].ls;\n    treap[k].ls = treap[t].rs;\n    treap[t].rs = k;\n    treap[t].size = treap[k].size;\n    update(k);\n    k = t;\n}\n```\n\n可见左旋和右旋正好是完全相反的过程，它们与在堆中插入元素时不断向上对比交换效果类似，从堆的角度来看，左旋相当于交换右孩子与父亲的值，右旋反之。\n\n\n\n### 插入\n\nBST的递归插入方式，顺便维护堆的性质。\n\n```c++\nvoid insert(int &k, int x)\n{\n    if (k == 0)\n    {\n        cnt++;\n        k = cnt;\n        treap[k].size = treap[k].freq = 1;\n        treap[k].val = x;\n        treap[k].rnd = rand();\n        return;\n    }\n    treap[k].size++;\n    if (treap[k].val == x)\n        treap[k].freq++; \n    else if (x > treap[k].val)\n    {\n        insert(treap[k].rs, x);\n        if (treap[treap[k].rs].rnd < treap[k].rnd)\n            rotate_l(k); \n    }\n    else\n    {\n        insert(treap[k].ls, x);\n        if (treap[treap[k].ls].rnd < treap[k].rnd)\n            rotate_r(k);\n    }\n}\n```\n\n\n\n### 删除\n\n先利用BST性质找到这个值，再把这个节点旋转成叶子节点，最后删除\n\n```c++\nvoid del(int &k, int x)\n{\n    if (k == 0)\n        return;\n    if (treap[k].val == x)\n    {\n        if (treap[k].freq > 1)\n        {\n            treap[k].freq--;\n            treap[k].size--;\n            return; \n        }\n        if (treap[k].ls * treap[k].rs == 0)\n            k = treap[k].ls + treap[k].rs; //有一个儿子为空\n        else if (treap[treap[k].ls].rnd < treap[treap[k].rs].rnd)\n            rotate_r(k), del(k, x);\n        else\n            rotate_l(k), del(k, x);\n    }\n    else if (x > treap[k].val)\n        treap[k].size--, del(treap[k].rs, x);\n    else\n        treap[k].size--, del(treap[k].ls, x);\n}\n```\n\n\n\n### 根据值查询排名\n\n与AVL树类似\n\n```c++\nint query_rank(int k, int x)\n{\n    if (k == 0)\n        return 0;\n    if (treap[k].val == x)\n        return treap[treap[k].ls].size + 1;\n    else if (x > treap[k].val)\n        return treap[treap[k].ls].size + treap[k].freq + query_rank(treap[k].rs, x);\n    else\n        return query_rank(treap[k].ls, x);\n}\n```\n\n\n\n### 根据排名查找值\n\n同样与AVL树类似\n\n```c++\nint query_val(int k, int x)\n{\n    if (k == 0)\n        return 0;\n    if (x <= treap[treap[k].ls].size)\n        return query_val(treap[k].ls, x);\n    else if (x > treap[treap[k].ls].size + treap[k].freq)\n        return query_val(treap[k].rs, x - treap[treap[k].ls].size - treap[k].freq);\n    else\n        return treap[k].val;\n}\n```\n\n\n\n### 查询前驱/后继\n\n由于是数组中建的树，实现难度远远低于AVL树\n\n```c++\nint query_pre(int k, int x)\n{\n    int t = k, ans = 0;\n    while (t)\n    {\n        if (treap[t].val < x)\n            ans = treap[t].val, t = treap[t].rs;\n        else\n            t = treap[t].ls;\n    }\n    return ans;\n}\nint query_suf(int k, int x)\n{\n    int t = k, ans = 0;\n    while (t)\n    {\n        if (treap[t].val > x)\n            ans = treap[t].val, t = treap[t].ls;\n        else\n            t = treap[t].rs;\n    }\n    return ans;\n}\n```\n\n\n\n## 3、完整代码（以[P3369](https://www.luogu.com.cn/problem/P3369)为例）\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1e5 + 9;\nstruct node\n{\n    int ls, rs, val, size, rnd, freq;\n} treap[maxn];\nint n, cnt, root;\ninline void update(int k)\n{\n    treap[k].size = treap[treap[k].ls].size + treap[treap[k].rs].size + treap[k].freq;\n}\ninline void rotate_l(int &k)\n{\n    int t = treap[k].rs; \n    treap[k].rs = treap[t].ls;\n    treap[t].ls = k;\n    treap[t].size = treap[k].size;\n    update(k);\n    k = t;\n}\ninline void rotate_r(int &k)\n{\n    int t = treap[k].ls;\n    treap[k].ls = treap[t].rs;\n    treap[t].rs = k;\n    treap[t].size = treap[k].size;\n    update(k);\n    k = t;\n}\nvoid insert(int &k, int x)\n{\n    if (k == 0)\n    {\n        cnt++;\n        k = cnt;\n        treap[k].size = treap[k].freq = 1;\n        treap[k].val = x;\n        treap[k].rnd = rand();\n        return;\n    }\n    treap[k].size++;\n    if (treap[k].val == x)\n        treap[k].freq++;\n    else if (x > treap[k].val)\n    {\n        insert(treap[k].rs, x);\n        if (treap[treap[k].rs].rnd < treap[k].rnd)\n            rotate_l(k);\n    }\n    else\n    {\n        insert(treap[k].ls, x);\n        if (treap[treap[k].ls].rnd < treap[k].rnd)\n            rotate_r(k);\n    }\n}\nvoid del(int &k, int x)\n{\n    if (k == 0)\n        return;\n    if (treap[k].val == x)\n    {\n        if (treap[k].freq > 1)\n        {\n            treap[k].freq--;\n            treap[k].size--;\n            return;\n        }\n        if (treap[k].ls * treap[k].rs == 0)\n            k = treap[k].ls + treap[k].rs; \n        else if (treap[treap[k].ls].rnd < treap[treap[k].rs].rnd)\n            rotate_r(k), del(k, x);\n        else\n            rotate_l(k), del(k, x);\n    }\n    else if (x > treap[k].val)\n        treap[k].size--, del(treap[k].rs, x);\n    else\n        treap[k].size--, del(treap[k].ls, x);\n}\nint query_rank(int k, int x)\n{\n    if (k == 0)\n        return 0;\n    if (treap[k].val == x)\n        return treap[treap[k].ls].size + 1;\n    else if (x > treap[k].val)\n        return treap[treap[k].ls].size + treap[k].freq + query_rank(treap[k].rs, x);\n    else\n        return query_rank(treap[k].ls, x);\n}\nint query_val(int k, int x)\n{\n    if (k == 0)\n        return 0;\n    if (x <= treap[treap[k].ls].size)\n        return query_val(treap[k].ls, x);\n    else if (x > treap[treap[k].ls].size + treap[k].freq)\n        return query_val(treap[k].rs, x - treap[treap[k].ls].size - treap[k].freq);\n    else\n        return treap[k].val;\n}\nint query_pre(int k, int x)\n{\n    int t = k, ans = 0;\n    while (t)\n    {\n        if (treap[t].val < x)\n            ans = treap[t].val, t = treap[t].rs;\n        else\n            t = treap[t].ls;\n    }\n    return ans;\n}\nint query_suf(int k, int x)\n{\n    int t = k, ans = 0;\n    while (t)\n    {\n        if (treap[t].val > x)\n            ans = treap[t].val, t = treap[t].ls;\n        else\n            t = treap[t].rs;\n    }\n    return ans;\n}\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cin >> n;\n    int opt, x;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> opt >> x;\n        switch (opt)\n        {\n        case 1:\n            insert(root, x);\n            break;\n        case 2:\n            del(root, x);\n            break;\n        case 3:\n            cout << query_rank(root, x) << '\\n';\n            break;\n        case 4:\n            cout << query_val(root, x) << '\\n';\n            break;\n        case 5:\n            cout << query_pre(root, x) << '\\n';\n            break;\n        case 6:\n            cout << query_suf(root, x) << '\\n';\n            break;\n        }\n    }\n    return 0;\n}\n```\n\n这样的Treap并非代码量最少的写法，但是便于理解，即便如此也比AVL树的实现少了100多行。\n\n\n\n# 后记\n\nTreap是一种非常有趣的数据结构，它并非像AVL树那样高度平衡，但是效率也不低，而且远比AVL树、红黑树好写。由于常数比较小，普通Treap的速度比Splay快。甚至在进行一些改进后Treap可以做到可持久化、分裂合并以及序列处理操作，是一种很强大的平衡树。\n\n\n\n学了大半天的Treap那就发一张树的图片好了。\n\n![200719Treap.jpg](https://i.loli.net/2020/07/19/usAjkBcWDYa4RSe.jpg)","tags":["数据结构"]},{"title":"HTML5基础知识","url":"/2020/07/17/HTML5_first_things_first/","content":"\n\nHTML即Hyper Text Markup Language（超文本标记语言），目前主流浏览器均支持HTML5。以下是一些HTML5最基本的概念。\n\n<!--more-->\n\n常用语句：\n\n- 声明：`<!DOCTYPPE>`\n\n  - HTML5：`<!DOCTYPPE html>`\n\n- `<head>`\n\n  -  `<title>` 显示网页标签的名字\n  -  `<link rel=\"stylesheet\" type=\"text/css\" href=\"\">` 外部样式表\n  -  内部样式表：\n\n  ```html\n  <style type=\"text/css\">\n  \tp{\n  \t\tcolor: #5C3317;<!-棕色->\n  \t}\n  </style>\n  ```\n\n- `<body>` \n\n  - 标题 `<h1>` 到`<h6>`逐渐变小 \n\n  - `<p>` 段落（结束后另起一行）\n\n  - `<a>` 超链接，用法：\n\n    `<a href=\"https://phlzy.github.io/\">blog</a>`\n\n  - `<img>` 图片，用法：\n\n    `<img src=\"images/html.png\">`\n\n  - `<br/>` 空标签（间距较小）\n  \n  - 格式化：\n  \n    ```html\n    <b>加粗</b>\n    <em>着重（斜体）</em>\n    <i>斜体</i>\n    <small>变小</small>\n    <strong>强调（变粗）</strong>\n    <sub>下标</sub>\n    <sup>上标</sup>\n    <ins>下划线</ins>\n    <del>删除线</del>\n    ```\n  - 内联样式表：`<a style=\"color: aqua\">` \n    \n\n### 元素标签\n\n**块：结束后会换行**\n\n标题 `<h1>` 等，段落 `<p>` 及列表 `ul` 等均为块元素\n\n**内联元素：结束后一般不会换行**\n\n**div元素：一般配合CSS样式作为组合HTML元素的容器使用**\n\n**span元素：内联元素，文本的容器**\n\n### 布局\n\n大致如下所示：\n\n```html\n<!DOCTYPE html>\n\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title>Index</title>\n    <style type=\"text/css\">\n        body{\n            margin: 0px;\n        }\n        #container{\n            width: 100%;\n            height: 950px;\n            background-color: antiquewhite;\n        }\n        #head{\n            width: 100%;\n            height: 10%;\n            background-color: darkgray;\n        }\n        #content_menu{\n            width: 30%;\n            height: 80%;\n            background-color: white;\n            float: right;\n        }\n        #content_body{\n            width: 70%;\n            height: 80%;\n            background-color: aqua;\n            float: left;\n        }\n        #bottom{\n            width: 100%;\n            height: 10%;\n            background-color: antiquewhite;\n            clear: both;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"container\">\n        <div id=\"head\">\n            \n        </div>\n        <div id=\"content_menu\">\n            \n        </div>\n        <div id=\"content_body\">\n\n        </div>\n        <div id=\"bottom\">\n\n        </div>\n    </div>\n\n</body>\n\n</html>\n```\n\n看完这些无聊的东西，是时候放松一下自己了\n\n![200717html.jpg](https://i.loli.net/2020/07/17/3wn4c2JAa5TRLYM.jpg)","tags":["前端"]},{"title":"最长不下降子序列（LIS）与最长公共子序列（LCS）","url":"/2020/07/16/LIS&LCS/","content":"\n\n\n总结一下线性动态规划的两个经典问题：最长不下降子序列（LIS）与最长公共子序列（LCS）。\n\n\n\n<!--more-->\n\n###  LIS回顾：（[模板题P1020](https://www.luogu.com.cn/problem/P1020)）\n\n提供一个序列，求最长不下降子序列（Longest Increasing Subsequence）：\n\n- 朴素的 $O(n^2)$ 做法：对每个元素，存储以该元素结尾的最长不下降子序列长度，从前往后递推。\n  - 思路简单，效率低下\n- $O(n\\log n)$ 做法：初始化一个空数组，将元素依次按照以下规则填入：\n  - 若数组为空或最后一个元素不大于新元素，直接将新元素push_back；\n  - 若数组最后一个元素大于新元素，查找数组中第一个大于新元素的元素并用新元素代替；\n  - 观察该流程可以发现，新数组是单调非递减的，类似于一个队列，该数组的长度就是LIS的长度，由于可以使用二分查找，时间复杂度优化到 $O(n\\log n)$。\n  - 正确性：第一类操作显然正确，不必多言。第二类操作替换数组内元素，不会改变其长度，因此对之前的结果不会产生影响，而后续如果会产生更长的子序列，接在新元素的后面也是更优的选择，也就是说被替换的元素同样不会对后续造成影响。\n- 二分查找\n  - `lower_bound(ForwardIterator beg,ForwardIterator end,const T& value,BinaryPredicate op)`（默认升序，op可以不加）：返回**第一个大于等于**value的元素位置，即**可插入元素值为value，且不破坏区间有序性**的位置。如果不存在这样的位置，返回end\n  - `upper_bound(ForwardIterator beg,ForwardIterator end,const T& value,BinaryPredicate op)`（默认升序，op可以不加）：返回**第一个大于**value的元素位置，即**可插入元素值为value，且不破坏区间有序性**的位置。如果不存在这样的位置，返回end\n  - 如果容器支持随机访问，以上两个函数的复杂度是对数的\n\n所以求LIS的核心代码大致是这样的：\n\n\n```c++\nint len = 1; \nd[1] = a[1];           \nfor (int i = 2; i <= n; ++i)\n{ \n    if (d[len] <= a[i])\n        d[++len] = a[i];\n    else\n    {\n        int p = upper_bound(d + 1, d + 1 + len, a[i]) - d;\n        d[p] = a[i];\n    }\n}\n```\n\nPS.LIS也可以用树状数组做\n\n### LCS：（[模板题P1439](https://www.luogu.com.cn/problem/P1439)）\n\n提供从1到n的两个排列 $P_1$、$P_2$，求它们的最长公共子序列（Longest Common Subsequence）：\n\n- $O(n^2)$ 的做法是直接DP，以 $i$ 表示 $P_1$ 的前 $i$ 位，以 $j$ 表示 $P_2$ 的前 $j$ 位，可以得到以下两个状态转移方程：\n  - $$dp[i][j]=\\max\\{dp[i][j],dp[i-1][j-1]+1\\}(P_1[i]=P_2[j])$$\n  - $$dp[i][j]=\\max\\{dp[i-1][j],dp[i][j-1]\\}(P_1[i]\\ne P_2[j])$$\n  - 会被卡掉\n  \n- $O(n\\log n)$ 做法：利用全排列的性质\n\n  - 由题可知，两个序列的元素种类相同，只是排列顺序不一样，因此可以以其中一个作为基准重新编号，如图所示：\n\n  | $P_1$  | B（2） | D（4） | C（3） | E（5） | A（1） |\n  | ------ | ------ | ------ | ------ | ------ | ------ |\n  | $P_2$  | C（3） | A（1） | E（5） | B（2） | D（4） |\n  | $P_1'$ | 1      | 2      | 3      | 4      | 5      |\n  | $P_2'$ | 3      | 5      | 4      | 1      | 2      |\n\n  - 这样重新标号后 $P_1'$ 序列是递增的，那么这个问题就转化为了求LIS的问题。\n\nP1439AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100009;\nint a[maxn], m[maxn], b[maxn], t[maxn], d[maxn], n;\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cin >> n;\n    for (int i = 1; i <= n; ++i)\n    {\n        cin >> a[i];\n        m[a[i]] = i;\n    }\n    for (int i = 1; i <= n; ++i)\n    {\n        cin >> b[i];\n        t[i] = m[b[i]];\n    }\n    int len = 1;\n    d[1] = t[1];\n    for (int i = 2; i <= n; ++i)\n    {\n        if (d[len] <= t[i])\n            d[++len] = t[i];\n        else\n        {\n            int p = upper_bound(d + 1, d + 1 + len, t[i]) - d;\n            d[p] = t[i];\n        }\n    }\n    cout << len << '\\n';\n    return 0;\n}\n```\n\n日常：\n\n![200716.jpg](https://i.loli.net/2020/07/16/SKHyueG5FdwRPNn.jpg)","tags":["洛谷","算法"]},{"title":"VSCode常用快捷键","url":"/2020/07/14/VSCode/","content":"\n写代码的时候不用鼠标才能达到最高的效率\n\n<!--more-->\n\n常用快捷键：\n\n\n|    快捷键    |      功能      |\n| :--------------------: | :--------------------: |\n|       Ctrl+Shift+P或F1       | 打开命令面板  |\n|       Ctrl+P       |      搜索文件      |\n|    Ctrl+Shift+W    |      关闭窗口      |\n|    Ctrl+Shift+N    |     打开新窗口     |\n|  Ctrl+X（不选中）  |      剪切本行      |\n|  Ctrl+C（不选中）  |      复制本行      |\n|    Alt+ ↑ 或 ↓ |   上移或下移本行   |\n| Shift+Alt + ↓ 或 ↑ | 向上或向下复制本行 |\n|    Ctrl+Shift+K    |      删除本行      |\n|     Ctrl+Enter     |   在下方插入一行   |\n|  Ctrl+Shift+Enter  |   在上方插入一行   |\n|  Ctrl+Shift+\\ | 移动到相匹配的括号 |\n|     Home / End     | 到本行的行首或行尾 |\n| Ctrl+Home / End |    到文件的头尾    |\n|     Ctrl+↑ / ↓     |   上下拖动滚动条   |\n| Ctrl+Shift+[或] |   折叠或展开区域   |\n|  Ctrl+K Ctrl+C |   将本行变成注释   |\n|  Ctrl+K Ctrl+U | 将本行注释变成代码 |\n|       Ctrl+M       | 通过tab移动焦点 |\n|       Ctrl+G       |     跳转到某行     |\n|         F8         |  定位到下一个错误  |\n|       Ctrl+F       |        查找        |\n|       Ctrl+H       |        替换        |\n|    （Shift+）F3    |    （上）下一个    |\n|       Ctrl+N       |        新建        |\n|       Ctrl+O       |        打开        |\n|      Ctrl+K S      |      全部保存      |\n\n[全部快捷键在此](https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf)\n\n\n\nVSC本身并不可怕，可怕的是它的主人\n\n![vsc](https://i.loli.net/2020/07/14/pGXAh7J5ZuU3vRg.jpg)","tags":["其它"]},{"title":"CF#655div2总结","url":"/2020/07/12/CF655div2/","content":"\n\n\n**几个月没打CF了，本来想拿这一场试试手感，虽然是比寒假菜了不少，但是似乎有很大的上分的希望，只可惜评测姬似乎罢工了导致Unrated。。。**\n\n\n\n<!--more-->\n\n## A. Omkar and Completion\n\n第一眼看上去不像水题的超级大水题，全部输出一个1000以内数字就好了。没啥好说的。\n\n## B. Omkar and Last Class of Math\n\n显而易见，如果 $n$ 是质数，输出 $1$ 和 $n-1$，否则输出 $n/k$ 与 $n-n/k$，其中 $k$ 是 $n$ 的最小质因数。\n\n这个规律很容易证明，考虑到 $t\\le 10$ 以及 $2\\le n \\le 10^9$，我写了个线性筛，预处理后如果是质数直接输出，如果是合数就从质数表里一个个遍历过去。虽然用bitset判断质数不会爆空间，但是由于数据范围太大，线性复杂度的预处理函数也占用了非常多的时间，最终以一次RE一次TE的失败而告终。\n\n回过头来看一下 $t$ 的大小，其实这题用最简单的 $O(\\sqrt{n})$ 的暴力法就可以完美解决。。。我裂开了\n\n## C. Omkar and Baseball\n\n又是一道看起来很难的水题。\n\n先画一些小序列找一下规律，可以发现，位置全错的一段序列重组一次就可以变为有序；如果在一段序列的中间只有一个元素的位置是对的，如果序列足够长的话至少需要两次；如果中间有多个分散的，也可以第一次将它们全部打乱，第二次直接排好。因此，对于一整段序列来说，重组次数一定不超过两次，其中0次的情况显然只有在已经有序的时候才符合，1次的情况是无序数列是连续的一段，其余情况都需要两次。\n\n## D. Omkar and Circle\n\n做完C以后说unrated了，时间也不早了，第二天还有考试，就去睡了。\n\n这个D题也不算难，画一个圈模拟一下可以发现，一圈上面取到的数一定是 $(n+1)/2$ 个，并且每个取到的元素之间都隔着一个不取的，也就是说只要把序列展开成 $[1,3,5,\\cdots ,n,2,4,6,\\cdots,n-1]$,然后用单调队列求出 $(n+1)/2$ 长度序列的最大元素和即可。\n\n最后用unsigned long long存答案。\n\n## E. Omkar and Last Floor\n\n看标签是尺取法，dp。有空仔细看一下。\n\n## F. Omkar and Modes\n\n连题解都看不明白。\n\n\n\n先放张图，E、F两题以后再补\n\n![200719CF655.jpg](https://i.loli.net/2020/07/19/LG8QrRlKepPOTFI.jpg)","tags":["CodeForces"]},{"title":"粗糙的顺序表","url":"/2020/07/08/Linear_List/","content":"\n\n数据结构复习，顺序表及其几个成员函数。\n\n<!--more-->\n\n**代码：**\n\n```c++\n#include <iostream>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nconst int maxn = 1000;\ntemplate <typename T>\nvoid swap(T &_a, T &_b)\n{\n    T temp = _a;\n    _a = _b;\n    _b = temp;\n}\ntemplate <typename T>\nint bin_search(T arr[], int l, int r, T x) //ascending\n{\n    int mid;\n    while (l <= r)\n    {\n        mid = (l + r) / 2;\n        if (x == arr[mid])\n            return mid;\n        else if (x < arr[mid])\n            r = mid - 1;\n        else\n            l = mid + 1;\n    }\n}\nclass Linear_List //ascending\n{\npublic:\n    int arr[maxn + 1], elenum;\n    void insert(int x, int pos)\n    {\n        elenum++;\n        for (int i = elenum; i > pos; --i)\n            arr[i] = arr[i - 1];\n        arr[pos] = x;\n    }\n    void show()\n    {\n        for (int i = 1; i <= elenum; ++i)\n            cout << arr[i] << ' ';\n        cout << endl;\n    }\n    void reverse()\n    {\n        for (int i = 1; i <= elenum / 2; ++i)\n            swap(arr[i], arr[elenum + 1 - i]);\n    }\n    int find(int x)\n    {\n        for (int i = 1; i <= elenum; ++i)\n            if (arr[i] == x)\n                return i;\n        return 0;\n    }\n    void _push_back(int x)\n    {\n        arr[++elenum] = x;\n    }\n    /*\n    void sort(int l, int r)\n    {\n        int mid = arr[(l + r) / 2], i = l, j = r;\n        do\n        {\n            while (arr[i] < mid)\n                i++;\n            while (arr[j] > mid)\n                j--;\n            if (i <= j)\n                swap(arr[i++], arr[j++]);\n        } while (i <= j);\n        if (l < j)\n            sort(l, j);\n        if (i < r)\n            sort(i, r);\n    }\n    */\n};\n```\n\n**成员函数递归调用似乎会造成程序运行时错误**，因此暂时无法实现sort函数，函数指针也无法解决这个问题，可能是因为编译器隐式的将在类内定义的成员函数当做内联函数。以后有空再来尝试解决这一问题。\n\n\n\n![奈芙莲.jpg](https://i.loli.net/2020/07/08/gHR8SmCohAFMnvT.jpg)\n\n（奈芙莲也很可爱","tags":["复习"]},{"title":"记一次神奇的错误","url":"/2020/06/10/20-06-error/","content":"\n\n\n前段时间hexo博客又出了一些问题，今天终于修好了。\n\n\n\n<!--more-->\n\n先上图\n\n![1.png](https://i.loli.net/2020/06/10/LaMEJYDvVG6Udy7.png)\n\n很神奇的错误，在网上找了一些解决方法都没有成功，比如控制面板的凭据管理、修改yml文件等。\n\n后来发现是GitHub的邮箱验证出了问题，重新验证了一下以后就好了。\n\n具体原因以后有空再研究一下。\n\n放一张可怕的图：\n\n![2.jpg](https://i.loli.net/2020/06/10/kdgDu3spEbe2CQv.jpg)","tags":["随笔"]},{"title":"2020-5，随便写一点","url":"/2020/05/05/2020-5/","content":"\n\n前几天打了个校赛成绩还可以，做一下总结顺便写点别的东西。\n\n<!--more-->\n\n这次比赛**B、D**水题，没什么好说的；\n\n**A**前缀和处理，这个数据显然不能暴力，但是做的时候第一时间却想到ST表结果没搞出来，后来树状数组过的，原理上差不多，就是稍微浪费了一点时间；\n\n**G**明显树状数组或者线段树，$\\le 10$ 看成 $\\lt 10$ 导致多了一些罚时；\n\n**C**虚树和点分治都不会，std没想到，本来想搜索试试看到数据范围放弃了，不过其实可以碰碰运气；\n\n**E**字典树最短路都很不熟练，看到直接跳了，尤其是字典树几乎已经忘记了，要再去看一看；\n\n**F**对于我这样的计算几何白痴来说过不了也一点都不意外；\n\n**H、I**都没什么想法，不会做也正常。\n\n总的来说会做的都过了，不会的也没骗到分，前段时间也没练题，CF的分也还是非常低，等这段时间考试什么的应付好又该好好搞一搞这些东西了。\n\n最近总是想思考一些事情，越思考又越不想思考下去，什么都想做，又什么都不想做，搞的很彷徨，不知道在干什么。好久没更博客了，接下来还是要多写点东西给自己一点目标。\n\n\n\n![001.jpg](https://i.loli.net/2020/05/05/bvXKsyZd83aQnhi.jpg)\n\n\n\n![002.jpg](https://i.loli.net/2020/05/05/4jzEUbRx67wOGtu.jpg)\n\n\n\n![003.jpg](https://i.loli.net/2020/05/05/6G97InpmXgPzuKr.jpg)\n\n\n\n放三张超好看的Tifa鼓励一下自己。","tags":["随笔"]},{"title":"iList v1.0.4","url":"/2020/03/23/iList_200323/","content":"\n更新图标，新增整点报时功能。\n\n<!--more-->\n\n**待实现的功能**\n\n- 定制DDL\n- 任务剩余时间提示\n- 永恒置顶模式\n- 小彩蛋\n\n随缘更新中\n\n*这次配一张更好看的图*\n\n![104.jpg](https://i.loli.net/2020/03/23/3lDXqzkIdjR45K2.jpg)\n\n","tags":["小工具"]},{"title":"Dijkstra算法","url":"/2020/03/19/Dijkstra/","content":"\n### 算法简介\n\nDijkstra算法可以用于计算正权图的单源最短路，它同时适用于有向图和无向图，在 $n$ 个顶点，$m$ 条边的图中朴素的Dijkstra算法时间复杂度 $O(n^2)$，堆优化后可以达到 $O(m\\log n)$（稀疏图）。\n\n<!--more-->\n\n### 思路\n\n与求最小生成树的Prim算法类似，从选取的原点开始，进行以下操作：\n\n1. 将已经经过的点看作一个集合（done数组）；\n2. 将除了原点之外所有点到原点的距离设置为无穷大，把原点加入集合；\n3. 对于一个新加入集合的点，遍历这个点连接的所有边，把与这些边相连的另一个顶点的距离更新；\n4. 在集合之外的所有点中找到路径最短的一个，把它加入集合，并重复步骤3，直到所有点都加入了集合。\n\n维基上的这个动图真是很形象了：\n\n![dijkstra.gif](https://i.loli.net/2020/03/19/2BtcSNAj1yo3fJT.gif)\n\n\n\n优化也和Prim算法类似，也是用一个堆，具体想法是这样的：找出未进入集合中的距离最近的点时可以将点和距离绑定，这样就能用一个堆来维护。\n\n### 代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 9, maxm = 2e5 + 9;\nconst int inf = 0x3f3f3f3f;\ntypedef vector<int> vi;\nstruct edge\n{\n    int from, to, dist;\n    edge(int u, int v, int d) : from(u), to(v), dist(d) {}\n};\nstruct HeapNode//适应STL的堆的排序方式\n{\n    int d, u;\n    bool operator<(const HeapNode &b) const\n    {\n        return d > b.d;\n    }\n};\nstruct dijkstra\n{\n    int n, m;\n    vector<edge> edg;\n    vi graph[maxn];\n    bool done[maxn];\n    int d[maxn], p[maxn];//p是最短路中的上一条弧\n    void init(int n)\n    {\n        this->n = n;\n        for (int i = 0; i <= n; ++i)\n            graph[i].clear();\n        edg.clear();\n    }\n    void add(int from, int to, int d)\n    {\n        edg.push_back(edge(from, to, d));\n        graph[from].push_back(edg.size() - 1);\n    }\n    void dij(int s)\n    {\n        priority_queue<HeapNode> pq;\n        for (int i = 0; i <= n; ++i)\n            d[i] = inf;\n        d[s] = 0;\n        memset(done, 0, sizeof(done));\n        pq.push((HeapNode){0, s});\n        while (!pq.empty())\n        {\n            HeapNode x = pq.top();\n            pq.pop();\n            int u = x.u;\n            if (done[u])//这个点在集合内了\n                continue;\n            done[u] = true;\n            for (int i = 0; i < graph[u].size(); ++i)\n            {\n                edge &e = edg[graph[u][i]];\n                if (d[e.to] > d[u] + e.dist)\n                {\n                    d[e.to] = d[u] + e.dist;\n                    p[e.to] = graph[u][i];\n                    pq.push((HeapNode){d[e.to], e.to});\n                }\n            }\n        }\n    }\n};\ndijkstra D;\nint main()\n{\n    int n, m, s;\n    scanf(\"%d%d%d\", &n, &m, &s);\n    D.init(n);\n    for (int i = 1; i <= m; ++i)\n    {\n        int u, v, w;\n        scanf(\"%d%d%d\", &u, &v, &w);\n        D.add(u, v, w);\n    }\n    D.dij(s);\n    for (int i = 1; i <= n; ++i)\n        printf(\"%d \", D.d[i]);\n    return 0;\n}\n```\n\n### 后记\n\n对于这个算法我的理解还不是很透彻，今后想的更清楚了再回来补。\n\n![dij2.jpg](https://i.loli.net/2020/03/19/4m6sByMfEv531JW.jpg)","tags":["图论"]},{"title":"iList初代","url":"/2020/03/17/iList_200317/","content":"\n**最初的想法**\n\n总觉得之前用过的清单、日程表之类的软件都不太好用，它们的主要缺陷是提醒能力太差，华而不实的功能太多而真正对我有用的功能却太少。因此我认为还是需要写一个适合我的日程表，即iList。\n\n<!--more-->\n\n**iList v1.0.0**\n\n- 显示当前时间\n- 7个任务槽\n- 任务完成提示随已完成的任务数量改变\n- 隐藏关闭按钮，防止误关\n\n**待实现的功能**\n\n- 定制DDL\n- 任务剩余时间提示\n- 整点报时\n\n随缘更新中\n\n![coooool](https://i.loli.net/2020/03/19/wioxGYkAfyPuQvB.jpg)","tags":["小工具"]},{"title":"快读模板","url":"/2020/03/16/fstread/","content":"\n\n### 快读\n\n据说 `cin` 大约能支持 $1,000,000$ 个数据的输入，`scanf` 的效率大约是 `cin` 的十倍，而快读大约是 `scanf` 的十倍。如果需要更快就要用 `fread`。\n\n<!--more-->\n\n### 快读\n\n```c++\ninline int read(){\n    int data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch)){\n   \tif (ch == '-')\n   \t    f = -1;\n   \tch = getchar();\n    }\n    while (isdigit(ch)){\n   \t    data = (data << 3) + (data << 1) + ch - '0';\n   \t    ch = getchar();\n    }\n    return f * data;\n}\n```\n\n据说 `isdigit` 比判断ASCII码来得快。\n\n**fread版**\n\n 版本1：\n\n```c++\nstruct FastIO {\n    static const int S = 1e7;\n    int wpos;\n    char wbuf[S];\n    FastIO() : wpos(0) {}\n    inline int xchar() {\n        static char buf[S];\n        static int len = 0, pos = 0;\n        if (pos == len)\n            pos = 0, len = fread(buf, 1, S, stdin);\n        if (pos == len) exit(0);\n        return buf[pos++];\n    }\n    inline int xuint() {\n        int c = xchar(), x = 0;\n        while (c <= 32) c = xchar();\n        for (; '0' <= c && c <= '9'; c = xchar()) x = x * 10 + c - '0';\n        return x;\n    }\n    inline int xint()\n    {\n        int s = 1, c = xchar(), x = 0;\n        while (c <= 32) c = xchar();\n        if (c == '-') s = -1, c = xchar();\n        for (; '0' <= c && c <= '9'; c = xchar()) x = x * 10 + c - '0';\n        return x * s;\n    }\n    inline void xstring(char *s)\n    {\n        int c = xchar();\n        while (c <= 32) c = xchar();\n        for (; c > 32; c = xchar()) * s++ = c;\n        *s = 0;\n    }\n    inline void wchar(int x)\n    {\n        if (wpos == S) fwrite(wbuf, 1, S, stdout), wpos = 0;\n        wbuf[wpos++] = x;\n    }\n    inline void wint(ll x)\n    {\n        if (x < 0) wchar('-'), x = -x;\n        char s[24];\n        int n = 0;\n        while (x || !n) s[n++] = '0' + x % 10, x /= 10;\n        while (n--) wchar(s[n]);\n        wchar('\\n');\n    }\n    inline void wstring(const char *s)\n    {\n        while (*s) wchar(*s++);\n    }\n    ~FastIO()\n    {\n        if (wpos) fwrite(wbuf, 1, wpos, stdout), wpos = 0;\n    }\n} io;\n```\n\n\n\n版本2：\n\n```c++\nstruct ios {\n    inline char read(){\n        static const int IN_LEN=1<<18|1;\n        static char buf[IN_LEN],*s,*t;\n        return (s==t)&&(t=(s=buf)+fread(buf,1,IN_LEN,stdin)),s==t?-1:*s++;\n    }\n\n    template <typename _Tp> inline ios & operator >> (_Tp&x){\n        static char c11,boo;\n        for(c11=read(),boo=0;!isdigit(c11);c11=read()){\n            if(c11==-1)return *this;\n            boo|=c11=='-';\n        }\n        for(x=0;isdigit(c11);c11=read())x=x*10+(c11^'0');\n        boo&&(x=-x);\n        return *this;\n    }\n} io;\n\nint main(){\n    io>>a>>b;\n}\n```\n\n\n\n版本3？？？：\n\n```c++\n#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\nchar buf[1<<23],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;\n\ninline int rd() {\n    int x=0,f=1;char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}\n    while(isdigit(ch)) x=x*10+(ch^48),ch=getchar();\n    return x*f;\n}\nvoid print(long long x) {\n    if(x>9) print(x/10);\n    *O++=x%10+'0';\n}\nfwrite(obuf,O-obuf,1,stdout);\n```\n\n\n\n### 快输\n\n版本1（递归）：\n\n```c++\n#define G(a) putchar(a+48)\ninline void write(int s){\n    if (s<0) G(-3),s=-s;\n    if (s>9) write(s/10);\n    G(s%10);\n}\n```\n\n\n\n版本2（循环）：\n\n```c++\n#define G(a) putchar(a+48)\ninline void write(int s){\n    int t=0,a[40];\n    if (s<0) G(-3),s=-s;\n    do {\n        a[++t]=s%10;\n    } while (t/=10);\n    while(t) \n        G(a[t--]);\n    putchar('');//看题目需要，可以加入\\n进行换行或者加入空格 \n}\n```\n\n\n\n当时SM.MS上不去所以放到了CSDN上，现在好了\n\n![fstread.jpg](https://i.loli.net/2020/07/20/UAnaQSyLIRkYl26.jpg)","tags":["模板"]},{"title":"最小生成树(Prim&Kruskal)","url":"/2020/03/13/Minimum_Spanning_Tree/","content":"\n# 简介：\n\n生成树（Spanning Tree）是连通图的一个极小连通子图，而最小生成树（Minimal Spanning Tree,MST）就是权值最小的生成树。最小生成树一般可以用Prim算法、Kruskal算法或[Borůvka算法](https://www.luogu.com.cn/blog/Tweetuzki/solution-p3366)求出。这里只记录前两种算法。[模板题：洛谷P3366](https://www.luogu.com.cn/problem/P3366)\n\n<!--more-->\n\n## 1.Prim\n\nPrim算法基于一种贪心的策略，即对于连通图的任意一个顶点，从该顶点出发的所有边中最短的一条一定属于最小生成树。这个策略显然是正确的，因为这条被选中的边的长度是该顶点和这张图除去该顶点的最小生成树的最小距离。\n\n具体实现的过程是先用邻接矩阵存边，然后初始化距离为最大值。任选一个顶点作为根，找到从该顶点发出的最短边并把这条边的另一个顶点并入最小生成树。然后重复寻找连接已有的最小生成树和其它顶点的最短边，依次选取新的顶点，直到所有的顶点都被选取。\n\n如果每次查找最短边都全部遍历一遍，时间复杂度是 $O(nm)$ 级别的，但是可以使用一个堆来存储已经走过的边的权值，避免重复计算，使时间复杂度降低到 $O(m\\log n)$。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, a, b) for (i = a; i <= b; ++i)\n#define drep(i, a, b) for (i = a; i >= b; --i)\ntypedef pair<int, int> pii;\nconst int maxn = 2e5 + 9;\nint i, k, n, m, cnt, sum, dis[10005], vis[10005];\nvector<int> edg[maxn], wgt[maxn];\ninline void add(int u, int v, int w)\n{\n    edg[u].push_back(v);\n    wgt[u].push_back(w);\n}\npriority_queue<pii, vector<pii>, greater<pii> > q;\ninline void prim()\n{\n    memset(dis, 127, sizeof(dis));\n    dis[1] = 0;\n    q.push(make_pair(dis[1], 1));\n    while (!q.empty() && cnt < n)\n    {\n        int d = q.top().first, u = q.top().second;\n        q.pop();\n        if (vis[u])\n            continue;\n        cnt++;\n        sum += d;\n        vis[u] = 1;\n        rep(i, 0, edg[u].size() - 1) if (wgt[u][i] < dis[edg[u][i]])\n        {\n            dis[edg[u][i]] = wgt[u][i];\n            q.push(make_pair(dis[edg[u][i]], edg[u][i]));\n        }\n    }\n}\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    rep(i, 1, m)\n    {\n        int a, b, c;\n        scanf(\"%d%d%d\", &a, &b, &c);\n        add(a, b, c);\n        add(b, a, c);\n    }\n    prim();\n    if (cnt == n) printf(\"%d\\n\", sum);\n    else puts(\"orz\");\n    return 0;\n}\n```\n\n\n\n## 2.Kruskal\n\nKruskal算法的策略也是依次选取最短边，但是它直接对边的长度进行排序，并使用并查集来判断是否需要选取这条边，如果这条边的两个顶点已经拥有公共祖先，说明这两个顶点已经存在于当前的最小生成树，所以不选取，否则就选取并且合并公共祖先。当所有的顶点拥有共同的公共祖先时最小生成树也就产生了。该算法的时间复杂度是 $O(m\\log m)$。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, a, b) for (i = a; i <= b; ++i)\n#define drep(i, a, b) for (i = a; i >= b; --i)\ntypedef pair<int, int> pii;\nconst int maxn = 2e5 + 9;\nconst int inf = 0x3f3f3f3f;\nstruct edg\n{\n    int x, y, w;\n    bool operator<(const edg &b) const\n    {\n        return w < b.w;\n    }\n};\nint n, m, father[maxn], i, ans;\nedg e[maxn];\nint find(int x)\n{\n    int t = x;\n    while (father[t] != t)\n        t = father[t];\n    father[x] = t;\n    return t;\n}\nvoid join(int x, int y)\n{\n    int tx = find(x), ty = find(y);\n    if (tx != ty)\n        father[tx] = ty;\n}\nint kruskal()\n{\n    rep(i, 1, n) father[i] = i;\n    rep(i, 1, m)\n    {\n        edg t = e[i];\n        if (find(t.x) == find(t.y))\n            continue;\n        join(t.x, t.y);\n        ans += t.w;\n    }\n    return ans;\n}\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    rep(i, 1, m) scanf(\"%d%d%d\", &e[i].x, &e[i].y, &e[i].w);\n    sort(e + 1, e + m + 1);\n    printf(\"%d\\n\", kruskal());\n    return 0;\n}\n```\n\n\n\nPrim算法更适合求稠密图的最小生成树，而Kruskal算法则更适合求稀疏图的最小生成树。\n\n![MST.jpg](https://i.loli.net/2020/03/13/O5gJTyZhsNrR12A.jpg)","tags":["图论"]},{"title":"欧拉函数","url":"/2020/02/28/Euler_Function/","content":"\n# 简介：\n\n欧拉函数 $\\varphi (x)$ 表示在不大于 $x$ 的正整数中与 $x$ 互质的数的个数，规定 $\\varphi (1)=1$。 \n\n<!--more-->\n\n# 推导：\n\n## 1.分解质因数：\n\n若正整数 $n$ 的唯一分解式 $n=p_1^{a_1}p_2^{a_2}p_3^{a_3} \\cdots \\,p_k^{a_k}$，根据乘法原理，$n$ 的正约数个数为 $\\prod_{i=1}^k(a_i+1)=(a_1+1)(a_2+1)\\cdots (a_k+1)$。\n\n得到正整数 $n$ 的唯一分解式是算出 $\\varphi(n)$ 的前提条件。\n\n## 2.特殊情形\n\n1.若 $n$ 是质数，显然 $\\varphi(n)=n-1$。\n\n2.若 $n=p^k$，$\\varphi(n)=(p-1)\\times p^{k-1}$，这一点也容易发现，因为在 $[1,n]$ 中 $p$ 的倍数一共有 $p^{k-1}$ 个，只有这些数是和 $n$ 不互质的。\n\n3.若 $p,q$ 互质，有 $\\varphi(p\\times q)=\\varphi(p)\\times\\varphi(q)$，即欧拉函数是一个**积性函数**，这个性质需要用中国剩余定理和完全剩余系才能证明。\n\n## 3.一般情况\n\n根据容斥原理，可以先得到一个暴力的公式：$\\displaystyle \\varphi(n)=\\sum_{S\\subseteq\\{p_1,p_2,\\cdots p_n\\}}(-1)^{|S|}\\frac{n}{\\prod_{p_i\\in S}p_i}$，这个式子的计算原理就是在 $n$ 中先减去同时是一个素因子的倍数的个数，再加上同时是两个素因子的个数…以此类推，很明显用这个东西去做题是不现实的，而欧拉函数还有一个更好的计算方式：\n\n结合几种特殊情形，可以推导出一般情况的欧拉函数计算方法，$\\varphi(n)=\\prod_{i=1}^k\\varphi(p_i^{a_i})$（3），而\n\n$\\varphi(p_i^{a_i})=p_i^{a_i-1}\\times (p_i-1)=p_i^{a_i}(1-\\frac{1}{p_i})$（2），这样乘起来以后得到 $\\varphi(n)=n\\prod_{i=1}^k(1-\\frac 1{p_i})$，这个公式就简洁了很多。根据这个公式又可以得到以下的一个小结论：\n\n对于质数 $p$，若 $p$ 是 $n$ 的约数，有 $\\varphi(n\\times p)=\\varphi(n)\\times p$，因为在 $\\varphi(n)$ 的计算中已经有了 $1-\\frac 1p$，所以直接乘在外面就可以了；若 $p$ 不是 $n$ 的约数，有 $\\varphi(n\\times p)=\\varphi(n)\\times (p-1)$（特殊情形3）。\n\n# 计算\n\n## 单个欧拉函数的求解\n\n分解质因数，然后用上面的公式求解，时间复杂度 $O(k\\sqrt n)$。\n\n~~还要再快的话还有Pollard Rho算法。~~\n\n## 一系列数的欧拉函数的求解\n\n先放一个紫书上时间复杂度 $O(n\\log \\log n)$ 的代码：\n\n```c++\nvoid init(int n){\n    for (int i = 2; i <= n; ++i)\n        phi[i] = 0;\n    phi[1] = 1;\n    for (int i = 2; i <= n; ++i){\n        if (!phi[i])\n            for (int j = i; j <= n; j += i){\n                if (!phi[j])\n                    phi[j] = j;\n                phi[j] = phi[j] / i * (i - 1);\n            }\n    }\n}\n```\n\n这种做法的原理和埃氏筛相似，每当遇到一个质数就去找它的所有倍数，如果这个数之前已经被其他的质数经过（即已经乘过计算公式的第一项，这个数的本体），就直接乘 $1-\\frac 1p$ 这一项，否则就先乘一个本体再这样处理，全部完成后的效果就相当于用公式算一遍。\n\n而根据欧拉筛的原理，结合由公式得出的小结论，还可以得到线性复杂度的求解方法：\n\n```c++\nbool is_prime[maxn];//或者bitset\nvector<int> vp;\nint phi[maxn];\nvoid init(int n){\n    int tmp;\n    for (int i = 2; i <= n; ++i)\n        is_prime[i] = true;\n    phi[1] = 1;\n    for (int i = 2; i <= n; ++i){//线性筛\n        if (is_prime[i])\n            phi[i] = i - 1, vp.push_back(i);\n        for (int j = 0; j < vp.size(); ++j){\n            tmp = i * vp[j];\n            if (tmp > n)\n                break;\n            is_prime[tmp] = false;\n            if (i % vp[j])//结论\n                phi[tmp] = phi[i] * (vp[j] - 1);\n            else{\n                phi[tmp] = phi[i] * vp[j];\n                break;\n            }\n        }\n    }\n}\n```\n\n就写到这里吧\n\n![ee](https://i.loli.net/2020/02/28/nNbpRHGS6Z4c2BM.jpg)","tags":["数论"]},{"title":"扩展欧几里得算法","url":"/2020/02/25/Ex_GCD/","content":"\n\n扩展欧几里得算法可以找出一对整数 $(x,y)$，使得 $ax+by=\\gcd(a,b)$。\n\n<!--more-->\n\n首先放上欧几里得算法，就是小学数学中的辗转相除法求最大公约数：\n\n```c++\nint gcd(int a,int b){\n    return !b ? a : gcd(b, a % b);\n}\n```\n\n该算法的正确性是显而易见的。利用欧几里得算法可以在 $O(\\log n)$ 的时间中算出最大公约数。\n\n由裴蜀定理，可以得知该不定方程是有解的。\n\n下面来对式子 $ax+by=\\gcd(a,b)$ 做一点变形：$ax+by=\\gcd(a,b)=\\gcd(b,a\\mod b)$，有 $bx+(a\\mod b)y=bx+(a-\\lfloor \\frac a b \\rfloor b)y=\\gcd(b,a\\mod b)$，即 $ay+b(x-\\lfloor \\frac a b \\rfloor y)=\\gcd(b,a\\mod b)$，这意味着可以递归求解 $(x,y)$。这个递归过程和欧几里得算法的递归是一样的，在递归边界 $b=0$ 处，可以发现 $\\gcd(a,0)=a$，所以 $x=1,y=0$。\n\n以上过程可以得到这样的代码：（$d$ 是最大公约数）\n\n```c++\nvoid exgcd(int a, int b, int &d, int &x, int &y){\n    if (b == 0)\n        d = a, x = 1, y = 0;\n    else{\n        exgcd(b, a % b, d, y, x);\n        y -= x * (a / b);\n    }\n}\n```\n\n这就是扩展欧几里得算法，从代码中可以看到它包含了欧几里得算法，显然复杂度也没有改变。\n\n使用该算法可以解决 $ax+by=c$ 的整数解问题，首先判断 $\\gcd(a,b)$ 能否整除 $c$，如果不能那么一定不会有整数解，如果能整除就用exgcd算。\n\n**简单的例题：[洛谷P1082](https://www.luogu.com.cn/problem/P1082)**\n\n求关于 $x$ 的同余方程 $ax\\equiv 1(\\mod b)$ 的最小正整数解。\n\n对方程稍作变形，就可以利用exgcd了。由 $ax\\equiv 1(\\mod b)$ 可得 $ax-by=1$ ，由于 $y$ 的正负并没有影响，故等价于 $ax+by=1$，那么需要使 $\\gcd(a,b)=1$，即两数互质，这就是答案存在的前提，题目也已经保证了这一点。到这一步后就可以直接用了，最后得出的 $x$ 就是一个整数解，但它不一定是最小的，甚至不一定是整数，所以还需要再取模处理一下。\n\n这样解出的 $x$ 就是 $a$ 在模 $b$ 意义下的乘法逆元。也就是说，在模 $b$ 意义下如果除以 $a$ 很麻烦，那么可以乘上 $x$ 起到同样的效果。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nvoid exgcd(int a, int b, int &d, int &x, int &y)\n{\n    if (b == 0)\n        d = a, x = 1, y = 0;\n    else\n    {\n        exgcd(b, a % b, d, y, x);\n        y -= x * (a / b);\n    }\n}\nint main()\n{\n    int a, b, d, x, y;\n    cin >> a >> b;\n    exgcd(a, b, d, x, y);\n    cout << (x % b + b) % b;\n    return 0;\n}\n```\n\n","tags":["数论"]},{"title":"2020寒假总结","url":"/2020/02/24/2020-2/","content":"\n随便写了一点\n\n<!--more-->\n\n\n今年1月19号晚上才到家，所以这个寒假对我来说差不多1月20号才开始，到2月23号我在洛谷上做了80多题，加上其它几个网站零零碎碎的几道，总题量大概有90题，大部分是洛谷黄题难度的，也有30%左右的题是绿题及以上的难度，主要还是打基础，学一些搜索、DP、数据结构、数论和图论的基础，以后就要逐渐深入学习这些内容了。今天我的洛谷咕值正好更新了，练习分59，总排名1.08k，以后很长一段时间可能都不会升高了，也算是寒假的一个小小成果吧。今后不会每题都写题解了，但是题解还是要写一些，知识点方面的文章以后倒是要多更一些，写这些东西对知识的掌握和巩固还是很有帮助的。最后还有点小遗憾，CF没能打上1500分，主要还是自己太菜了，要是两场Edu不崩的话还是有希望的，希望3月能打上1500吧。\n\n![ozc02k63.png](https://i.loli.net/2020/02/24/RSGKYXz6nTai9mQ.png)\n\n","tags":["2020寒假"]},{"title":"洛谷P1313题解","url":"/2020/02/23/P1313-Solution/","content":"\n### 链接：[P1313](https://www.luogu.com.cn/problem/P1313)   \n<!--more-->\n\n# 题解：\n\n根据二项式定理，$(ax+by)^k$ 的第 $n$ 项是 $\\text{C}_k^{n-1}(ax)^{n-1}(by)^{k-n+1}$，所以这里的系数是 $\\text{C}_k^{n-1}a^{n-1}b^{k-n+1}$，其中 $\\text{C}_k^{n-1}$ 正好是杨辉三角中的一项，而 $a^{n-1}b^{k-n+1}$ 可以用快速幂求出，那么只要把杨辉三角相应的一行推出来，问题就解决了。\n\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nconst int MOD = 10007;\nconst int maxn = 1e4 + 1;\nll f[maxn][maxn];\nll ksm(ll base, ll b) \n{\n    ll ans = 1; \n    while (b)         \n    {\n        if (b & 1)      \n        {\n            ans *= base;\n            ans %= MOD;\n        }\n        base *= base;\n        base %= MOD;\n        b >>= 1;      \n    }\n    return ans;\n}\nint main()\n{\n    ll a, b, k, n, m;\n    scanf(\"%lld%lld%lld%lld%lld\", &a, &b, &k, &n, &m);\n    f[1][1] = 1;\n    for (int i = 2; i <= k + 1; i++)\n        for (int j = 1; j <= i; j++)\n            f[i][j] = (f[i - 1][j - 1] + f[i - 1][j]) % MOD;//杨辉三角\n    ll ans = ((f[k + 1][k - n + 1] * ksm(a, n)) % MOD) * ksm(b, m) % MOD;\n    printf(\"%lld\", ans);\n    return 0;\n}\n```\n\n","tags":["2020寒假","洛谷"]},{"title":"洛谷P6102题解","url":"/2020/02/23/P6102-Solution/","content":"\n### 链接：[P6102](https://www.luogu.com.cn/problem/P6102)   \n<!--more-->\n\n# 题解：\n\n最初的想法是打一个 $O(n^4)$ 的大暴力，当然只能拿15分，数据范围显示只有优于 $O(n^2)$ 的算法才有可能过这道题。通过手动模拟可以找到这道题的一些规律，只有 $a|b=1,c\\&d=0$ 或 $a|b=0,c\\&d=1$ 的组合才会对最终答案产生影响，而每个数都不大于 $2^{32}$，所以可以枚举每个数的每一个二进制位，在线性的复杂度完成本题。\n\n找到正确复杂度的方法后考虑实现过程：不同的二进制位相互没有任何关系，所以可以用一个数组存储；对于每一位， $a|b$ 和 $c\\&d$ 均有 $n^2$ 种组合方式，其中 $a|b=1$ 的个数是这一位上1的个数的平方，而 $c\\&d=0$ 的个数是这一位上0的个数的平方，所以统计每一位上1的个数就可以算出这一位对最后答案的贡献。最后将每一位左移相应的位数再全部加起来即可。\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\ninline uint read()\n{\n    uint data = 0;\n    char ch = getchar();\n    while (ch < '0' || ch > '9')\n        ch = getchar();\n    while (ch >= '0' && ch <= '9')\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    return data;\n}\nuint w[33];\nint main()\n{\n    uint n = read(), x, ans = 0;\n    for (uint i = 0; i < n; ++i)\n    {\n        x = read();\n        for (int j = 0; j < 32; ++j)\n            if ((x >> j) & 1)\n                w[j]++;\n    }\n    for (uint i = 0; i < 32; ++i)\n    {\n        uint a = w[i] * w[i], o = (n - w[i]) * (n - w[i]);\n        ans += (a * o + (n * n - a) * (n * n - o)) << i;\n    }\n    printf(\"%u\\n\", ans);\n    return 0;\n}\n```\n\n","tags":["2020寒假","洛谷"]},{"title":"洛谷P1330题解","url":"/2020/02/22/P1330-Solution/","content":"\n### 链接：[P1330](https://www.luogu.com.cn/problem/P1330)   \n<!--more-->\n\n# 题解：\n\n为了使图的每一条边都只有一个点被封锁，可以考虑对所有点进行染色，初始状态下所有点都是没有颜色的，因此color数组所有元素初始化为-1，然后对每个没有颜色的点进行DFS，由于是无向图，所以一次DFS后可以把第一个点所在的极大联通子图完全染上色。在染色过程中，如果遇到两个端点颜色相同的情况，直接判定为Impossible，否则就按照端点不同的颜色一直染下去。在一个极大联通子图完成染色后，统计其两种颜色分别占有的点数，取小的加进ans，然后重置两种颜色的点数，给下一个极大联通子图染色。这种做法每条边和每个点都会经过一次，时间复杂度 $O(n+m)$。\n\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\ninline int read()\n{\n    int data = 0, f = 1;\n    char ch = getchar();\n    while (ch < '0' || ch > '9')\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (ch >= '0' && ch <= '9')\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    return f * data;\n}\nconst int maxn = 1e4 + 9;\nint color[10001], cnt[2];\nvector<int> v[maxn];\nint dfs(int x)\n{\n    for (int i = 0; i < v[x].size(); ++i)\n    {\n        int t = v[x][i];\n        if (color[t] == -1)\n        {\n            color[t] = color[x] ? 0 : 1;\n            cnt[color[t]]++;\n            dfs(t);\n        }\n        else if (color[t] == color[x])\n        {\n            puts(\"Impossible\");\n            exit(0);\n        }\n    }\n    return min(cnt[0], cnt[1] + 1);//最开始的点是1也要算进去\n}\nint main()\n{\n    int p = read(), m = read(), ans = 0;\n    for (int i = 1; i <= m; ++i)\n    {\n        int u = read(), w = read();\n        v[u].push_back(w);\n        v[w].push_back(u);\n    }\n    memset(color, -1, sizeof(int) * (p + 1));\n    for (int i = 1; i <= p; ++i)\n    {\n        cnt[0] = cnt[1] = 0;\n        if (color[i] == -1)\n        {\n            color[i] = 1;\n            ans += dfs(i);\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n```\n\n","tags":["2020寒假","洛谷"]},{"title":"洛谷P6103题解","url":"/2020/02/21/P6103-Solution/","content":"\n### 链接：[P6103](https://www.luogu.com.cn/problem/P6103)   \n<!--more-->\n\n# 题解：\n\n很明显这是一道DP题，并且对 $2^{64}$ 取模也就相当于用unsigned long long保存数据直接算，但是状态转移方程的设计很麻烦，因为有以下这些复杂的转换关系：\n\n- 语句(sentc) + 程序片段(ans) = 程序片段(ans)；\n\n- 程序片段(ans) + 2 = 语句块(blk)；\n\n- 语句块(blk) = 语句(sentc)；\n\n- 语句块(blk) +2 或 +4 是函数(func)；\n\n- 函数(func) +4 还是函数(func)；\n\n- 值(val) +2 还是值(val)，值(val) + 1 = 语句(sentc)；\n\n- 语句块(blk)是语句(sentc)，但语句(sentc)不是语句块(blk)；\n\n- 函数(func)都是值(val)，但值(val)不一定是函数(func)。\n\n所以可以得到以下这些递推式：\n\n- $blk_i=ans_{i-2}$\n\n- $func_i=func_{i-2}+blk_{i-2}+blk_{i-4}$\n\n- $val_i=val_{i-2}+func_i$\n\n- $sentc_i = val_{i-1} + blk_i$\n\n- $ans_i=\\sum_{k=0}^{i-1} {(ans_k\\times sentc_{i-k})}$\n\n  \n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nconst int maxn = 10009;\null n, sentc[maxn], ans[maxn], blk[maxn], func[maxn], val[maxn];\nint main()\n{\n    cin >> n;\n    sentc[1] = ans[0] = ans[1] = 1;\n    for (int i = 2; i <= n; ++i)\n    {\n        blk[i] += ans[i - 2];\n        if (i >= 4)\n            func[i] += blk[i - 4];\n        func[i] += blk[i - 2] + func[i - 2];\n        val[i] += val[i - 2] + func[i];\n        sentc[i] += val[i - 1] + blk[i];\n        for (int j = 0; j <= i; ++j)\n            ans[i] += ans[j] * sentc[i - j];\n    }\n    cout << ans[n] << endl;\n    return 0;\n}\n```\n\n","tags":["2020寒假","洛谷"]},{"title":"UVa10129题解","url":"/2020/02/21/UVa10129-Solution/","content":"\n### 链接：[UVA10129](https://www.luogu.com.cn/problem/UVA10129)\n<!--more-->\n\n# 题解：\n\n把每个单词看作一条有向边，第一个字母是起点，最后一个字母是终点，这个问题就转化为一个求欧拉回路的问题。如果这个图不是联通的，显然是不行的；如果联通，统计26个字母各自的入度和出度，如果所有点各自的出度和入度均相等或者有一个出度比入度多1，另一个出度比入度少1则可以形成欧拉回路，否则也不行。\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nstring s;\nint graph[28][28], in[28], out[28], vis[28];\nvoid dfs(int u)\n{\n    vis[u] = 0;\n    for (int i = 1; i <= 26; ++i)\n        if (graph[u][i] && vis[i])\n            dfs(i);\n}\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    int T;\n    cin >> T;\n    while (T--)\n    {\n        bool flag = true;\n        int n, u, v, incnt = 0, outcnt = 0;\n        memset(vis, 0, sizeof(vis));\n        memset(graph, 0, sizeof(graph));\n        memset(in, 0, sizeof(in));\n        memset(out, 0, sizeof(out));\n        cin >> n;\n        for (int i = 0; i < n; ++i)\n        {\n            cin >> s;\n            u = s[0] - 'a' + 1;\n            v = s[s.length() - 1] - 'a' + 1;\n            graph[u][v]++, graph[v][u]++, out[u]++, in[v]++;\n            vis[u] = vis[v] = 1;\n        }\n        dfs(u);\n        for (int i = 1; i <= 26; ++i)\n        {\n            if (vis[i])\n            {\n                flag = false;\n                break;\n            }\n            if (in[i] != out[i])\n            {\n                if (in[i] - out[i] == 1)\n                    incnt++;\n                else if (out[i] - in[i] == 1)\n                    outcnt++;\n                else\n                {\n                    flag = false;\n                    break;\n                }\n            }\n        }\n        if ((incnt == 1 && outcnt == 0) || (incnt == 0 && outcnt == 1))   \n            flag = false;\n        if (flag)\n            puts(\"Ordering is possible.\");\n        else\n            puts(\"The door cannot be opened.\");\n    }\n    return 0;\n}\n```\n\n","tags":["2020寒假","UVa"]},{"title":"洛谷P1095题解","url":"/2020/02/20/P1095-Solution/","content":"\n### 链接：[P1095](https://www.luogu.com.cn/problem/P1095)\n<!--more-->\n\n# 题解：\n\n这题理论上存在 $O(1)$ 的做法，因为每过7秒是一个周期，但是分类讨论非常复杂，我试着写了150行左右，还存在一些问题需要调试，但是其实并没有必要写这么多的代码，因为 $O(n)$ 的做法也是完全可行的，只需要对时间进行动态规划，每次在跑步和闪现中选择最优的一种，最终如果能到达直接输出时间，如果不能到就输出最大距离。\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nint main()\n{\n    int m, s, t, s1 = 0, s2 = 0;\n    scanf(\"%d%d%d\", &m, &s, &t);\n    for (int i = 1; i <= t; i++)\n    {\n        s1 += 17;\n        if (m >= 10)\n        {\n            s2 += 60;\n            m -= 10;\n        }\n        else\n            m += 4;\n        s1 = max(s1, s2);\n        if (s1 >= s)\n        {\n            printf(\"Yes\\n%d\", i);\n            return 0;\n        }\n    }\n    printf(\"No\\n%d\", s1);\n    return 0;\n}\n```\n\n","tags":["2020寒假","洛谷"]},{"title":"洛谷P1736题解","url":"/2020/02/20/P1736-Solution/","content":"\n### 链接：[P1736](https://www.luogu.com.cn/problem/P1736)\n<!--more-->\n\n# 题解：\n\n题目要求在一个方形区域中找到一个最大的只有一条对角线上全是1的正方形，所以可以考虑对两种方向的对角线分别进行一次DP，分别找到两种的最大值。一次DP时，$f_{i,j}$ 的值由其左/右侧、上方和斜上方的状态决定。\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nconst int maxn = 2509;\ninline int read()\n{\n    int data = 0, f = 1;\n    char ch = getchar();\n    while (ch < '0' || ch > '9')\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (ch >= '0' && ch <= '9')\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    return f * data;\n}\ninline int _min(int a, int b, int c)\n{\n    return a > b ? b > c ? c : b : a > c ? c : a;\n}\nint a[maxn][maxn], f[maxn][maxn], s1[maxn][maxn], s2[maxn][maxn];\nint main()\n{\n    int n = read(), m = read(), ans = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        for (int j = 1; j <= m; ++j)\n        {\n            a[i][j] = read();\n            if (a[i][j] == 0)\n            {\n                s1[i][j] = s1[i][j - 1] + 1;\n                s2[i][j] = s2[i - 1][j] + 1;\n            }\n            else\n                f[i][j] = _min(f[i - 1][j - 1], s1[i][j - 1], s2[i - 1][j]) + 1;\n            ans = max(ans, f[i][j]);\n        }\n    }\n    memset(f, 0, sizeof(f));\n    memset(s1, 0, sizeof(s1)); \n    memset(s2, 0, sizeof(s2));\n    for (int i = 1; i <= n; ++i)\n    {\n        for (int j = m; j >= 1; --j)\n        {\n            if (a[i][j] == 0)\n            {\n                s1[i][j] = s1[i][j + 1] + 1;\n                s2[i][j] = s2[i - 1][j] + 1;\n            }\n            else\n                f[i][j] = _min(f[i - 1][j + 1], s1[i][j + 1], s2[i - 1][j]) + 1;\n            ans = max(ans, f[i][j]);\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n```\n\n\n","tags":["2020寒假","洛谷"]},{"title":"洛谷P1363题解","url":"/2020/02/19/P1363-Solution/","content":"\n### 链接：[P1363](https://www.luogu.com.cn/problem/P1363)   \n<!--more-->\n\n# 题解：\n\n这题是 [CF196B](http://codeforces.com/problemset/problem/196/B) 的多组数据版，思路是一样的。由于迷宫是无限大的，走出一个区域走到另一个全等的区域就相当于一次取模的运算。如果有一个点被走过了两次，就说明是可以走向无限远处的。所以可以用DFS，一直不停搜下去，只到搜完所有的路或者找到一种走向无限远的方法。\n\n具体实现时，先找到起点并将起点也变成能通过的路，然后全部加上 $m\\times n$ 以防在DFS时越界，DFS时每次遍历的x和y都不一样，所以一旦找到一个被标记过的而且和自己不一样的点就说明可以走向无限远了。\n\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nconst int maxn = 1509;\nconst int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};\nint n, m, f[maxn][maxn][2];\nstring s[maxn];\nbool flag;\nvoid dfs(int x, int y)\n{\n    if (!flag)\n        return;\n    else if (f[x % n][y % m][0] == -1 && f[x % n][y % m][1] == -1)\n    {\n        f[x % n][y % m][0] = x;\n        f[x % n][y % m][1] = y;\n    }\n    else if (f[x % n][y % m][0] != x || f[x % n][y % m][1] != y)\n    {\n        flag = false;\n        puts(\"Yes\");\n        return;\n    }\n    else\n        return;\n    for (int i = 0; i < 4; ++i)\n    {\n        int x1 = x + dx[i], y1 = y + dy[i];\n        if (s[x1 % n][y1 % m] == '.')\n            dfs(x1, y1);\n    }\n}\nint main()\n{\n    while (scanf(\"%d%d\", &n, &m) == 2)\n    {\n        int x, y;\n        for (int i = 0; i < n; ++i)\n        {\n            cin >> s[i];\n            for (int j = 0; j < m; ++j)\n            {\n                if (s[i][j] == 'S')\n                {\n                    s[i][j] = '.';\n                    x = i + n * m;\n                    y = j + n * m;\n                }\n            }\n        }\n        flag = true;\n        memset(f, -1, sizeof(f));\n        dfs(x, y);\n        if (flag)\n            puts(\"No\");\n    }\n    return 0;\n}\n\n```\n\n","tags":["2020寒假","洛谷"]},{"title":"洛谷P2123题解","url":"/2020/02/19/P2123-Solution/","content":"\n### 链接：[P2123](https://www.luogu.com.cn/problem/P2123)\n\n如果无法显示详细内容或公式崩坏，可以在[我的CSDN博客](https://blog.csdn.net/Pastafarian/article/details/104397141)查看。\n\n<!--more-->\n\n# 题解：\n\n第一步分析与 [P1080](https://www.luogu.com.cn/problem/P1080) 类似，考虑最简单的两个人情况，有两种排列方式：\n\n| 第一种| $sum=0$ | / | $c_i$ |\n| ---- | ---- | ---- |---- |\n| 1    | $l_1$ | $r_1$ | $l_1+r_1$ |\n| 2    | $l_2$ | $r_2$ | $\\max(l_1+r_1,l_1+l_2)+r_2$ |\n\n$ans_1=\\max(l_1+r_1,\\max(l_1+r_1,l_1+l_2)+r_2)$；\n\n| 第二种| $sum=0$ | / | $c_i$ |\n| ---- | ---- | ---- |---- |\n| 1    | $l_2$ | $r_2$ | $l_2+r_2$ |\n| 2    | $l_1$ | $r_1$ | $\\max(l_2+r_2,l_1+l_2)+r_1$ |\n\n$ans_2=\\max(l_2+r_2,\\max(l_2+r_2,l_1+l_2)+r_1)$。\n显然，$\\max(l_1+r_1,l_1+l_2)+r_2\\gt l_2+r_2$，因此如果让 $ans_1\\lt ans_2$，就有 $\\max(l_1+r_1,l_1+l_2)+r_2\\lt \\max(l_2+r_2,l_1+l_2)+r_1$，提出 $\\max()$ 中的 $l_1,l_2$，可以化简为 $\\max(r_1,l_2)-r_1-l_2\\lt \\max(l_1,r_2)-l_1-r_2$，进一步化简可以得到 $\\min(r_1,l_2)\\ge \\min(l_1,r_2)$。\n\n我们还可以发现，$c_i$ 是严格递增的，在所有人的排列中，可以发现当某个人前面的人被确定属于某个集合后，这个人所对应的 $c_i$ 只和他前一个人的 $c_i$ 有关。\n\n所以可以用贪心对所有人进行一种排序，然后统计答案。但是cmp函数里面是不能写 $\\le$ 或 $\\ge$ 的，否则排序时会出问题，如对于数据(7,3)(1,1)(1,6)不会进行任何操作，但是正确的顺序却是(1,1)(1,6)(7,3)。因此，对两个人的 $l_i$ 和 $r_i$ 的关系进行分类，如果 $l_i\\lt r_i,l_j \\lt r_j$ ，按照 $l$ 的升序排列，如果 $l_i=r_i,l_j =r_j$，任意的排列都可以，如果 $l_i\\gt r_i,l_j \\gt r_j$ ，按照 $r$ 的降序排列。\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef tuple<int, int, int> tiii;\nconst int INF = 0x3f3f3f3f;\ninline int read()\n{\n    int data = 0, f = 1;\n    char ch = getchar();\n    while (ch < '0' || ch > '9')\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (ch >= '0' && ch <= '9')\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    return f * data;\n}\nbool cmp(tiii a, tiii b)\n{\n    if (get<2>(a) != get<2>(b))\n        return get<2>(a) < get<2>(b);\n    if (get<2>(a) <= 0)\n        return get<0>(a) < get<0>(b);\n    return get<1>(a) > get<1>(b);\n}\nvector<tiii> v;\nint main()\n{\n    int T = read();\n    while (T--)\n    {\n        int n = read();\n        v.clear();\n        for (int i = 1; i <= n; ++i)\n        {\n            int a = read(), b = read();\n            if (a > b)\n                v.push_back(make_tuple(a, b, 1));\n            else if (a < b)\n                v.push_back(make_tuple(a, b, -1));\n            else\n                v.push_back(make_tuple(a, b, 0));\n        }\n        sort(v.begin(), v.end(), cmp);\n        ull sum = 0, last = 0, now = 0;\n        for (int i = 0; i < n; ++i)\n        {\n            sum += get<0>(v[i]);\n            now = max(last, sum) + get<1>(v[i]);\n            last = now;\n        }\n        printf(\"%llu\\n\", now);\n    }\n    return 0;\n}\n```\n\n![2123.jpg](https://i.loli.net/2020/02/19/Ns4Fqtjeyaw6OuL.jpg)","tags":["2020寒假","洛谷"]},{"title":"洛谷P1080题解","url":"/2020/02/18/P1080-Solution/","content":"\n### 链接：[P1080](https://www.luogu.com.cn/problem/P1080)\n**因为一些玄学的问题本题解可能无法在此显示，可以在[我的CSDN博客](https://blog.csdn.net/Pastafarian/article/details/104384521)查看。**\n<!--more-->\n\n# 题解：\n\n先对简单的情况进行分析，假如只有两个大臣，那么只有两种排列方式：\n\n| 第一种| $king_l$ | $king_r$ |\n| ---- | ---- | ---- |\n| 1    | $l_1$ | $r_1$ |\n| 2    | $l_2$ | $r_2$ |\n\n$ans_1=\\max(\\frac{king_l}{r_1},\\frac{king_l\\times l_1}{r_2})$\n\n或\n\n| 第二种| $king_l$ | $king_r$ |\n| ---- | ---- | ---- |\n| 1    | $l_2$ | $r_2$ |\n| 2    | $l_1$ | $r_1$ |\n\n$ans_2=\\max(\\frac{king_l}{r_2},\\frac{king_l\\times l_2}{r_1})$\n\n显然有 $\\frac{king_l\\times l_1}{r_2}\\ge \\frac{king_l}{r_2}$和$\\frac{king_l\\times l_2}{r_1}\\ge \\frac{king_l}{r_1}$。因此，如果 $ans_1\\le ans_2$，就有 $\\frac{king_l\\times l_1}{r_2}\\le \\frac{king_l\\times l_2}{r_1}$，即 $l_1\\times r_1\\le l_2\\times r_2$。从中可以发现，对于两个相邻的大臣，将左右手数字乘积小的排在前面可以使这两个人的最大金币数达到最小。而对于所有的大臣，每个大臣前面的人只要固定不变，无论他们如何排列都不会影响这个大臣的收入，当然他身后的大臣也不会对他造成影响。所以我们可以对所有人左右手数据的积进行一次排序，然后从小到大安排位次，再统计最大值即可，这里数据很大，需要用到高精度乘除法。\n\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint m;\nconst long long mod = 40961, G = 3, Ginv = (mod + 1) / 3;\nint r[240100];\nlong long ksm(long long a, long long b, long long mod)\n{\n    long long ans = 1;\n    for (; b; b >>= 1, a = a * a % mod)\n        if (b & 1)\n            ans = ans * a % mod;\n    return ans;\n}\nvoid NTT(int limit, long long *l, int opt)\n{\n    for (int i = 0; i < limit; ++i)\n        if (i < r[i])\n            swap(l[i], l[r[i]]);\n    for (int mid = 1; mid < limit; mid <<= 1)\n    {\n        long long wn, len = mid << 1;\n        if (opt == 1)\n            wn = ksm(G, (mod - 1) / len, mod);\n        else\n            wn = ksm(Ginv, (mod - 1) / len, mod);\n        for (int j = 0; j < limit; j += len)\n        {\n            long long w = 1;\n            for (int k = j; k < mid + j; ++k, (w *= wn) %= mod)\n            {\n                int x = l[k], y = w * l[k + mid] % mod;\n                l[k] = (x + y) % mod;\n                l[k + mid] = (x - y + mod) % mod;\n            }\n        }\n    }\n    if (opt == -1)\n    {\n        long long inv = ksm(limit, mod - 2, mod);\n        for (int i = 0; i <= limit; i++)\n            l[i] = l[i] * inv % mod;\n    }\n}\nstruct BigInt\n{\n    int len;\n    bool Is_Pos;\n    long long v[5000];\n    BigInt()\n    {\n        len = 0;\n        memset(v, 0, sizeof(v));\n        Is_Pos = 1;\n    }\n    BigInt(int x)\n    {\n        if (x >= 0)\n            Is_Pos = 1;\n        else\n            x = -x, Is_Pos = 0;\n        len = 0;\n        memset(v, 0, sizeof(v));\n        while (x)\n        {\n            v[++len] = x % 10;\n            x /= 10;\n        }\n    }\n    friend bool operator<(const BigInt &a, const BigInt &b)\n    {\n        if (a.len < b.len)\n            return 1;\n        if (a.len > b.len)\n            return 0;\n        for (int i = a.len; i >= 1; --i)\n        {\n            if (a.v[i] < b.v[i])\n                return 1;\n            if (a.v[i] > b.v[i])\n                return 0;\n        }\n        return 0;\n    }\n};\nBigInt n, a, b;\nostream &operator<<(ostream &out, const BigInt &a);\nistream &operator>>(istream &in, BigInt &a);\nBigInt operator-(BigInt a, BigInt b);\nBigInt operator+(BigInt a, BigInt b);\nBigInt operator*(BigInt a, BigInt b);\nBigInt operator+(BigInt a, BigInt b)\n{\n    if (!a.Is_Pos && !b.Is_Pos)\n    {\n        a.Is_Pos = b.Is_Pos = 1;\n        BigInt c = a + b;\n        c.Is_Pos = 0;\n        return c;\n    }\n    if (!a.Is_Pos && b.Is_Pos)\n    {\n        a.Is_Pos = b.Is_Pos = 1;\n        return b - a;\n    }\n    if (a.Is_Pos && !b.Is_Pos)\n    {\n        a.Is_Pos = b.Is_Pos = 1;\n        return a - b;\n    }\n    int len = a.len + b.len;\n    BigInt c;\n    c.len = len;\n    for (int i = 1; i <= len; ++i)\n        c.v[i] = a.v[i] + b.v[i];\n    for (int i = 1; i <= len; ++i)\n    {\n        if (c.v[i] >= 10)\n        {\n            ++c.v[i + 1];\n            c.v[i] -= 10;\n        }\n    }\n    while (c.len && !c.v[c.len])\n        c.len--;\n    return c;\n}\nBigInt operator-(BigInt a, BigInt b)\n{\n    if (!a.Is_Pos && !b.Is_Pos)\n    {\n        a.Is_Pos = b.Is_Pos = 1;\n        return b - a;\n    }\n    if (!a.Is_Pos && b.Is_Pos)\n    {\n        a.Is_Pos = 1;\n        BigInt c = a + b;\n        c.Is_Pos = 0;\n        return c;\n    }\n    if (a.Is_Pos && !b.Is_Pos)\n    {\n        b.Is_Pos = 1;\n        BigInt c = a + b;\n        return c;\n    }\n    if (a.Is_Pos && b.Is_Pos && a < b)\n    {\n        BigInt c = b - a;\n        c.Is_Pos = 0;\n        return c;\n    }\n    int len = max(a.len, b.len);\n    BigInt c;\n    for (int i = 1; i <= len; ++i)\n        c.v[i] = a.v[i] - b.v[i];\n    c.len = len;\n    for (int i = 1; i <= c.len; ++i)\n    {\n        if (c.v[i] < 0)\n        {\n            c.v[i + 1]--;\n            c.v[i] += 10;\n        }\n    }\n    while (c.len && !c.v[c.len])\n        c.len--;\n    return c;\n}\nBigInt operator*(BigInt a, BigInt b)\n{\n    int limit = 1, tot, l = 0;\n    BigInt c;\n    a.len--;\n    b.len--;\n    for (int i = 0; i <= a.len; ++i)\n        a.v[i] = a.v[i + 1];\n    a.v[a.len + 1] = 0;\n    for (int i = 0; i <= b.len; ++i)\n        b.v[i] = b.v[i + 1];\n    b.v[b.len + 1] = 0;\n    while (limit <= a.len + b.len)\n        limit <<= 1, l++;\n    for (int i = 0; i <= limit; i++)\n        r[i] = (r[i >> 1] >> 1) | ((i & 1) << (l - 1));\n    NTT(limit, a.v, 1);\n    NTT(limit, b.v, 1);\n    for (int i = 0; i <= limit; i++)\n        a.v[i] = a.v[i] * b.v[i] % mod;\n    NTT(limit, a.v, -1);\n    for (int i = 0; i <= limit; i++)\n        c.v[i] = a.v[i];\n    for (int i = 0; i <= limit; i++)\n    {\n        if (c.v[i] >= 10)\n        {\n            c.v[i + 1] += c.v[i] / 10, c.v[i] %= 10;\n            if (i + 1 > limit)\n                limit++;\n        }\n    }\n    for (int i = limit; i >= 0; i--)\n        if (c.v[i] == 0)\n            limit--;\n        else\n            break;\n    c.len = limit + 1;\n    for (int i = c.len; i >= 1; --i)\n        c.v[i] = c.v[i - 1];\n    c.v[0] = 0;\n    for (int i = 1; i <= c.len; ++i)\n        swap(c.v[i], c.v[c.len - i + 1]);\n    if (a.Is_Pos != b.Is_Pos)\n        c.Is_Pos = 0;\n    else\n        c.Is_Pos = 1;\n    return c;\n}\nBigInt operator/(BigInt a, long long b)\n{\n    BigInt c;\n    int d = 0;\n    for (int i = a.len; i >= 1; --i)\n        c.v[++c.len] = ((d * 10 + a.v[i]) / b), d = (d * 10 + a.v[i]) % b;\n    for (int i = 1; i <= c.len / 2; ++i)\n        swap(c.v[i], c.v[c.len - i + 1]);\n    if (!a.len || !b || (a.Is_Pos && b > 0) || (!a.Is_Pos && b < 0))\n        c.Is_Pos = 1;\n    else\n        c.Is_Pos = 0;\n    while (c.v[c.len] == 0 && c.len > 1)\n        --c.len;\n    return c;\n}\nBigInt operator%(BigInt a, long long b)\n{\n    BigInt c = a / b;\n    return a - c * b;\n}\nbool operator>(const BigInt &a, const BigInt &b)\n{\n    return b < a;\n}\nbool operator!=(const BigInt &a, const BigInt &b)\n{\n    if (a > b || a < b)\n        return true;\n    else\n        return false;\n}\nbool operator==(const BigInt &a, const BigInt &b)\n{\n    if (a != b)\n        return false;\n    else\n        return true;\n}\nbool operator<=(const BigInt &a, const BigInt &b)\n{\n    if (a > b)\n        return false;\n    else\n        return true;\n}\nbool operator>=(const BigInt &a, const BigInt &b)\n{\n    if (a < b)\n        return false;\n    else\n        return true;\n}\nistream &operator>>(istream &in, BigInt &a) //cin\n{\n    char lin[5010];\n    int len;\n    scanf(\"%s\", lin + 1);\n    len = a.len = strlen(lin + 1);\n    if (lin[1] == '-')\n        a.Is_Pos = 0, a.len--;\n    else\n        a.Is_Pos = 1;\n    for (int i = 1; i <= a.len; ++i)\n        a.v[i] = lin[len - i + 1] - '0';\n    return in;\n}\nostream &operator<<(ostream &out, const BigInt &a) //cout\n{\n    if (!a.len)\n    {\n        cout << \"0\";\n        return out;\n    }\n    if (!a.Is_Pos)\n        cout << \"-\";\n    for (int i = a.len; i >= 1; i--)\n        printf(\"%d\", a.v[i]);\n    return out;\n}\ninline int read()\n{\n    int data = 0, f = 1;\n    char ch = getchar();\n    while (ch < '0' || ch > '9')\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (ch >= '0' && ch <= '9')\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    return f * data;\n}\nstruct ppp\n{\n    BigInt lft, mul;\n    long long rht;\n};\nvector<ppp> v;\nbool cmp(ppp a, ppp b)\n{\n    return a.mul < b.mul;\n}\nint main()\n{\n    int nm;\n    cin >> nm;\n    BigInt ans, kingr;\n    cin >> ans >> kingr;\n    for (int i = 1; i <= nm; ++i)\n    {\n        ppp kkk;\n        cin >> kkk.lft >> kkk.rht;\n        kkk.mul = kkk.lft * kkk.rht;\n        v.push_back(kkk);\n    }\n    sort(v.begin(), v.end(), cmp);\n    BigInt maxans = ans / v[0].rht;\n    for (int i = 1; i < nm; ++i)\n    {\n        ans = ans * v[i - 1].lft;\n        if (maxans < ans / v[i].rht)\n            maxans = ans / v[i].rht;\n    }\n    cout << maxans;\n    return 0;\n}\n```\n\n我就不信这次还是传不上去\n\n![1080.jpg](https://i.loli.net/2020/02/18/5eQry7HUEil3NCg.jpg)","tags":["2020寒假","洛谷"]},{"title":"洛谷P1233题解","url":"/2020/02/18/P1233-Solution/","content":"\n### 链接：[P1233](https://www.luogu.com.cn/problem/P1233)   \n<!--more-->\n\n# 题解：\n由于数据范围不大，直接暴力算也可以做，但是根据Dilworth定理可以知道这其实是一道加强版的求最长上升子序列的问题，先根据木棍的长度对其进行从大到小的排序，这样长度就不会再对以后的计算过程产生影响，然后就是DP计算最长上升子序列，利用二分查找，时间复杂度 $O(n\\log n)$，明显优于暴力。\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nconst int maxn = 5009;\ninline int read()\n{\n    int data = 0, f = 1;\n    char ch = getchar();\n    while (ch < '0' || ch > '9')\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (ch >= '0' && ch <= '9')\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    return f * data;\n}\nvector<pii> v;\nvector<int> vi;\nbool cmp(pii a, pii b)\n{\n    if (a.first == b.first)\n        return a.second > b.second;\n    return a.first > b.first;\n}\nint main()\n{\n    int n = read();\n    for (int i = 1; i <= n; ++i)\n    {\n        int a = read(), b = read();\n        v.push_back(make_pair(a, b));\n    }\n    sort(v.begin(), v.end(), cmp);\n    for (int i = 0; i < n; ++i)\n    {\n        if (vi.empty() || v[i].second > vi.back())\n            vi.push_back(v[i].second);\n        else\n        {\n            int t = lower_bound(vi.begin(), vi.end(), v[i].second) - vi.begin();\n            vi[t] = v[i].second;\n        }\n    }\n    printf(\"%d\\n\", vi.size());\n    return 0;\n}\n```\n\n","tags":["2020寒假","洛谷"]},{"title":"洛谷P4017题解","url":"/2020/02/18/P4017-Solution/","content":"\n### 链接：[P4017](https://www.luogu.com.cn/problem/P4017)\n<!--more-->\n\n# 题解：\n\n可以用一个有向无环图来保存所有的生物，由于 $n\\le 5000$，如果用邻接矩阵存储是勉强可以的，但是邻接表还是更优秀的选择。存完图后找到所有入度为0的点，它们是食物链的起点，首先把它们放进一个队列，将他们的路径数量修改成1（显然前往入度为0的点只有1种方式），然后处理队列：以队列中每个点为起点，遍历它们所有能够前往的点，更新这些点的路径数量与入度，当一个点的入度变为0，即前往该点的所有方式均被找过后，将这个点压入队列。\n\n在拓扑排序的过程中，所有的点都进入一次队列，每条边计算一次，所以复杂度是 $O(n+m)$。最后统计所有出度为0的点的路径数量，即可得到答案。\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nconst int INF = 0x3f3f3f3f;\nconst int maxn = 10009;\nconst int MOD = 80112002;\ninline int read()\n{\n    int data = 0, f = 1;\n    char ch = getchar();\n    while (ch < '0' || ch > '9')\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (ch >= '0' && ch <= '9')\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    return f * data;\n}\nint m, n, ans;\nint in[maxn], out[maxn], f[maxn];\nvector<int> e[maxn];\nqueue<int> q;\nint main()\n{\n    n = read(), m = read();\n    for (int i = 1; i <= m; ++i)\n    {\n        int x = read(), y = read();\n        out[x]++;\n        in[y]++;\n        e[x].push_back(y);\n    }\n    for (int i = 1; i <= n; ++i)\n    {\n        if (!in[i])\n        {\n            q.push(i);\n            f[i] = 1;\n        }\n    }\n    while (!q.empty())\n    {\n        int x = q.front();\n        q.pop();\n        for (int i = 0, sz = e[x].size(); i < sz; ++i)\n        {\n            int y = e[x][i];\n            f[y] = (f[x] + f[y]) % MOD;\n            in[y]--;\n            if (!in[y])\n                q.push(y);\n        }\n    }\n    for (int i = 1; i <= n; ++i)\n    {\n        if (!out[i])\n            ans = (ans + f[i]) % MOD;\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n```\n\n","tags":["2020寒假","洛谷"]},{"title":"洛谷P5318题解","url":"/2020/02/17/P5318-Solution/","content":"\n### 链接：[P5318](https://www.luogu.com.cn/problem/P5318)   \n<!--more-->\n\n# 题解：\n\n题目给出一个有向图的边数和点数，然后用DFS和BFS分别找一遍字典序最小的路径。由于数据量比较大，要用邻接表存图。存储之前先进行一次排序，由于对于每个点伸出的所有边都按照字典序进行遍历，而字典序小的位于表的前部，所以排序的时候先比较终点~~（似乎先比较起点也是可以的）~~。然后就是DFS和BFS了，两者都可以借助一个bool数组来确定点是否被访问过，其中DFS用递归，BFS用队列，都是很经典的操作。\n\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pint;\nconst int INF = 0x3f3f3f3f;\nconst int maxn = 1e5 + 9;\nvector<int> edg[maxn];\nvector<pint> v;\nbool vis[maxn];\ninline int read()\n{\n    int data = 0, f = 1;\n    char ch = getchar();\n    while (ch < '0' || ch > '9')\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (ch >= '0' && ch <= '9')\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    return f * data;\n}\nbool cmp(pint a, pint b)\n{\n    if (a.second != b.second)\n        return a.second < b.second;\n    return a.first < b.first;\n}\nvoid dfs(int n)\n{\n    vis[n] = true;\n    printf(\"%d \", n);\n    for (int i = 0; i < edg[n].size(); ++i)\n    {\n        int pt = v[edg[n][i]].second;\n        if (!vis[pt])\n            dfs(pt);\n    }\n}\nvoid bfs(int n)\n{\n    queue<int> q;\n    vis[n] = true;\n    printf(\"%d \", n);\n    q.push(n);\n    while (!q.empty())\n    {\n        int f = q.front();\n        for (int i = 0; i < edg[f].size(); ++i)\n        {\n            int pt = v[edg[f][i]].second;\n            if (!vis[pt])\n            {\n                vis[pt] = true;\n                printf(\"%d \", pt);\n                q.push(pt);\n            }\n        }\n        q.pop();\n    }\n}\nint main()\n{\n    int n, m;\n    n = read(), m = read();\n    for (int i = 1; i <= m; ++i)\n    {\n        int p = read(), q = read();\n        v.push_back(make_pair(p, q));\n    }\n    sort(v.begin(), v.end(), cmp);\n    for (int i = 0; i < m; ++i)\n        edg[v[i].first].push_back(i);\n    memset(vis, 0, sizeof(bool) * (n + 1));\n    dfs(1);\n    memset(vis, 0, sizeof(bool) * (n + 1));\n    putchar('\\n');\n    bfs(1);\n    return 0;\n}\n```\n\n","tags":["2020寒假","洛谷"]},{"title":"CF1304D题解","url":"/2020/02/16/CF1304D-Solution/","content":"\n### 链接：[CF1304D Shortest and Longest LIS](https://codeforces.com/problemset/problem/1304/D) [洛谷CF1304D](https://www.luogu.com.cn/problem/CF1304D)  \n\n- **构造 贪心 图论 双指针    \\*1800 ** \n<!--more-->\n# 思路：\n\n最短的**最长上升子序列**一定是最长的**连续上升子序列**，而最长的最长上升子序列则应该是将所有的连续上升子序列拼接起来的长度。所以可以贪心，如果求最短的最长上升子序列，就要尽量使数字递减排列，那么被 $\\gt$ 隔开的**连续递增序列**就都不能拼到一起；同理，如果求最长的最长上升子序列，就尽量使数字升序，使得所有被  $\\lt$ 隔开的**连续递增序列**可以连接起来。\n\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 5;\nint ans[maxn];\nint main()\n{\n\tint T, n;\n\tscanf(\"%d\", &T);\n\twhile (T--)\n\t{\n\t\tstring s;\n\t\tcin >> n >> s;\n\t\tint sum = n, last = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (i == n - 1 || s[i] == '>')\n\t\t\t{\n\t\t\t\tfor (int j = i; j >= last; j--)\n\t\t\t\t\tans[j] = sum--;\n\t\t\t\tlast = i + 1;\n\t\t\t}\n\t\t}\n\t\tsum = 1, last = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tprintf(\"%d \", ans[i]);\n\t\tprintf(\"\\n\");\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (i == n - 1 || s[i] == '<')\n\t\t\t{\n\t\t\t\tfor (int j = i; j >= last; j--)\n\t\t\t\t\tans[j] = sum++;\n\t\t\t\tlast = i + 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tprintf(\"%d \", ans[i]);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n\n```\n\n","tags":["2020寒假","CodeForces"]},{"title":"洛谷P6057题解","url":"/2020/02/16/P6057-Solution/","content":"\n### 链接：[P6057](https://www.luogu.com.cn/problem/P6057)   \n<!--more-->\n\n# 题解：\n\n这是一道很好的训练逆向思维的题，如果暴力枚举一定会超时，并且直接计算同色三元环难以找到一个时间复杂度优秀的算法，但是计算所有三元环的个数是容易的，并且只要 $O(1)$ 就可以完成，那么同色三元环的数量就是三元环总数减去不同色的三元环的数量，而计算不同色三元环的数量只要枚举异色角的数量之和再除2就可以得到，时间复杂度 $O(n)$，这样做总体只需要 $O(n)$ 的时间，就可以做了。\n\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 2;\ntypedef unsigned long long ull;\nint a[maxn];\null ans = 0;\ninline int read()\n{\n    int data = 0, f = 1;\n    char ch = getchar();\n    while (ch < '0' || ch > '9')\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (ch >= '0' && ch <= '9')\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    return f * data;\n}\nint main()\n{\n    int n, m, u, v;\n    n = read();\n    m = read();\n    for (int i = 1; i <= m; i++)\n    {\n        u = read();\n        a[u]++;\n        v = read();\n        a[v]++;\n    }\n    for (int i = 1; i <= n; i++)\n        ans += (ull)a[i] * (n - 1 - a[i]);\n    ull N = (ull)n * (n - 1) / 2 * (n - 2) / 3;\n    cout << N - ans / 2 << endl;\n    return 0;\n}\n```\n\n","tags":["2020寒假","洛谷"]},{"title":"洛谷P1062题解","url":"/2020/02/15/P1062-Solution/","content":"\n### 链接：[P1062](https://www.luogu.com.cn/problem/P1062)\n<!--more-->\n\n# 题解：\n\n题目给的数据暗示了这题的做法，如果所求的数是第k小的，那么这个数就是将k转化为二进制后当成n进制的数来输出。因为每个n的幂都只能最多加一次，所以以这种形式可以不重不漏地表达所有这样的数，前面得到的猜想的正确性得到了证明。接下来用一个栈来存放二进制的各位，加出答案即可。\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\null k, n, ans;\nstack<int> s;\null ksm(ull a,int b)\n{\n    ull ans=1;\n    while(b)\n    {\n        if(b&1)\n            ans*=a;\n        a*=a;\n        b>>=1;\n    }\n    return ans;\n}\ninline ull read()\n{\n    ull data = 0;\n    char ch = getchar();\n    while (ch < '0' || ch > '9')\n        ch = getchar();\n    while (ch >= '0' && ch <= '9')\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    return data;\n}\nint main()\n{\n    k=read(),n=read();\n    while(n>0)\n    {\n        s.push(n & 1);\n        n >>= 1;\n    }\n    while(!s.empty())\n    {\n        ans += s.top() * ksm(k, s.size()-1);\n        s.pop();\n    }\n    cout << ans << endl;\n    return 0;\n}\n```\n\n","tags":["2020寒假","洛谷"]},{"title":"洛谷P1801题解","url":"/2020/02/15/P1801-Solution/","content":"\n### 链接：[P1801](https://www.luogu.com.cn/problem/P1801)\n<!--more-->\n\n# 题解：\n\n这道题要在一些数据加入一个集合的过程中动态维护第k小值，因此可以用一棵平衡树来做。先把所有数据存到数组里，再根据询问的内容每次插入一些数并求出答案。用平衡树做比较容易想到，但是这题还可以用对顶堆来做，维护区间k小值，速度要比平衡树慢一些，代码量也小一些。\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 0x7FFFFFFF;\nstruct AVL_node;\ntypedef AVL_node *AVL_Tree;\nstruct AVL_node\n{\n    int value, height, freq, size;\n    AVL_Tree ls, rs;\n    AVL_node() : value(0), height(1), freq(1), size(1), ls(nullptr), rs(nullptr) {}\n    AVL_node(int n) : value(n), height(1), freq(1), size(1), ls(nullptr), rs(nullptr) {}\n};\ninline int get_size(AVL_Tree p)\n{\n    if (p == nullptr)\n        return 0;\n    return p->size;\n}\ninline int get_height(AVL_Tree p)\n{\n    if (p == nullptr)\n        return 0;\n    return p->height;\n}\ninline void update(AVL_Tree &p)\n{\n    p->size = get_size(p->ls) + get_size(p->rs) + p->freq;\n    p->height = max(get_height(p->ls), get_height(p->rs)) + 1;\n}\ninline void rotate_ls_ls(AVL_Tree &p)\n{\n    AVL_Tree q;\n    q = p->ls;\n    p->ls = q->rs;\n    q->rs = p;\n    update(p);\n    update(q);\n    p = q;\n}\ninline void rotate_rs_rs(AVL_Tree &p)\n{\n    AVL_Tree q;\n    q = p->rs;\n    p->rs = q->ls;\n    q->ls = p;\n    update(p);\n    update(q);\n    p = q;\n}\ninline void rotate_ls_rs(AVL_Tree &p)\n{\n    rotate_rs_rs(p->ls);\n    rotate_ls_ls(p);\n}\ninline void rotate_rs_ls(AVL_Tree &p)\n{\n    rotate_ls_ls(p->rs);\n    rotate_rs_rs(p);\n}\nvoid AVL_insert(AVL_Tree &p, int x)\n{\n    if (p == nullptr)\n    {\n        p = new AVL_node(x);\n        return;\n    }\n    if (p->value == x)\n    {\n        (p->freq)++;\n        update(p);\n        return;\n    }\n    if (p->value > x)\n    {\n        AVL_insert(p->ls, x);\n        update(p);\n        if (get_height(p->ls) - get_height(p->rs) == 2)\n        {\n            if (x < p->ls->value)\n                rotate_ls_ls(p);\n            else\n                rotate_ls_rs(p);\n        }\n    }\n    else\n    {\n        AVL_insert(p->rs, x);\n        update(p);\n        if (get_height(p->rs) - get_height(p->ls) == 2)\n        {\n            if (x > p->rs->value)\n                rotate_rs_rs(p);\n            else\n                rotate_rs_ls(p);\n        }\n    }\n    update(p);\n}\nint get_val(AVL_Tree p, int r)\n{\n    if (get_size(p->ls) >= r)\n        return get_val(p->ls, r);\n    if (get_size(p->ls) + p->freq >= r)\n        return p->value;\n    return get_val(p->rs, r - get_size(p->ls) - p->freq);\n}\ninline int read()\n{\n    int data = 0, f = 1;\n    char ch = getchar();\n    while (ch < '0' || ch > '9')\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (ch >= '0' && ch <= '9')\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    return f * data;\n}\nAVL_Tree root;\nint in[200001], u[200001];\nint main()\n{\n    int n, m, j = 1, temp = 0;\n    n = read(), m = read();\n    for (int i = 1; i <= n; i++)\n        in[i] = read();\n    for (int i = 1; i <= m; i++)\n    {\n        u[i] = read();\n        while (j <= u[i])\n            AVL_insert(root, in[j++]);\n        printf(\"%d\\n\", get_val(root, ++temp));\n    }\n    return 0;\n}\n```\n\n","tags":["2020寒假","洛谷"]},{"title":"洛谷P3952题解","url":"/2020/02/15/P3952-Solution/","content":"\n### 链接：[P3952](https://www.luogu.com.cn/problem/P3952)\n<!--more-->\n\n# 题解：\n\n一道恐怖的大模拟题。这题可以在线也可以离线，在线做复杂之处在于判断编译错误后依然要读完，离线复杂的地方在于把所有数据正确存进去，我是用在线做的。根据题意ERR的优先级是大于Yes和No的，所以先用一个栈和一个string来判断F和E是否匹配以及是否出现重名的循环变量。如果编译错误就不用再考虑后面的几行，直接读掉就可以了。然后判断时间复杂度，分类讨论每一层是线性的还是常数的还是不会进入的循环，如果是不会进入的循环就需要屏蔽掉这个循环内部的东西。最后比较算出的时间复杂度和给的时间复杂度的关系，得出答案。\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x7fffffff;\nint main()\n{\n    int T, n;\n    cin >> T;\n    while (T--)\n    {\n        int f = 0, e = 0, cnt = 0, maxo = 0, int_o = 0, lpcnt = -1, ce = 0, erl = 0, pos = 0;\n        char op;\n        stack<int> st;\n        string ooo, chset;\n        cin >> n >> ooo;\n        if (ooo.length() > 4)\n            for (int i = 4; i < ooo.length() - 1; i++)\n                int_o *= 10, int_o += ooo[i] - '0';\n        for (int i = 1; i <= n; ++i)\n        {\n            string ch, xx, yy;\n            int sta = 0, end = 0;\n            cin >> op;\n            if (op == 'F')\n            {\n                f++, pos++;\n                st.push(pos);\n                cin >> ch >> xx >> yy;\n                if (yy[0] == 'n' && xx[0] != 'n')\n                    cnt++;\n                for (int j = 0; j < xx.length(); j++)\n                    sta *= 10, sta += xx[j] - '0';\n                if (xx[0] == 'n')\n                    sta = INF;\n                if (yy[0] != 'n')\n                {\n                    for (int j = 0; j < yy.length(); j++)\n                        end *= 10, end += yy[j] - '0';\n                    if (sta > end)\n                        lpcnt = pos;\n                }\n                if (lpcnt == -1 || pos < lpcnt)\n                    maxo = max(maxo, cnt);\n                chset += ch;\n                if (chset.find(ch) != chset.length() - 1)\n                {\n                    erl = i;\n                    ce = 1;\n                    break;\n                }\n                sta = end = 0;\n            }\n            else \n            {\n                e++, cnt--;\n                if (st.empty())\n                {\n                    erl = i;\n                    ce = 1;\n                    break;\n                }\n                if (st.top() <= lpcnt)\n                    pos = 0, lpcnt = -1;\n                st.pop();\n                if (st.empty())\n                    cnt = 0;\n                if (chset.length())\n                    chset = chset.substr(0, chset.length() - 1);\n            }\n        }\n        if (ce)\n        {\n            string crap;\n            for (int i = 1; i <= n + 1 - erl; i++)\n                getline(cin, crap);\n            puts(\"ERR\");\n        }\n        else if (f != e)\n        {\n            if (!ce)\n                puts(\"ERR\");\n        }\n        else\n        {\n            if (maxo == int_o)\n                puts(\"Yes\");\n            else\n                puts(\"No\");\n        }\n    }\n    return 0;\n}\n```\n\n","tags":["2020寒假","洛谷"]},{"title":"洛谷P1063题解","url":"/2020/02/14/P1063-Solution/","content":"\n### 链接：[P1063](https://www.luogu.com.cn/problem/P1063)\n<!--more-->\n\n# 题解：\n\n这是一个区间DP题，先把环形的区间展开变成一条直线。每当发生一次合并的操作，问题就会转化成$n-1$个珠子合并求最大值，所以推导出状态转移方程：\n\n$$f_{left,right}=\\max(f_{left,right},f_{left,k}+f_{k,right}+a_{left}\\times a_{k}\\times a_{right})$$\n\n这样做的时间复杂度是$O(n^3)$的，感觉很暴力，好在数据范围比较小，并不会超时。\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint f[409][409], n, a[209], ans;\ninline int read()\n{\n    int data = 0, f = 1;\n    char ch = getchar();\n    while (ch < '0' || ch > '9')\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (ch >= '0' && ch <= '9')\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    return f * data;\n}\nint main()\n{\n    n = read();\n    for (int i = 1; i <= n; i++)\n    {\n        a[i] = read();\n        a[n + i] = a[i];\n    }\n    for (int i = 2; i <= n + 1; i++)\n    {\n        for (int j = 1; j <= 2 * n + 1 - i; j++)\n        {\n            int r = j + i - 1;\n            for (int k = j + 1; k <= j + i - 2; k++)\n                f[j][r] = max(f[j][r], f[j][k] + f[k][r] + a[j] * a[k] * a[r]);\n        }\n    }\n    for (int i = 1; i <= n; i++)\n        ans = max(ans, f[i][n + i]);\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n```\n\n","tags":["2020寒假","洛谷"]},{"title":"洛谷P1440题解","url":"/2020/02/14/P1440-Solution/","content":"\n### 链接：[P1440](https://www.luogu.com.cn/problem/P1440)   \n<!--more-->\n\n# 题解：\n\n找长度给定的连续子序列中最小值，单调队列、ST表和线段树应该都可以做。其中单调队列是$O(n)$复杂度，ST表建表$O(n\\log n)$，查询$O(m)$，线段树建树$O(n\\log n)$，查询$O(m\\log n)$，理论上线段树是最慢的，但是数据范围是$2\\times 10^7$，感觉线段树应该也能过。这里线段树不用修改操作，自然也不需要lazy-tag，所以比较好写，但是写完试了一下发现线段树要开O2优化才能过最后一个点，说明对于这样的数据范围以线段树的复杂度还是很勉强的。\n\n\n# AC代码：\n\n```c++\n#pragma GCC optimize(2)\n#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 0x7fffffff;\nconst int maxn = 2e7 + 2;\nint a[maxn], seg_tree[maxn << 2];\nvoid pushup(int p)\n{\n    seg_tree[p] = min(seg_tree[p << 1], seg_tree[p << 1 | 1]);\n}\nvoid build(int p, int l, int r)\n{\n    if (l == r)\n    {\n        seg_tree[p] = a[l];\n        return;\n    }\n    int mid = (l + r) >> 1;\n    build(p << 1, l, mid);\n    build(p << 1 | 1, mid + 1, r);\n    pushup(p);\n}\nint query(int q_x, int q_y, int l, int r, int p)\n{\n    if (q_x <= l && q_y >= r)\n        return seg_tree[p];\n    int ans = inf, mid = (l + r) >> 1;\n    if (q_x <= mid)\n        ans = query(q_x, q_y, l, mid, p << 1);\n    if (q_y > mid)\n        ans = min(ans, query(q_x, q_y, mid + 1, r, p << 1 | 1));\n    return ans;\n}\ninline int read()\n{\n    int data = 0, f = 1;\n    char ch = getchar();\n    while (ch < '0' || ch > '9')\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (ch >= '0' && ch <= '9')\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    return f * data;\n}\nint main()\n{\n    int n, m;\n    n = read(), m = read();\n    for (int i = 1; i <= n; i++)\n        a[i] = read();\n    build(1, 1, n);\n    printf(\"0\\n\");\n    for (int i = 2; i <= n; i++)\n        printf(\"%d\\n\", query(max(1, i - m), i - 1, 1, n, 1));\n    return 0;\n}\n```\n\n","tags":["2020寒假","洛谷"]},{"title":"洛谷P2471题解","url":"/2020/02/14/P2471-Solution/","content":"\n### 链接：[P2471](https://www.luogu.com.cn/problem/P2471)\n<!--more-->\n\n# 题解：\n\n题目需要查询静态区间最大值，所以用ST表比较方便，但是区间长度非常大，要先用一个map来离散化，并且在查询的时候要进行分类讨论，如果区间不合法直接输出false，否则查询区间内已知数据的最大值，如果不小于右边界则输出false，如果小于就进一步判断区间内是否存在未知的数据，如果有就输出maybe，如果没有就输出true。\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 500020;\nconst int inf = 0x7FFFFFFF;\nint st[maxn][21];\nint n, m, x, y, c, d;\nmap<int, int> mp;\ninline int query(int left, int right)\n{\n    int k = log2(right - left + 1);\n    return max(st[left][k], st[right - (1 << k) + 1][k]);\n}\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++)\n    {\n        scanf(\"%d%d\", &y, &st[i][0]);\n        mp[y] = i;\n    }\n    for (int j = 1; j < 21; j++)\n        for (int i = 1; i + (1 << j) - 1 <= n; i++)\n            st[i][j] = max(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n    scanf(\"%d\", &m);\n    while (m--)\n    {\n        scanf(\"%d%d\", &y, &x);\n        if (y >= x)\n        {\n            printf(\"false\\n\");\n            continue;\n        }\n        int cx = mp.count(x), cy = mp.count(y), flag;\n        if (!cx && !cy)\n        {\n            printf(\"maybe\\n\");\n            continue;\n        }\n        auto it = mp.lower_bound(x);\n        auto it2 = mp.lower_bound(y);\n\n        if (it2 == mp.end())\n        {\n            printf(\"maybe\\n\");\n            continue;\n        }\n        d = it2->second;\n        if (it == mp.end())\n            c = mp.size() + 1;\n        else\n            c = it->second;\n        if (cy == 0)\n            d--;\n        int k = d + 1 <= c - 1 ? query(d + 1, c - 1) : 0;\n        if (cy == 0)\n            flag = (k < st[c][0]);\n        else if (cx == 0)\n            flag = (k < st[d][0]);\n        else\n            flag = (st[d][0] >= st[c][0] && st[c][0] > k);\n        if (cy && cx && d - c == y - x)\n        {\n            if (flag)\n                printf(\"true\\n\");\n            else\n                printf(\"false\\n\");\n        }\n        else\n        {\n            if (flag)\n                printf(\"maybe\\n\");\n            else\n                printf(\"false\\n\");\n        }\n    }\n    return 0;\n}\n```\n\n","tags":["2020寒假","洛谷"]},{"title":"洛谷P1118题解","url":"/2020/02/13/P1118-Solution/","content":"\n### 链接：[P1118](https://www.luogu.com.cn/problem/P1118)\n<!--more-->\n\n# 题解：\n\n一道可以用DFS做的题，先打个表或者用数学方法可以推出数字三角形最下方的数正好是序列的每一项和杨辉三角中所对应的的项的乘积之和。因此先生成与输入数据对应的杨辉三角的一行，再用DFS搜出第一个满足要求的排列，因为是从小到大循环的所以肯定是“字典序”的。还有就是如果无解什么也不输出有点坑，要特判一下。\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nbitset<13> b;\nint n, tot, a[13], table[15];\nbool flag = true;\nint r(int i, int base)\n{\n    int ans = 1, j;\n    if (i == 0 || i == base)\n        return ans;\n    else\n    {\n        int k=min(i,base-i);\n        for (j = 0; j < k; j++)\n            ans *= (base - j);\n        for (j = 1; j <= k; j++)\n            ans /= j;\n    }\n    return ans;\n}\nvoid dfs(int step, int sum)\n{\n\n    if (sum > tot)\n        return;\n    if (step > n)\n    {\n        if (sum == tot)\n            flag = false;\n        return;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        if (b[i] == false)\n        {\n            b[i] = true;\n            a[step] = i;\n            dfs(step + 1, sum + i * table[step]);\n            if (!flag)\n                return;\n            b[i] = false;\n        }\n    }\n}\nint main()\n{\n    scanf(\"%d%d\", &n, &tot);\n    for (int i = 0; i < n; i++)\n        table[i + 1] = r(i, n-1);\n    dfs(1, 0);\n    if(!flag)\n        for (int i = 1; i <= n; i++)\n            printf(\"%d \", a[i]);\n    return 0;\n}\n```\n\n","tags":["2020寒假","洛谷"]},{"title":"洛谷P1387题解","url":"/2020/02/13/P1387-Solution/","content":"\n### 链接：[P1387](https://www.luogu.com.cn/problem/P1387)   \n<!--more-->\n\n# 题解：\n\n这是一个很神奇的DP题，虽然答案代码很短但是状态转移方程的设计非常巧妙。可以发现，每一块方格1能否形成更大的正方形都是由它的左边、左上角以及上方的三个格子共同决定的。因此使用正方形右下角的顶点来保存边长，这样做可以更容易设计状态转移方程：(前提是$f_{i,j}=1$)\n\n$$f_{i,j}=min(f_{i-1,j},f_{i-1,j-1},f_{i,j-1})+1$$\n\n这样统计出最大的$f_{i,j}=1$就是答案。\n\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint f[102][102];\nint min3(int a, int b, int c)\n{\n    return a < b ? a < c ? a : c : b < c ? b : c;\n}\nint main()\n{\n    int c, r, ans = 0;\n    scanf(\"%d%d\", &r, &c);\n    for (int i = 1; i <= r; i++)\n    {\n        for (int j = 1; j <= c; j++)\n        {\n            scanf(\"%1d\", &f[i][j]);\n            if (f[i][j] > 0)\n            {\n                f[i][j] = min3(f[i - 1][j], f[i - 1][j - 1], f[i][j - 1]) + 1;\n                ans = max(ans, f[i][j]);\n            }\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n```\n\n","tags":["2020寒假","洛谷"]},{"title":"洛谷P1855题解","url":"/2020/02/13/P1855-Solution/","content":"\n### 链接：[P1855](https://www.luogu.com.cn/problem/P1855)\n<!--more-->\n\n# 题解：\n\n这是一个二维背包问题，条件和一维背包问题相似，只是多了一种“价值”需要考虑。状态转移方程：$$F_{i,v,u}= max(F_{i-1,v,u}, F_{i-1, v-Ci,u-Di}+W_i)$$\n\n所以将数组增加一维，在一维背包的做法上增加一个循环，最后得到的$F_{m,t}$就是答案。\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint n,m,t;\nint mi[220],ti[220],ni[220][220];\nint main()\n{\n    scanf(\"%d%d%d\",&n,&m,&t);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d%d\",&mi[i],&ti[i]);\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=m;j>=mi[i];j--)\n        {\n            for(int k=t;k>=ti[i];k--)\n            {\n                ni[j][k]=max(ni[j][k],ni[j-mi[i]][k-ti[i]]+1);\n            }\n        }\n    }\n    printf(\"%d\\n\",ni[m][t]);\n    return 0;\n}\n```\n\n","tags":["2020寒假","洛谷"]},{"title":"AVL树","url":"/2020/02/12/AVL_Tree/","content":"\n# 简介：\n\nAVL树是最先发明的自平衡二叉查找树。AVL树高度平衡，其任意节点左右子树的高度差不超过1。同时它也拥有普通二叉查找树的性质，即每个节点左子树上所有节点的值均小于根节点的值，右子树上所有节点的值均大于根节点的值，且不同节点的值均不同。\n\n<!--more-->\n\n# 实现过程\n**平衡因子：**每个节点左子树和右子树的高度差。若所有节点平衡因子的绝对值均不超过1则平衡。\n\n使用一个结构体保存节点的键值、频数、以该点为根的树的树高和大小以及左右子树。当树不平衡时，可以通过旋转使树平衡。\n\n```c++\nstruct AVL_node;\ntypedef AVL_node *AVL_Tree;\nstruct AVL_node\n{\n    int value, height, freq, size;\n    AVL_Tree ls, rs;\n    AVL_node() : value(0), height(1), freq(1), size(1), ls(nullptr), rs(nullptr) {}\n    AVL_node(int n) : value(n), height(1), freq(1), size(1), ls(nullptr), rs(nullptr) {}\n};\n```\n\n**不平衡情况1（左-左）：**\n\n![1](https://i.loli.net/2020/02/12/BYrixbevTfP8cR4.png)\n\n在插入1之前，树是平衡的，但是9的左子树比右子树高度大。在9的左子树的左子树插入1（或2，4，5）后，树不平衡了，这种左子树更高且向左子树的左子树插入节点的情况可以通过一次右旋来使树平衡。右旋使原来不平衡的根节点的左子树成为根节点，而原来的根节点成为新的右子树，原来左子树的右子树成为原来的根节点的左子树。容易证明，旋转后依旧具有二叉查找树的性质。\n\n![2](https://i.loli.net/2020/02/12/mz46SiMWg5lTcfJ.png)\n\n```c++\ninline void rotate_ls_ls(AVL_Tree &p)\n{\n    AVL_Tree q;\n    q = p->ls;\n    p->ls = q->rs;\n    q->rs = p;\n    update(p);\n    update(q);\n    p = q;\n}\n```\n**不平衡情况2（右-右）：**\n\n![3](https://i.loli.net/2020/02/12/f5eClWkqbJ7XywL.png)\n\n在插入13之前，树是平衡的，但是8的右子树比左子树高度大。在8的右子树的右子树插入13（或11）后，树不平衡了，这种右子树更高且向右子树的右子树插入节点的情况可以通过一次左旋来使树平衡。左旋使原来不平衡的根节点的右子树成为根节点，而原来的根节点成为新的左子树，原来右子树的左子树成为原来的根节点的右子树。同样，旋转后依旧具有二叉查找树的性质。\n\n![4](https://i.loli.net/2020/02/12/vhUgRs8SFj41HmV.png)\n```c++\ninline void rotate_rs_rs(AVL_Tree &p)\n{\n    AVL_Tree q;\n    q = p->rs;\n    p->rs = q->ls;\n    q->ls = p;\n    update(p);\n    update(q);\n    p = q;\n}\n```\n**不平衡情况3：（左-右）**\n\n![5](https://i.loli.net/2020/02/12/dRS1WHXAN7MlUhg.png)\n\n这种情况是在左子树更高的树的左子树的右子树插入节点，需要先进行一次左旋，再进行一次右旋。\n\n左旋：\n\n![6](https://i.loli.net/2020/02/12/9S1xL8N2FIvhuZA.png)\n\n右旋：\n\n![7](https://i.loli.net/2020/02/12/WgVKU1dbrEno9Ra.png)\n```c++\ninline void rotate_ls_rs(AVL_Tree &p)\n{\n    rotate_rs_rs(p->ls);\n    rotate_ls_ls(p);\n}\n```\n**不平衡情况4：（右-左）**\n\n与情况3相反，先进行一次右旋，再进行一次左旋。\n\n![8](https://i.loli.net/2020/02/12/6KXb74TNLQUO1RB.png)\n\n右旋：\n\n![9](https://i.loli.net/2020/02/12/V5JZvClKTzU8qcP.png)\n\n左旋：\n\n![10](https://i.loli.net/2020/02/12/2h8ktCgqNnZR3IW.png)\n```c++\ninline void rotate_rs_ls(AVL_Tree &p)\n{\n    rotate_ls_ls(p->rs);\n    rotate_rs_rs(p);\n}\n```\n\n**获取树的大小**\n\n```c++\ninline int get_size(AVL_Tree p)\n{\n    if (p == nullptr)\n        return 0;\n    return p->size;\n}\n```\n\n**获取树的高度**\n\n```c++\ninline int get_height(AVL_Tree p)\n{\n    if (p == nullptr)\n        return 0;\n    return p->height;\n}\n```\n\n**更新**\n\n```c++\ninline void update(AVL_Tree &p)\n{\n    p->size = get_size(p->ls) + get_size(p->rs) + p->freq;\n    p->height = max(get_height(p->ls), get_height(p->rs)) + 1;\n}\n```\n\n**插入**\n\n```c++\nvoid AVL_insert(AVL_Tree &p, int x)\n{\n    if (p == nullptr)\n    {\n        p = new AVL_node(x);\n        return;\n    }\n    if (p->value == x)//已经存在,频数+1\n    {\n        (p->freq)++;\n        update(p);\n        return;\n    }\n    if (p->value > x)\n    {\n        AVL_insert(p->ls, x);\n        update(p);\n        if (get_height(p->ls) - get_height(p->rs) == 2)//插到左边,左边更高\n        {\n            if (x < p->ls->value)\n                rotate_ls_ls(p);\n            else\n                rotate_ls_rs(p);\n        }\n    }\n    else\n    {\n        AVL_insert(p->rs, x);\n        update(p);\n        if (get_height(p->rs) - get_height(p->ls) == 2)//插到右边,右边更高\n        {\n            if (x > p->rs->value)\n                rotate_rs_rs(p);\n            else\n                rotate_rs_ls(p);\n        }\n    }\n    update(p);\n}\n```\n\n**删除数据**\n\n```c++\nvoid AVL_erase(AVL_Tree &p, int x)\n{\n    if (p == nullptr)\n        return;\n    if (p->value > x)\n    {\n        AVL_erase(p->ls, x);\n        update(p);\n        if (get_height(p->rs) - get_height(p->ls) == 2)//删左边，右边高\n        {\n            if (get_height(p->rs->rs) >= get_height(p->rs->ls))//见代码后注释\n                rotate_rs_rs(p);\n            else\n                rotate_rs_ls(p);\n        }\n    }\n    else if (p->value < x)\n    {\n        AVL_erase(p->rs, x);\n        update(p);\n        if (get_height(p->ls) - get_height(p->rs) == 2)\n        {\n            if (get_height(p->ls->ls) >= get_height(p->ls->rs))\n                rotate_ls_ls(p);\n            else\n                rotate_ls_rs(p);\n        }\n    }\n    else\n    {\n        if (p->freq > 1)\n        {\n            (p->freq)--;\n            update(p);\n            return;\n        }\n        if (p->ls && p->rs)\n        {\n            AVL_Tree q;\n            q = p->rs;\n            while (q->ls)\n                q = q->ls;\n            p->freq = q->freq;\n            p->value = q->value;\n            q->freq = 1; //删除q\n            AVL_erase(p->rs, q->value);\n            if (get_height(p->ls) - get_height(p->rs) == 2)\n            {\n                if (get_height(p->ls->ls) >= get_height(p->ls->rs))\n                    rotate_ls_ls(p);\n                else\n                    rotate_ls_rs(p);\n            }\n        }\n        else\n        {\n            AVL_Tree q;\n            q = p;\n            if (p->ls)\n                p = p->ls;\n            else if (p->rs)\n                p = p->rs;\n            else\n                p = nullptr;\n            delete q;\n            q = nullptr;\n        }\n    }\n    if (p == nullptr)\n        return;\n    update(p);\n}\n```\n\n第11行必须用$\\ge$，否则遇到如图的情况：\n\n![11](https://i.loli.net/2020/02/12/XuxmhoWtJvaCqwp.png)\n\n删去13后，先右旋再左旋，树仍然不是平衡的：\n\n![12](https://i.loli.net/2020/02/12/U4IajS9vukohHml.png)\n\n**通过值查找位次**\n\n```c++\nint get_rank(AVL_Tree p, int x)\n{\n    if (p->value == x)\n        return get_size(p->ls) + 1;\n    if (p->value > x)\n        return get_rank(p->ls, x);\n    return get_rank(p->rs, x) + get_size(p->ls) + p->freq;\n}\n```\n\n**通过位次查找值**\n\n```c++\nint get_val(AVL_Tree p, int r)\n{\n    if (get_size(p->ls) >= r)\n        return get_val(p->ls, r);\n    if (get_size(p->ls) + p->freq >= r)\n        return p->value;\n    return get_val(p->rs, r - get_size(p->ls) - p->freq);\n}\n```\n\n**查找前驱**\n\n```c++\nint get_pre(AVL_Tree p, int x)\n{\n    AVL_Tree ans = new AVL_node(-inf);\n    while (p)\n    {\n        if (p->value == x)\n        {\n            if (p->ls)\n            {\n                p = p->ls;\n                while (p->rs)\n                {\n                    p = p->rs;\n                }\n                ans = p;\n            }\n            break;\n        }\n        if (p->value < x && p->value > ans->value)\n            ans = p;\n        p = p->value < x ? p->rs : p->ls;\n    }\n    return ans->value;\n}\n```\n\n**查找后继**\n\n```c++\nint get_suf(AVL_Tree p, int x)\n{\n    AVL_Tree ans = new AVL_node(inf);\n    while (p)\n    {\n        if (p->value == x)\n        {\n            if (p->rs)\n            {\n                p = p->rs;\n                while (p->ls)\n                {\n                    p = p->ls;\n                }\n                ans = p;\n            }\n            break;\n        }\n        if (p->value > x && p->value < ans->value)\n            ans = p;\n        p = p->value < x ? p->rs : p->ls;\n    }\n    return ans->value;\n}\n```\n\n**中序遍历**\n\n```c++\nvoid output(AVL_Tree p)\n{\n    if(p==nullptr)\n        return;\n    output(p->ls);\n    for (int i = 1; i <= p->freq;i++)\n        printf(\"%d \", p->value);\n    output(p->rs);\n}\n```\n\nAVL树的插入、删除、查找都是$\\log$级别的复杂度，其中AVL树的查询和其它平衡树相比会更有优势，但是AVL树代码量比较大，总体速度也很一般，可以分裂合并，可持久化，但是比较难写。\n\n终于写完了，真是不容易。\n\n![v2-28825ec8201c53892205bfd8b41c97dd_hd.jpg](https://i.loli.net/2020/02/12/1scLYZaiKRt25N3.jpg)\n\n\n","tags":["数据结构"]},{"title":"洛谷P3369题解","url":"/2020/02/12/P3369-Solution/","content":"\n### 链接：[P3369](https://www.luogu.com.cn/problem/P3369)\n<!--more-->\n\n# 题解：\n题目要求用一个数据结构实现一些数的插入、删除、根据排名查找数、根据数值询问排名以及求前驱和后继，所以可以通过建一棵AVL树来实现。\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 0x7FFFFFFF;\nstruct AVL_node;\ntypedef AVL_node *AVL_Tree;\nstruct AVL_node\n{\n    int value, height, freq, size;\n    AVL_Tree ls, rs;\n    AVL_node() : value(0), height(1), freq(1), size(1), ls(nullptr), rs(nullptr) {}\n    AVL_node(int n) : value(n), height(1), freq(1), size(1), ls(nullptr), rs(nullptr) {}\n};\ninline int get_size(AVL_Tree p)\n{\n    if (p == nullptr)\n        return 0;\n    return p->size;\n}\ninline int get_height(AVL_Tree p)\n{\n    if (p == nullptr)\n        return 0;\n    return p->height;\n}\ninline void update(AVL_Tree &p)\n{\n    p->size = get_size(p->ls) + get_size(p->rs) + p->freq;\n    p->height = max(get_height(p->ls), get_height(p->rs)) + 1;\n}\ninline void rotate_ls_ls(AVL_Tree &p)\n{\n    AVL_Tree q;\n    q = p->ls;\n    p->ls = q->rs;\n    q->rs = p;\n    update(p);\n    update(q);\n    p = q;\n}\ninline void rotate_rs_rs(AVL_Tree &p)\n{\n    AVL_Tree q;\n    q = p->rs;\n    p->rs = q->ls;\n    q->ls = p;\n    update(p);\n    update(q);\n    p = q;\n}\ninline void rotate_ls_rs(AVL_Tree &p)\n{\n    rotate_rs_rs(p->ls);\n    rotate_ls_ls(p);\n}\ninline void rotate_rs_ls(AVL_Tree &p)\n{\n    rotate_ls_ls(p->rs);\n    rotate_rs_rs(p);\n}\nvoid AVL_insert(AVL_Tree &p, int x)\n{\n    if (p == nullptr)\n    {\n        p = new AVL_node(x);\n        return;\n    }\n    if (p->value == x)\n    {\n        (p->freq)++;\n        update(p);\n        return;\n    }\n    if (p->value > x)\n    {\n        AVL_insert(p->ls, x);\n        update(p);\n        if (get_height(p->ls) - get_height(p->rs) == 2)\n        {\n            if (x < p->ls->value)\n                rotate_ls_ls(p);\n            else\n                rotate_ls_rs(p);\n        }\n    }\n    else\n    {\n        AVL_insert(p->rs, x);\n        update(p);\n        if (get_height(p->rs) - get_height(p->ls) == 2)\n        {\n            if (x > p->rs->value)\n                rotate_rs_rs(p);\n            else\n                rotate_rs_ls(p);\n        }\n    }\n    update(p);\n}\nvoid AVL_erase(AVL_Tree &p, int x)\n{\n    if (p == nullptr)\n        return;\n    if (p->value > x)\n    {\n        AVL_erase(p->ls, x);\n        update(p);\n        if (get_height(p->rs) - get_height(p->ls) == 2)\n        {\n            if (get_height(p->rs->rs) >= get_height(p->rs->ls))\n                rotate_rs_rs(p);\n            else\n                rotate_rs_ls(p);\n        }\n    }\n    else if (p->value < x)\n    {\n        AVL_erase(p->rs, x);\n        update(p);\n        if (get_height(p->ls) - get_height(p->rs) == 2)\n        {\n            if (get_height(p->ls->ls) >= get_height(p->ls->rs))\n                rotate_ls_ls(p);\n            else\n                rotate_ls_rs(p);\n        }\n    }\n    else\n    {\n        if (p->freq > 1)\n        {\n            (p->freq)--;\n            update(p);\n            return;\n        }\n        if (p->ls && p->rs)\n        {\n            AVL_Tree q;\n            q = p->rs;\n            while (q->ls)\n                q = q->ls;\n            p->freq = q->freq;\n            p->value = q->value;\n            q->freq = 1; //to erase q;\n            AVL_erase(p->rs, q->value);\n            if (get_height(p->ls) - get_height(p->rs) == 2)\n            {\n                if (get_height(p->ls->ls) >= get_height(p->ls->rs))\n                    rotate_ls_ls(p);\n                else\n                    rotate_ls_rs(p);\n            }\n        }\n        else\n        {\n            AVL_Tree q;//防止内存泄漏\n            q = p;\n            if (p->ls)\n                p = p->ls;\n            else if (p->rs)\n                p = p->rs;\n            else\n                p = nullptr;\n            delete q;\n            q = nullptr;\n        }\n    }\n    if (p == nullptr)\n        return;\n    update(p);\n}\nint get_rank(AVL_Tree p, int x)\n{\n    if (p->value == x)\n        return get_size(p->ls) + 1;\n    if (p->value > x)\n        return get_rank(p->ls, x);\n    return get_rank(p->rs, x) + get_size(p->ls) + p->freq;\n}\nint get_val(AVL_Tree p, int r)\n{\n    if (get_size(p->ls) >= r)\n        return get_val(p->ls, r);\n    if (get_size(p->ls) + p->freq >= r)\n        return p->value;\n    return get_val(p->rs, r - get_size(p->ls) - p->freq);\n}\nint get_pre(AVL_Tree p, int x)\n{\n    AVL_Tree ans = new AVL_node(-inf);\n    while (p)\n    {\n        if (p->value == x)\n        {\n            if (p->ls)\n            {\n                p = p->ls;\n                while (p->rs)\n                {\n                    p = p->rs;\n                }\n                ans = p;\n            }\n            break;\n        }\n        if (p->value < x && p->value > ans->value)\n            ans = p;\n        p = p->value < x ? p->rs : p->ls;\n    }\n    return ans->value;\n}\nint get_suf(AVL_Tree p, int x)\n{\n    AVL_Tree ans = new AVL_node(inf);\n    while (p)\n    {\n        if (p->value == x)\n        {\n            if (p->rs)\n            {\n                p = p->rs;\n                while (p->ls)\n                {\n                    p = p->ls;\n                }\n                ans = p;\n            }\n            break;\n        }\n        if (p->value > x && p->value < ans->value)\n            ans = p;\n        p = p->value < x ? p->rs : p->ls;\n    }\n    return ans->value;\n}\nAVL_Tree root;\nint main()\n{\n    int n, op, x;\n    scanf(\"%d\", &n);\n    for (register int i = 1; i <= n; i++)\n    {\n        scanf(\"%d%d\", &op, &x);\n        switch (op)\n        {\n        case 1:\n            AVL_insert(root, x);\n            break;\n        case 2:\n            AVL_erase(root, x);\n            break;\n        case 3:\n            printf(\"%d\\n\", get_rank(root, x));\n            break;\n        case 4:\n            printf(\"%d\\n\", get_val(root, x));\n            break;\n        case 5:\n            printf(\"%d\\n\", get_pre(root, x));\n            break;\n        case 6:\n            printf(\"%d\\n\", get_suf(root, x));\n            break;\n        default:\n            break;\n        }\n    }\n    return 0;\n}\n```\n\n[今天才学会的AVL树](https://phlzy.github.io/2020/02/12/AVL_Tree/)","tags":["2020寒假","洛谷"]},{"title":"洛谷P1433题解","url":"/2020/02/11/P1433-Solution/","content":"\n### 链接：[P1433](https://www.luogu.com.cn/problem/P1433)   \n<!--more-->\n\n# 题解：\n\n这题我最先尝试了DFS，但是无论如何优化都没有办法过第10个点，所以只好用状压DP做，每个点取或不取是两种状态，并且n的最大值是15，指数次的复杂度也可以接受。用一个二维数组d来保存从某个点出发并经过其它某些点的路径，加上到原点的距离，然后找到在遍历完所有点的路径中最短的一条就是答案。\n\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ndouble x[17], y[17], d[17][33000], ans = -1, a, b;\nvector<pair<double, double> > vxy;\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    vxy.push_back(make_pair(0.0, 0.0));\n    for (int i = 1; i <= n; i++)\n    {\n        scanf(\"%lf%lf\", &a, &b);\n        vxy.push_back(make_pair(a, b));\n    }\n    memset(d, 127, sizeof(d));\n    for (int s = 1; s <= (1 << n) - 1; s++)\n    {\n        for (int i = 1; i <= n; i++)\n        {\n            if ((s & (1 << (i - 1))) == 0)\n                continue;\n            if (s == (1 << (i - 1)))\n            {\n                d[i][s] = 0;\n                continue;\n            }\n            for (int j = 1; j <= n; j++)\n            {\n                if ((s & (1 << (j - 1))) == 0 || i == j)\n                    continue;\n                d[i][s] = min(d[i][s], d[j][s - (1 << (i - 1))] + sqrt((vxy[i].first - vxy[j].first) * (vxy[i].first - vxy[j].first) + (vxy[i].second - vxy[j].second) * (vxy[i].second - vxy[j].second)));\n            }\n        }\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        double s = d[i][(1 << n) - 1] + sqrt(vxy[i].first * vxy[i].first + vxy[i].second * vxy[i].second);\n        if (ans == -1 || ans > s)\n            ans = s;\n    }\n    printf(\"%.2lf\\n\", ans);\n    return 0;\n}\n```\n\n","tags":["2020寒假","洛谷"]},{"title":"洛谷P1508题解","url":"/2020/02/11/P1508-Solution/","content":"\n### 链接：[P1508](https://www.luogu.com.cn/problem/P1508)   \n<!--more-->\n\n# 题解：\n\n题目给的数据虽然有正有负，而且出发点也很奇怪，但是并不需要初始化数据，直接重载一个$max$函数，然后用状态转移方程$f[i][j]=max(f[i-1][j-1],f[i-1][j],f[i-1][j+1])$推就可以了。\n\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint table[210][210], r, c;\nint max(int a,int b,int c)\n{\n    if(a>b)\n        return a > c ? a : c;\n    else\n        return b > c ? b : c;\n}\nint main()\n{\n    scanf(\"%d%d\", &c, &r);\n    for (register int i = 1; i <= c; i++)\n        for (register int j = 1; j <= r; j++)\n            scanf(\"%d\", &table[i][j]);\n    for (register int i = 1; i <= c; i++)\n        for (register int j = 1; j <= r; j++)\n            table[i][j] += max(table[i - 1][j - 1], table[i - 1][j], table[i - 1][j + 1]);\n    printf(\"%d\\n\", max(table[c][(r >> 1)], table[c][(r >> 1) + 1], table[c][(r >> 1) + 2]));\n    return 0;\n}\n```\n\n","tags":["2020寒假","洛谷"]},{"title":"洛谷P2880题解","url":"/2020/02/11/P2880-Solution/","content":"\n### 链接：[P2880](https://www.luogu.com.cn/problem/P2880)\n<!--more-->\n\n# 题解：\n\n区间维护最大值和最小值，离线查询，所以最快的方法是建两个ST表分别维护最大值和最小值，然后查询的时候减一下就好了。\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint ST_max[200001][22], ST_min[200001][22];\ninline int query_max(int left, int right)\n{\n    int k = log2(right - left + 1);\n    return max(ST_max[left][k], ST_max[right - (1 << k) + 1][k]);\n}\ninline int query_min(int left, int right)\n{\n    int k = log2(right - left + 1);\n    return min(ST_min[left][k], ST_min[right - (1 << k) + 1][k]);\n}\nint main()\n{\n    int n, m, left, right;\n    scanf(\"%d%d\", &n, &m);\n    for (register int i = 1; i <= n; i++)\n    {\n        scanf(\"%d\", &ST_max[i][0]);\n        ST_min[i][0] = ST_max[i][0];\n    }\n    for (register int j = 1; j <= 22; j++)\n        for (register int i = 1; i + (1 << j) - 1 <= n; i++)\n            ST_max[i][j] = max(ST_max[i][j - 1], ST_max[i + (1 << (j - 1))][j - 1]);\n    for (register int j = 1; j <= 22; j++)\n        for (register int i = 1; i + (1 << j) - 1 <= n; i++)\n            ST_min[i][j] = min(ST_min[i][j - 1], ST_min[i + (1 << (j - 1))][j - 1]);\n    for (register int i = 1; i <= m; i++)\n    {\n        scanf(\"%d%d\", &left, &right);\n        printf(\"%d\\n\", query_max(left, right) - query_min(left, right));\n    }\n    return 0;\n}\n```\n\n","tags":["2020寒假","洛谷"]},{"title":"CF1296C题解","url":"/2020/02/10/CF1296C-Solution/","content":"\n### 链接：[CF1296C Yet Another Walking Robot](https://codeforces.com/problemset/problem/1296/C) [洛谷CF1296C](https://www.luogu.com.cn/problem/CF1296C)  \n\n- **数据结构 模拟  \\*1500 **\n<!--more-->\n# 思路：\n这题不需要想太多，直接模拟就可以了，寻找整个路径中最大的环，如果没有形成过环就输出-1。可惜在比赛的时候由于不熟悉map和pair的用法，写了个结构体代替pair，结果本地一直CE，最终也没能改对。\n\n```c++\n/*pair基本用法*/\npair<int,double> p1;\ncout << p1.first << \",\" << p1.second << endl; //输出  0,0   \npair<string,int> p2(\"this\",20);\ncout << p2.first << \",\" << p2.second << endl; //输出  this,20\npair<int,int> p3(pair<char,char>('a','b'));\ncout << p3.first << \",\" << p3.second << endl; //输出  97,98\npair<int,string> p4 = make_pair(200,\"hello\");\ncout << p4.first << \",\" << p4.second << endl; //输出  200,hello\n```\n\n\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nstring s;\npair<int, int> p;\nmap<pair<int, int>, int> vis;\nint main()\n{\n    int T, n, l, r;\n    scanf(\"%d\", &T);\n    while (T--)\n    {\n        cin >> n >> s;\n        l = -1, r = n;\n        vis.clear();\n        p = {0, 0};\n        vis[p] = 0;\n        for (int i = 0; i < n; i++)\n        {\n            if (s[i] == 'L')\n                p.first--;\n            if (s[i] == 'R')\n                p.first++;\n            if (s[i] == 'U')\n                p.second++;\n            if (s[i] == 'D')\n                p.second--;\n            if (vis.count(p))\n            {\n                if (i - vis[p] + 1 < r - l + 1)\n                {\n                    l = vis[p];\n                    r = i;\n                }\n            }\n            vis[p] = i + 1;\n        }\n        if (l == -1)\n            printf(\"-1\\n\");\n        else\n            printf(\"%d %d\\n\", l + 1, r + 1);\n    }\n    return 0;\n}\n```\n\n","tags":["2020寒假","CodeForces"]},{"title":"CF1299A题解","url":"/2020/02/10/CF1299A-Solution/","content":"\n### 链接：[CF1299A Anu Has a Function](https://codeforces.com/problemset/problem/1299/A) [洛谷CF1299A](https://www.luogu.com.cn/problem/CF1299A)  \n\n- **暴力 贪心 数学    \\*1500 **\n<!--more-->\n# 思路：\n\n题目中的函数$f:f(x,y)=(x|y)-y$的作用相当于把$x$中所有同时出现在$x$和$y$里面的$1$去掉，即f(x,y)=x&(~y)。显然函数$f$是不满足交换律的，但是x&( ~a)&( ~b)和x&( ~b)&( ~a)是完全一样的。也就是说，对这个数列进行题目中的操作后的结果只和第一个元素的选取有关。于是在比赛的时候我就直接先输出一个最大值然后把剩下的输出，结果WA了，直到第二天我才明白过来可能还有以下的情况：\n\n| 原数组   | 25(11001) | 18(10010) | 9(1001) | 最后结果 |\n| -------- | --------- | --------- | ------- | -------- |\n| 直接贪心 | 25        | 18        | 9       | 0        |\n| 正确答案 | 18        | 9         | 25      | 2        |\n\n所以，第一个元素选取的不一定是最大的元素，而应该是拥有所有数中独一无二的最高位1的那个数。那么只能预处理前后缀然后枚举找出这个数了。\n\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 2;\nint a[maxn], pre[maxn], suf[maxn];\nint main()\n{\n    int n, m, ans = -1, pos = 0, t;\n    scanf(\"%d\", &n);\n    for (register int i = 1; i <= n; i++)\n    {\n        scanf(\"%d\", &a[i]);\n        pre[i] = pre[i - 1] | a[i];\n    }\n    for (register int i = n; i > 0; i--)\n        suf[i] = suf[i + 1] | a[i];\n    for (register int i = 1; i <= n; i++)\n    {\n        t = pre[i - 1] | suf[i + 1];\n        if ((a[i] | t) - t > ans)\n        {\n            ans = (a[i] | t) - t;//这个数可能会是0,所以ans初值需要小于0\n            pos = i;\n        }\n    }\n    printf(\"%d \", a[pos]);\n    for (register int i = 1; i <= n; i++)\n        if (i != pos)\n            printf(\"%d \", a[i]);\n    return 0;\n}\n```\n\n","tags":["2020寒假","CodeForces"]},{"title":"洛谷P1168题解","url":"/2020/02/10/P1168-Solution/","content":"\n### 链接：[P1168](https://www.luogu.com.cn/problem/P1168)\n<!--more-->\n\n# 题解：\n\n标签是线段树和树状数组，但是用这两个都不太好实现，如果每加入一个数据就排序一次的话又会超时。排序超时的原因是每次排序的时候都重复处理了一些没有用处的数据，通过观察每次加入数据的过程可以发现，计算新的中位数只需要考虑新加进去的两个数和原来中位数以及原来中位数两侧的数即可，其它的数都是不需要考虑的，但是并不能保证以后是否会用到它们。堆正是一个符合这种要求的数据结构，维护一个大根堆和一个小根堆，将小于中位数的放在大根堆里，将大于中位数的放在大根堆里，将中位数单独拿出放在外面，新数加入时比较新数、中位数和两个堆顶的大小并重新分配这5个元素即可。\n\n\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\npriority_queue<int, vector<int>, greater<int>> rht;\npriority_queue<int, vector<int>> lft;\nint main()\n{\n    int mid, a[2], n;\n    scanf(\"%d%d\", &n, &mid);\n    printf(\"%d\\n\", mid);\n    if (n == 1)\n        return 0;\n    scanf(\"%d%d\", &a[0], &a[1]);\n    if (mid < min(a[0], a[1]))\n    {\n        lft.push(mid);\n        mid = min(a[0], a[1]);\n        rht.push(max(a[0], a[1]));\n    }\n    else if (mid > max(a[0], a[1]))\n    {\n        rht.push(mid);\n        mid = max(a[0], a[1]);\n        lft.push(min(a[0], a[1]));\n    }\n    else\n    {\n        lft.push(min(a[0], a[1]));\n        rht.push(max(a[0], a[1]));\n    }\n    printf(\"%d\\n\", mid);\n    for (register int i = 4; i <= n; i++)\n    {\n        scanf(\"%d\", &a[i & 1]);\n        if (i & 1)\n        {\n            if (mid < min(a[0], a[1]))\n            {\n                lft.push(mid);\n                mid = rht.top();\n                rht.pop();\n                if (mid > a[0])\n                    swap(mid, a[0]);\n                if (mid > a[1])\n                    swap(mid, a[1]);\n                rht.push(a[0]);\n                rht.push(a[1]);\n            }\n            else if (mid > max(a[0], a[1]))\n            {\n                rht.push(mid);\n                mid = lft.top();\n                lft.pop();\n                if (mid < a[0])\n                    swap(mid, a[0]);\n                if (mid < a[1])\n                    swap(mid, a[1]);\n                lft.push(a[0]);\n                lft.push(a[1]);\n            }\n            else\n            {\n                lft.push(min(a[0], a[1]));\n                rht.push(max(a[0], a[1]));\n            }\n            printf(\"%d\\n\", mid);\n        }\n    }\n    return 0;\n}\n```\n\n","tags":["2020寒假","洛谷"]},{"title":"洛谷P1434题解","url":"/2020/02/10/P1434-Solution/","content":"\n### 链接：[P1434](https://www.luogu.com.cn/problem/P1434)   \n<!--more-->\n\n# 题解：\n\n本题看起来可以用DFS或者状压DP来做，但是由于滑雪的规则是从高处滑向低处，所以可以得到以下的递推关系：\n\n- 从最低处开始的路径长度一定为1，四周均不能下滑的路径长度也是1；\n- 高度大于自身的区域在接下来的下滑过程中一定不会用到；\n- 如果四周有可以选择下滑的区域，选择路径长度最大的区域下滑一定可以得到最大的路径。\n\n所以可以用贪心+递推，先把每一块按照高度顺序排序，然后从低到高依次推出每块的最大路径，顺便找出最大值就行了。\n\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nstruct node\n{\n    int way, val, c, r;\n    node() : way(1), val(0), c(0), r(0) {}//路径长度的下限是1\n};\nbool cmp(node a, node b)\n{\n    return a.val < b.val;\n}\nvector<node> v;\nnode hill[102][102];\nint r, c, tr, tc;\nint main()\n{\n    int ans = 0;\n    scanf(\"%d%d\", &r, &c);\n    for (register int i = 1; i <= r; i++)\n    {\n        for (register int j = 1; j <= c; j++)\n        {\n            scanf(\"%d\", &hill[i][j].val);\n            hill[i][j].c = j;\n            hill[i][j].r = i;\n            v.push_back(hill[i][j]);\n        }\n    }\n    sort(v.begin(), v.end(), cmp);\n    for (register int i = 0; i < r * c; i++)\n    {\n        tr = v[i].r;\n        tc = v[i].c;\n        if (tc > 1 && hill[tr][tc].val > hill[tr][tc - 1].val)\n            hill[tr][tc].way = max(hill[tr][tc].way, hill[tr][tc - 1].way + 1);\n        if (tr > 1 && hill[tr][tc].val > hill[tr - 1][tc].val)\n            hill[tr][tc].way = max(hill[tr][tc].way, hill[tr - 1][tc].way + 1);\n        if (tc < c && hill[tr][tc].val > hill[tr][tc + 1].val)\n            hill[tr][tc].way = max(hill[tr][tc].way, hill[tr][tc + 1].way + 1);\n        if (tr < r && hill[tr][tc].val > hill[tr + 1][tc].val)\n            hill[tr][tc].way = max(hill[tr][tc].way, hill[tr + 1][tc].way + 1);\n        ans = max(ans, hill[tr][tc].way);\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n```\n\n","tags":["2020寒假","洛谷"]},{"title":"C++ string功能总结","url":"/2020/02/09/Cpp_String/","content":"\n\n\n### 简介\n\nstring的用法总结。\n\n<!--more-->\n\n**声明、赋值、输入输出等**\n\n```c++\nstring a,b=\"123ab\",c;\na=\"654321\";\ncin>>a;//读到空格\ngetline(cin,a);//一行\ncout<<a;\nswap(a,b);\n```\n\n**运算与比较**\n\n重载了$+$运算符连接string，根据字典序比较大小。\n**函数**\n\n```c++\nprintf(\"%s\",a.c_str());//这个函数返回一个char类型的指针char*,C风格输出\nint len=a.length();\na.insert(2,b);//在a[1]和a[2]之间插入string b\na.erase(2,3);//删除从a[2]到a[4]的连续3个字符\na.clear();\na.replace(2,3,b);//将从a[2]到a[4]的连续3个字符替换成string b\na.find(b,pos);//从pos开始找第一个string b出现的位置并返回,pos不写默认为0,找不到返回4294967295\na.rfind(b,pos);//倒着找\na.find_first_of(b,pos);//从a的第pos(默认0)开始向后查找,找到第一个出现在b中的字符就返回位置\na.find_last_of(b,pos);//倒着找\na.find_first_not_of(b,pos),a.find_first_not_of(b,pos);//补集\na.substr(start,len);//子串,len不写就到结尾\n//int转string\nostringstream outs; //输出字符串流\nint x = 12; \nouts << x; //向输出字符串流中输出x的内容 \nstring a=outs.str(); //利用字符串流的str函数获取流中的内容\n//string转int\nstring a=\"12\";\nistringstream ins(a); //输入字符串流，流的内容初始化为a\nint x; \nins >> x; //从is流中读入并存入x中\n```\n\n\n","tags":["Cpp"]},{"title":"洛谷P1032题解","url":"/2020/02/09/P1032-Solution/","content":"\n### 链接：[P1032](https://www.luogu.com.cn/problem/P1032)\n<!--more-->\n\n# 题解：\n\n题意比较明确是用BFS找到最优解，用multimap存放变换方式，用queue的push和pop来模拟每一种替换方式的选择。虽然这题数据范围不大，但是直接BFS还是会在第四个点超时，要用一个map来去重。相比迭代加深和KMP的做法，用STL可以大大简化思考和写代码的难度。\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nmultimap<string, string> tot;\nmap<string, int> vis;\nqueue<string> q;\nstring a, b, org, tran, now, tmp;\nint main()\n{\n    cin >> a >> b;\n    while (cin >> org >> tran)\n        tot.insert(make_pair(org, tran));\n    q.push(a);\n    vis.insert(make_pair(a, 0));\n    while (!q.empty())\n    {\n        now = q.front();\n        q.pop();\n        int num = vis[now];\n        if (num > 10)\n            break;\n        if (now == b)//BFS第一个搜到的就是正解\n        {\n            printf(\"%d\\n\", num);\n            return 0;\n        }\n        for (auto it : tot)\n        {\n            tmp = now;\n            int pos = 0;\n            while ((pos = tmp.find(it.first, pos)) != -1)//可以替换\n            {\n                now.replace(pos, it.first.size(), it.second);\n                if (vis.count(now) == 0)//如果第一次出现就放进去,不是第一次的话就不是最好的选择\n                {\n                    vis[now] = num + 1;\n                    q.push(now);\n                }\n                now = tmp;\n                pos++;\n            }\n        }\n    }\n    printf(\"NO ANSWER!\\n\");\n    return 0;\n}\n```\n\n","tags":["2020寒假","洛谷"]},{"title":"洛谷P1531题解","url":"/2020/02/09/P1531-Solution/","content":"\n### 链接：[P1531](https://www.luogu.com.cn/problem/P1531) [HDU-1754](https://vjudge.net/problem/HDU-1754)\n<!--more-->\n\n# 题解：\n\n区间单点修改和查询最值，可以用线段树解决，但是树状数组也支持单点修改且更容易写，只是传统的树状数组不能支持查询区间最值。考虑到树状数组的点上存的是区间的最值，那么只要把输入的数据存起来，然后从查询的区间的右端点开始向左判断点上储存的区间是否超过左端点，如果不超过就进行一次比较并向左移动lowbit位，否则与原始数组单点比较，然后左移一位重新判断。修改的操作除了更新树状数组里面的值，也要把原始数据改掉。\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>//洛谷P1531,HDU-1754不用判断s[a]与b的大小\nusing namespace std;\nconst int maxn = 2e5 + 5;\nint tree[maxn], s[maxn], n, m;\ninline int lowbit(int i)\n{\n    return i & -i;\n}\nvoid update(int x, int k)\n{\n    for (; x <= n; x += lowbit(x))\n        tree[x] = max(tree[x], k);\n}\nint query(int a, int b)\n{\n    int ans = 0;\n    while (a <= b)\n    {\n        while (b - lowbit(b) >= a)\n        {\n            ans = max(ans, tree[b]);\n            b -= lowbit(b);\n        }\n        ans = max(ans, s[b]);\n        b--;\n    }\n    return ans;\n}\nint main()\n{\n    int a, b;\n    char op;\n    cin >> n >> m;\n    for (register int i = 1; i <= n; i++)\n    {\n        scanf(\"%d\", &s[i]);\n        update(i, s[i]);\n    }\n    while (m--)\n    {\n        cin >> op >> a >> b;\n        if (op == 'U')\n        {\n            if (s[a] < b)\n            {\n                s[a] = b;\n                update(a, b);\n            }\n        }\n        else\n            printf(\"%d\\n\", query(a, b));\n    }\n    return 0;\n}\n```\n\n","tags":["2020寒假","洛谷"]},{"title":"KMP算法","url":"/2020/02/08/KMP/","content":"\n### 简介：\n\nKMP算法是一种字符串匹配算法。朴素的暴力匹配法应对随机数据表现很好，但是它的最坏情况的时间复杂度是$O(m(n-1))$，而KMP算法的时间复杂度是$O(m+n)$。[P3375模板题](https://www.luogu.com.cn/problem/P3375)\n\n<!--more-->\n\n**原理：**\n\n朴素的匹配算法需要两个指针$i$，$j$，其中$i$指向文本中匹配到的位置，$j$指向模式串中的位置。当某次匹配失败后，$i$指针可能会需要向文本头部回溯，而KMP算法可以防止这样的回溯从而提高匹配的效率，在某个位置匹配失败后利用已知的信息将模式串移动一段。\n\n**预处理：**\n\n构造next数组记录**到模式串上某个字符为止的模式串前缀**的**真前缀和真后缀最大相同的位置**，还要找出**所有模式串前缀的前缀和后缀最大相同的位置**，以此分辨模式串换位时有没有完成匹配。\n\n所以next数组记录的位置$next_i$是一个不大于$i$的值，满足模式串中从第$1$个字符到第$next_i$个字符形成的子串和中从第$i-next_i+1$个字符到第$i$个字符形成的子串完全相同。\n\n代码实现：\n\n```c++\nvoid getnext(string t)\n{\n    int j = 0, k = -1;\n    n[0] = -1;\n    while (j < t.length - 1)\n    {\n        if (k == -1 || t[j] == t[k])\n            n[++j] = ++k;\n        else\n            k = n[k];\n    }\n}\n```\n\n在模式串自我匹配的过程中，默认$next_0=-1$，而$next_1$一定是0。例如向后匹配到$m$时，如果第$next_m+1$个字符和第$m+1$个字符相等，那么$next_{m+1}=next_m+1$，这是显然的；如果匹配失败，则说明$next_{m+1}$一定是小于$next_m$的，由于$next_m\\le m$，我们又可以从next数组中找出第$next_m$个字符所对应的值，即第$m$个字符的**最长相同真前/后缀**不能匹配后，使用**第二长的相同真前/后缀**进行匹配，以此类推，因此有$k = n[k]$。\n\n**匹配：**\n\n```c++\nvoid KMP()\n{\n    int i = 0, j = 0;\n    while (i < lena)\n    {\n        if (j == -1 || a[i] == b[j])\n            i++, j++;//正常向下匹配\n        else\n            j = n[j];//失败，移动模式串\n        if (j == lenb)\n            printf(\"%d\\n\", i - lenb + 1), j = n[j];//成功\n    }\n}\n```\n\n匹配的过程非常直观。\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e6 + 3;\nint lena, lenb;\nint n[maxn];\nstring a, b;\nvoid get_next()\n{\n    int i = 0, j = -1;\n    n[0] = -1;\n    while (i < lenb)\n    {\n        if (j == -1 || b[i] == b[j])\n            n[++i] = ++j;\n        else\n            j = n[j];\n    }\n}\nvoid KMP()\n{\n    int i = 0, j = 0;\n    while (i < lena)\n    {\n        if (j == -1 || a[i] == b[j])\n            i++, j++;\n        else\n            j = n[j];\n        if (j == lenb)\n            printf(\"%d\\n\", i - lenb + 1), j = n[j];\n    }\n}\nint main()\n{\n    cin >> a >> b;\n    lena = a.length();\n    lenb = b.length();\n    get_next();\n    KMP();\n    for (int i = 1; i <= lenb; i++)\n        printf(\"%d \", n[i]);\n    return 0;\n}\n```\n\n","tags":["洛谷","算法"]},{"title":"洛谷P3368题解","url":"/2020/02/08/P3368-Solution/","content":"\n### 链接：[P3368](https://www.luogu.com.cn/problem/P3368)\n<!--more-->\n\n# 题解：\n\n要求使用树状数组进行区间修改和单点查询。树状数组的查询会得到前面所有元素的和，所以对原始数据进行一次差分操作可以使查询的结果变成单点的值，而进行差分操作后原先的单点修改也可以进行区间的修改。这题用线段树做也可以过，但是耗时是树状数组的两倍多，代码长度也更长。\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 5e5 + 2;\nint tree[maxn], n, m, k, x, y, p, temp;\ninline int lowbit(int i)\n{\n    return i & -i;\n}\nint query(int x)\n{\n    int ans = 0;\n    for (; x; x ^= lowbit(x))\n        ans = ans + tree[x];\n    return ans;\n}\nvoid update(int x, int k)\n{\n    for (; x <= n; x += lowbit(x))\n        tree[x] += k;\n}\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    for (register int i = 1; i <= n; i++)\n    {\n        scanf(\"%d\", &k);\n        update(i, k - temp);\n        temp = k;\n    }\n    while (m--)\n    {\n        scanf(\"%d\", &k);\n        if (k == 1)\n        {\n            scanf(\"%d%d%d\", &x, &y, &p);\n            update(x, p);\n            update(y + 1, -p);\n        }\n        else\n        {\n            scanf(\"%d\", &x);\n            printf(\"%d\\n\", query(x));\n        }\n    }\n    return 0;\n}\n```\n\n","tags":["2020寒假","洛谷"]},{"title":"UVa11992题解","url":"/2020/02/08/UVa11992-Solution/","content":"\n### 链接：[UVA11992](https://www.luogu.com.cn/problem/UVA11992)\n<!--more-->\n\n# 题解：\n\n本题对于矩阵的每一行都需要开一棵线段树来维护，而且需要支持三种查询操作和两种修改操作，因此需要用结构体将多种标记保存在一个点上。每次进行赋值操作时都要重置加法标记中的值。当然，本题最大的难点还是在代码的实现上。\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 5e4 + 5, INF = 1e9;\nstruct SegmentTree\n{\n    int l, r, sum, maxn, minn, tag, cover;\n};\nSegmentTree tree[21][MAXN << 2];\nint length, width, m, lx, rx, ly, ry, op, val, sum, maxn, minn;\ninline void push_up(int h, int node)\n{\n    tree[h][node].sum = tree[h][node << 1].sum + tree[h][(node << 1) | 1].sum;\n    tree[h][node].maxn = max(tree[h][node << 1].maxn, tree[h][(node << 1) | 1].maxn);\n    tree[h][node].minn = min(tree[h][node << 1].minn, tree[h][(node << 1) | 1].minn);\n}\nvoid build(int h, int l, int r, int node)\n{\n    tree[h][node].l = l, tree[h][node].r = r, tree[h][node].cover = -1;\n    if (l == r)\n    {\n        tree[h][node].sum = tree[h][node].maxn = tree[h][node].minn = 0;\n        return;\n    }\n    int mid = (l + r) >> 1;\n    build(h, l, mid, node << 1);\n    build(h, mid + 1, r, (node << 1) | 1);\n    push_up(h, node);\n}\ninline void push_down(int h, int node)\n{\n    int ls = node << 1, rs = ls | 1;\n    int lx = (tree[h][ls].r - tree[h][ls].l + 1);\n    int rx = (tree[h][rs].r - tree[h][rs].l + 1);\n    if (tree[h][node].cover != -1)\n    {\n        tree[h][ls].maxn = tree[h][node].cover;\n        tree[h][rs].maxn = tree[h][node].cover;\n        tree[h][ls].minn = tree[h][node].cover;\n        tree[h][rs].minn = tree[h][node].cover;\n        tree[h][ls].sum = tree[h][node].cover * lx;\n        tree[h][rs].sum = tree[h][node].cover * rx;\n        tree[h][ls].cover = tree[h][rs].cover = tree[h][node].cover;\n        tree[h][ls].tag = tree[h][rs].tag = 0;\n        tree[h][node].cover = -1;\n    }\n    if (tree[h][node].tag)\n    {\n        tree[h][ls].maxn += tree[h][node].tag;\n        tree[h][rs].maxn += tree[h][node].tag;\n        tree[h][ls].minn += tree[h][node].tag;\n        tree[h][rs].minn += tree[h][node].tag;\n        tree[h][ls].sum += tree[h][node].tag * lx;\n        tree[h][rs].sum += tree[h][node].tag * rx;\n        tree[h][ls].tag += tree[h][node].tag;\n        tree[h][rs].tag += tree[h][node].tag;\n        tree[h][node].tag = 0;\n    }\n}\nvoid add(int h, int l, int r, int val, int node)\n{\n    if (l <= tree[h][node].l && r >= tree[h][node].r)\n    {\n        tree[h][node].sum += (tree[h][node].r - tree[h][node].l + 1) * val;\n        tree[h][node].maxn += val, tree[h][node].minn += val;\n        tree[h][node].tag += val;\n        return;\n    }\n    push_down(h, node);\n    int mid = (tree[h][node].l + tree[h][node].r) >> 1;\n    if (l <= mid)\n        add(h, l, r, val, node << 1);\n    if (r > mid)\n        add(h, l, r, val, (node << 1) | 1);\n    push_up(h, node);\n}\nvoid cover(int h, int l, int r, int val, int node)\n{\n    if (l <= tree[h][node].l && r >= tree[h][node].r)\n    {\n        tree[h][node].sum = (tree[h][node].r - tree[h][node].l + 1) * val;\n        tree[h][node].maxn = tree[h][node].minn = val;\n        tree[h][node].cover = val;\n        tree[h][node].tag = 0;\n        return;\n    }\n    push_down(h, node);\n    int mid = (tree[h][node].l + tree[h][node].r) >> 1;\n    if (l <= mid)\n        cover(h, l, r, val, node << 1);\n    if (r > mid)\n        cover(h, l, r, val, (node << 1) | 1);\n    push_up(h, node);\n}\nint query_sum(int h, int l, int r, int node)\n{\n    if (l <= tree[h][node].l && r >= tree[h][node].r)\n        return tree[h][node].sum;\n    int mid = (tree[h][node].l + tree[h][node].r) >> 1, res = 0;\n    push_down(h, node);\n    if (l <= mid)\n        res += query_sum(h, l, r, node << 1);\n    if (r > mid)\n        res += query_sum(h, l, r, (node << 1) | 1);\n    return res;\n}\nint query_max(int h, int l, int r, int node)\n{\n    if (l <= tree[h][node].l && r >= tree[h][node].r)\n        return tree[h][node].maxn;\n    int mid = (tree[h][node].l + tree[h][node].r) >> 1, res = 0;\n    push_down(h, node);\n    if (l <= mid)\n        res = max(res, query_max(h, l, r, node << 1));\n    if (r > mid)\n        res = max(res, query_max(h, l, r, (node << 1) | 1));\n    return res;\n}\nint query_min(int h, int l, int r, int node)\n{\n    if (l <= tree[h][node].l && r >= tree[h][node].r)\n        return tree[h][node].minn;\n    int mid = (tree[h][node].l + tree[h][node].r) >> 1, res = INF;\n    push_down(h, node);\n    if (l <= mid)\n        res = min(res, query_min(h, l, r, node << 1));\n    if (r > mid)\n        res = min(res, query_min(h, l, r, (node << 1) | 1));\n    return res;\n}\nint main()\n{\n    while (scanf(\"%d%d%d\", &length, &width, &m) == 3)\n    {\n        memset(tree, 0, sizeof(tree));\n        for (register int i = 1; i <= length; i++)\n            build(i, 1, width, 1);\n        while (m--)\n        {\n            scanf(\"%d%d%d%d%d\", &op, &lx, &ly, &rx, &ry);\n            if (op == 1)\n            {\n                scanf(\"%d\", &val);\n                for (register int j = lx; j <= rx; j++)\n                    add(j, ly, ry, val, 1);\n            }\n            else if (op == 2)\n            {\n                scanf(\"%d\", &val);\n                for (register int j = lx; j <= rx; j++)\n                    cover(j, ly, ry, val, 1);\n            }\n            else\n            {\n                sum = maxn = 0, minn = INF;\n                for (register int j = lx; j <= rx; j++)\n                {\n                    sum += query_sum(j, ly, ry, 1);\n                    maxn = max(maxn, query_max(j, ly, ry, 1));\n                    minn = min(minn, query_min(j, ly, ry, 1));\n                }\n                printf(\"%d %d %d\\n\", sum, minn, maxn);\n            }\n        }\n    }\n}\n```\n\n","tags":["2020寒假","UVa"]},{"title":"洛谷P1083题解","url":"/2020/02/07/P1083-Solution/","content":"\n### 链接：[P1083](https://www.luogu.com.cn/problem/P1083)\n<!--more-->\n\n# 题解：\n\n这题虽然可以用二分答案和差分数组来做，但是看到区间修改和查询的操作我的第一反应就是线段树，并且线段树的时间复杂度应该也能满足$10^6$的数据范围。因此开一棵维护区间最小值的线段树，每一次修改前进行一次询问，如果待修改区间的最小值小于输入的值就结束。但是这样写会超时，需要进行优化。考虑到查询操作的时间复杂度是$O(\\log n)$的，而线段树的性质决定了树根节点的值就是整个区间的最小值，所以一旦有一个节点的值变成了负数，树根的值也会变成负数，只需要查询树根的值就可以了。这样把$O(\\log n)$的查询优化成$O(1)$，整个程序快了一倍，就可以通过了。\n\n\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1000002;\nint a[maxn], seg_tree[maxn << 2], tag[maxn << 2];\nvoid push_up_min(int p)\n{\n    seg_tree[p] = min(seg_tree[p << 1], seg_tree[p << 1 | 1]);\n}\nvoid build(int p, int l, int r)\n{\n    tag[p] = 0;\n    if (l == r)\n    {\n        seg_tree[p] = a[l];\n        return;\n    }\n    int mid = (l + r) >> 1;\n    build(p << 1, l, mid);\n    build(p << 1 | 1, mid + 1, r);\n    push_up_min(p);\n}\nvoid push_down(int p, int l, int r)\n{\n    int mid = (l + r) >> 1;\n    tag[p << 1] += tag[p];\n    seg_tree[p << 1] += tag[p];\n    tag[p << 1 | 1] += tag[p];\n    seg_tree[p << 1 | 1] += tag[p];\n    tag[p] = 0;\n}\nvoid update(int newl, int newr, int l, int r, int p, int k)\n{\n    if (newl <= l && r <= newr)\n    {\n        seg_tree[p] += k;\n        tag[p] += k;\n        return;\n    }\n    push_down(p, l, r);\n    int mid = (l + r) >> 1;\n    if (newl <= mid)\n        update(newl, newr, l, mid, p << 1, k);\n    if (newr > mid)\n        update(newl, newr, mid + 1, r, p << 1 | 1, k);\n    push_up_min(p);\n}\nint main()\n{\n    int n, m, k, l, r;\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; i++)\n        scanf(\"%d\", &a[i]);\n    build(1, 1, n);\n    for (int i = 1; i <= m; i++)\n    {\n        scanf(\"%d%d%d\", &k, &l, &r);\n        update(l, r, 1, n, 1, -k);\n        if (seg_tree[1] < 0)\n        {\n            printf(\"-1\\n%d\", i);\n            return 0;\n        }\n    }\n    printf(\"0\\n\");\n    return 0;\n}\n```\n\n","tags":["2020寒假","洛谷"]},{"title":"洛谷P3373题解","url":"/2020/02/07/P3373-Solution/","content":"\n### 链接：[P3373](https://www.luogu.com.cn/problem/P3373)\n<!--more-->\n\n# 题解：\n\n题目要求对线段树进行两种修改和一种查询操作，一个lazy-tag难以完成加和乘的操作，故需要设置两个，于是代码就变得复杂了很多。首先在向下推标记时，先处理加法标记和先处理乘法标记的效果是不一样的。如果先处理加法，在以后的修改操作中就有可能出现非整数的运算，而先处理乘法则不会。所以应该选择先处理乘法，同时对线段树模板中的$push\\_down()$函数和$update()$函数作相应的修改，并增加一个更新乘法的函数。本题的思维难度并不是很大，但是代码实现过程很麻烦，需要注意很多细节。\n\n\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 2;\nlong long a[maxn], seg_tree[maxn << 2], tag_p[maxn << 2], tag_m[maxn << 2], mod;\nvoid push_up_sum(long long p)\n{\n    seg_tree[p] = (seg_tree[p << 1] + seg_tree[p << 1 | 1]) % mod;\n}\nvoid build(long long p, long long l, long long r)\n{\n    tag_p[p] = 0;\n    tag_m[p] = 1;\n    if (l == r)\n    {\n        seg_tree[p] = a[l] % mod;\n        return;\n    }\n    long long mid = (l + r) >> 1;\n    build(p << 1, l, mid);\n    build(p << 1 | 1, mid + 1, r);\n    push_up_sum(p);\n}\nvoid push_down(long long p, long long l, long long r)\n{\n    long long mid = (l + r) >> 1, ls = p << 1, rs = ls | 1;\n    //modify sons' value\n    seg_tree[ls] = seg_tree[ls] * tag_m[p] % mod;\n    seg_tree[ls] = (seg_tree[ls] + tag_p[p] * (mid - l + 1)) % mod;\n    seg_tree[rs] = seg_tree[rs] * tag_m[p] % mod;\n    seg_tree[rs] = (seg_tree[rs] + tag_p[p] * (r - mid)) % mod;\n    //modify sons' tags\n    tag_m[ls] = tag_m[ls] * tag_m[p] % mod;\n    tag_m[rs] = tag_m[rs] * tag_m[p] % mod;\n    tag_p[ls] = tag_p[ls] * tag_m[p] % mod;\n    tag_p[rs] = tag_p[rs] * tag_m[p] % mod;\n    tag_p[ls] = (tag_p[ls] + tag_p[p]) % mod;\n    tag_p[rs] = (tag_p[rs] + tag_p[p]) % mod;\n    //reset father's tag\n    tag_p[p] = 0;\n    tag_m[p] = 1;\n}\nvoid update_p(long long newl, long long newr, long long l, long long r, long long p, long long k)\n{\n    if (newl <= l && r <= newr)\n    {\n        seg_tree[p] = (seg_tree[p] + k * (r - l + 1)) % mod;\n        tag_p[p] = (tag_p[p] + k) % mod;\n        return;\n    }\n    push_down(p, l, r);\n    long long mid = (l + r) >> 1;\n    if (newl <= mid)\n        update_p(newl, newr, l, mid, p << 1, k);\n    if (newr > mid)\n        update_p(newl, newr, mid + 1, r, p << 1 | 1, k);\n    push_up_sum(p);\n}\nvoid update_m(long long newl, long long newr, long long l, long long r, long long p, long long k)\n{\n    if (newl <= l && r <= newr)\n    {\n        seg_tree[p] = seg_tree[p] * k % mod;\n        tag_p[p] = tag_p[p] * k % mod;\n        tag_m[p] = tag_m[p] * k % mod;\n        return;\n    }\n    push_down(p, l, r);\n    long long mid = (l + r) >> 1;\n    if (newl <= mid)\n        update_m(newl, newr, l, mid, p << 1, k);\n    if (newr > mid)\n        update_m(newl, newr, mid + 1, r, p << 1 | 1, k);\n    push_up_sum(p);\n}\nlong long query(long long q_x, long long q_y, long long l, long long r, long long p)\n{\n    if (q_x <= l && r <= q_y)\n        return seg_tree[p];\n    long long ans = 0, mid = (l + r) >> 1;\n    push_down(p, l, r);\n    if (q_x <= mid)\n        ans = (ans + query(q_x, q_y, l, mid, p << 1)) % mod;\n    if (q_y > mid)\n        ans = (ans + query(q_x, q_y, mid + 1, r, p << 1 | 1)) % mod;\n    return ans;\n}\nint main()\n{\n    int n, m, k;\n    long long b, c, d;\n    scanf(\"%d%d%d\", &n, &m, &mod);\n    for (int i = 1; i <= n; i++)\n        scanf(\"%lld\", &a[i]);\n    build(1, 1, n);\n    while (m--)\n    {\n        scanf(\"%d\", &k);\n        if (k == 1)\n        {\n            scanf(\"%lld%lld%lld\", &b, &c, &d);\n            update_m(b, c, 1, n, 1, d);\n        }\n        else if (k == 2)\n        {\n            scanf(\"%lld%lld%lld\", &b, &c, &d);\n            update_p(b, c, 1, n, 1, d);\n        }\n        else\n        {\n            scanf(\"%lld%lld\", &b, &c);\n            printf(\"%lld\\n\", query(b, c, 1, n, 1));\n        }\n    }\n    return 0;\n}\n```\n\n","tags":["2020寒假","洛谷"]},{"title":"Trie","url":"/2020/02/07/Trie/","content":"\n### 简介：\n\n**Trie**（字典树、前缀树）可以存储字符串并进行查询、修改等操作。Trie是一棵多叉树，每条边上都有一个字符，从根到某个点的路径就是一个字符串。\n\n<!--more-->\n\n本文的字典树代码以[P2580](https://www.luogu.com.cn/problem/P2580)为例。\n\n#### 节点：\n\nTrie的根节点是空的，因为每个单词的首字母几乎不可能全部相同。Trie的建树方式类似于数组模拟链表，先定义结构体node存放字符，node中子节点的数量由字符的种类决定，此外node中至少还需要包含一个判断单词结尾的标记。代码如下：\n\n```c++\nstruct node\n{\n    int cnt;\n    int son[26];//如果只有英文字母且不区分大小写\n    bool isword;\n    node()//构造函数（以备不时之需）\n    {\n        cnt = 0;\n        memset(son, 0, sizeof(son));\n        isword = false;\n    }\n};\n```\n\n#### 建树/插入：\n\n每次都从根开始，逐渐向下，如果后面空了就申请一个新的节点连在后面。代码如下：\n\n```c++\nint num = 0;\nvoid insert(char s[])\n{\n    int t, len = strlen(s);\n    int pos = root;\n    for (int i = 0; i < len; i++)\n    {\n        t = (int)s[i] - 'a';\n        if (!trie[pos].son[t])\n            trie[pos].son[t] = ++num;\n        pos = trie[pos].son[t];\n    }\n    trie[pos].isword = true;\n}\n```\n\n#### 查询：\n\n和插入非常相似，代码如下：\n\n```c++\nvoid check(char s[])\n{\n    int t, pos = root, len = strlen(s);\n    for (int i = 0; i < len; i++)\n    {\n        t = (int)s[i] - 'a';\n        if (!trie[pos].son[t])\n        {\n            printf(\"WRONG\\n\");\n            return;\n        }\n        pos = trie[pos].son[t];\n    }//查询结束，根据题意判断\n    if (!trie[pos].isword){\n        printf(\"WRONG\\n\");\n        return;\n    }\n    if (!trie[pos].cnt){\n        trie[pos].cnt++;\n        printf(\"OK\\n\");\n        return;\n    }\n    printf(\"REPEAT\\n\");\n    return;\n}\n```\n#### 删除：\n\n字典树删除单词的要求很少见，如果需要删除的单词是其它单词的前缀，只需要更改它的判断标记即可；如果它有其它的分支，就删除最后一个分支后面的节点；如果它是一个单独的分支，就删除整个单词。\n\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 7e5, root = 0;\nint n, m, num;\nstruct node\n{\n    int cnt;\n    int son[26];\n    bool isword;\n};\nnode trie[maxn];\nvoid insert(char s[])\n{\n    int t, len = strlen(s);\n    int pos = root;\n    for (int i = 0; i < len; i++)\n    {\n        t = (int)s[i] - 'a';\n        if (!trie[pos].son[t])\n            trie[pos].son[t] = ++num;\n        pos = trie[pos].son[t];\n    }\n    trie[pos].isword = true;\n}\nvoid check(char s[])\n{\n    int t, pos = root, len = strlen(s);\n    for (int i = 0; i < len; i++)\n    {\n        t = (int)s[i] - 'a';\n        if (!trie[pos].son[t])\n        {\n            printf(\"WRONG\\n\");\n            return;\n        }\n        pos = trie[pos].son[t];\n    }\n    if (!trie[pos].isword)\n    {\n        printf(\"WRONG\\n\");\n        return;\n    }\n    if (!trie[pos].cnt)\n    {\n        trie[pos].cnt++;\n        printf(\"OK\\n\");\n        return;\n    }\n    printf(\"REPEAT\\n\");\n    return;\n}\nint main()\n{\n    char name[100];\n    cin >> n;\n    for (int i = 1; i <= n; ++i)\n    {\n        cin >> name;\n        insert(name);\n    }\n    cin >> m;\n    for (int i = 1; i <= m; ++i)\n    {\n        cin >> name;\n        check(name);\n    }\n    return 0;\n}\n```\n\n","tags":["数据结构","洛谷"]},{"title":"归并排序","url":"/2020/02/06/Merge_Sort/","content":"\n### 简介：\n\n归并排序是一种时间复杂度$ O(n\\log n)$，空间复杂度$O(n)$的稳定排序算法，它的原理是将序列不断二分只到只剩一个元素后再进行合并操作，在合并的过程中通过比较进行排序。该算法除了可以排序，还可以计算区间的逆序对数。\n\n<!--more-->\n\n- 链接：[P1908逆序对](https://www.luogu.com.cn/problem/P1908)，[P1309瑞士轮](https://www.luogu.com.cn/problem/P1309)。\n\n**操作过程**\n\n先采用递归的方式将区间不断二分，全部分成只含有一个元素的区间后进行合并。只含有一个元素的区间内部必然是有序的，将两个有序的区间合并时只要用两个指针指向两个小区间的头部并比较指针指向的值，将更小（大）的值放进辅助空间并将相应的指针向后移动。两个指针都到达区间尾部时就可以用辅助空间的新数组覆盖原来的两个区间，合并操作就完成了。\n\n**代码（P1908）：**\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 5E5 + 5;\nint a[maxn], temp[maxn], n;\nlong long ans;\nvoid mergesort(int l, int r)\n{\n    if (l == r)\n        return;\n    int mid = (l + r) >> 1, i = l, j = mid + 1, k = l;\n    mergesort(l, mid);\n    mergesort(mid + 1, r);\n    while (i <= mid && j <= r)\n    {\n        if (a[i] <= a[j])\n            temp[k++] = a[i++];\n        else\n        {\n            temp[k++] = a[j++];\n            ans += mid - i + 1;\n        }\n    }\n    while (i <= mid)\n        temp[k++] = a[i++];\n    while (j <= r)\n        temp[k++] = a[j++];\n    for (int t = l; t <= r; t++)\n        a[t] = temp[t];\n}\nint main()\n{\n    scanf(\"%d\", &n);\n    for (register int i = 1; i <= n; i++)\n        scanf(\"%d\", &a[i]);\n    mergesort(1, n);\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n```\n\n","tags":["洛谷","算法"]},{"title":"洛谷P1309题解","url":"/2020/02/06/P1309-Solution/","content":"\n### 链接：[P1309](https://www.luogu.com.cn/problem/P1309)   \n<!--more-->\n\n# 题解：\n\n第一想法是直接模拟瑞士轮的赛制，即每经过一轮就排序一次，但是这样做即便开了O2优化也只有70分，肯定需要对排序算法进行优化。考虑到快速排序的优点在于处理随机的数据，而这里每一轮比赛结束后所有的胜利者和失败者各自都是有序的，而快速排序并不能利用这个条件，所以会很浪费时间。如果能够利用这个性质，就只需要进行一次归并操作完成排序，一轮的时间复杂度从$O(n\\log n)$下降到$O(n)$。因此只要将归并排序的递归去掉，只合并一次，就可以解决这个问题。\n\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nstruct player\n{\n    int sco, id;\n    bool operator>(const player &b)\n    {\n        if (sco != b.sco)\n            return sco > b.sco;\n        else\n            return id < b.id;\n    }\n    player operator=(const player &b)\n    {\n        sco = b.sco;\n        id = b.id;\n        return *this;\n    }\n};\nplayer a[200001], win[100001], lose[100001];\nint abi[200001], n, r, q, m;\nbool cmp(player a, player b)\n{\n    if (a.sco == b.sco)\n        return a.id < b.id;\n    return a.sco > b.sco;\n}\nvoid MergeSort()\n{\n    int i = 1, j = 1, k = 1;\n    while (i <= n && j <= n)\n        if (win[i] > lose[j])\n            a[k++] = win[i++];\n        else\n            a[k++] = lose[j++];\n    while (i <= n)\n        a[k++] = win[i++];\n    while (j <= n)\n        a[k++] = lose[j++];\n}\nint main()\n{\n    scanf(\"%d%d%d\", &n, &r, &q);\n    m = n << 1;\n    for (register int i = 1; i <= m; i++)\n    {\n        scanf(\"%d\", &a[i].sco);\n        a[i].id = i;\n    }\n    for (register int i = 1; i <= m; i++)\n        scanf(\"%d\", &abi[i]);\n    sort(a + 1, a + 1 + m, cmp);\n    for (register int k = 1; k <= r; k++)\n    {\n        int p = 1;\n        for (register int i = 1; i < m; i += 2)\n        {\n            if (abi[a[i].id] > abi[a[i + 1].id])\n            {\n                a[i].sco++;\n                win[p] = a[i];\n                lose[p] = a[i + 1];\n            }\n            else\n            {\n                a[i + 1].sco++;\n                win[p] = a[i + 1];\n                lose[p] = a[i];\n            }\n            p++;\n        }\n        MergeSort();\n    }\n    printf(\"%d\\n\", a[q].id);\n    return 0;\n}\n```\n\n","tags":["2020寒假","洛谷"]},{"title":"CF1291C题解","url":"/2020/02/05/CF1291C-Solution/","content":"\n### 链接：[CF1291C Mind Control](https://codeforces.com/problemset/problem/1291/C) [洛谷CF1290A](https://www.luogu.com.cn/problem/CF1290A)  \n\n- **数学 暴力 数据结构 贪心  \\*1700 **\n<!--more-->\n# 思路：\n首先这道题的数据范围很小，$n \\le 3500$，所以$O(n^2)$的暴力做法是可以通过的。并且题目的一个标签就是brute force，说明暴力确实是这题的标准解法之一。但是，可以通过一些优化将时间复杂度降低到$O(logn)$甚至$O(n)$。\n\n根据题意，首先需要明确两点：\n\n- 不需要考虑在自己后面的人。即当$k$的值超过在自己之前的人数$m-1$时，多余的受控制的人数不会对结果产生任何影响。\n- 自己取数字的情况只和在队首和队尾取的人数有关，和是否受自己控制的人取数字的先后顺序没有关系。\n\n自己是队伍的第$m$个人，由于之前的$m-1$人都只会取数组首尾的元素，留给自己的一定是原数组中完整的且长度为$n-m+1$的一个区间。比较每一个区间的首尾元素并取最大值，可以得到一个值表示对于这一个区间可以取到的最大值。这样的区间一共有$m$个，所以开一个新的数组$s$来存储。\n\n接下来对**从数组前面取的人**中受到自己控制的人的数量进行遍历，然后用一个单调队列找出每一次的最坏情况，再将所有的最坏情况取最大值，就可以找到所求的答案。这种方法可以将复杂度降低到$O(n)$。\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ndeque<int> q;\nvector<int> v, a;\nint main()\n{\n    int t, n, m, k, r, ans;\n    scanf(\"%d\", &t);\n    while (t--)\n    {\n        ans = 0;\n        a.clear();\n        v.clear();\n        q.clear();\n        scanf(\"%d%d%d\", &n, &m, &k);\n        k = min(k, m - 1);\n        for (register int i = 0; i < n; i++)\n        {\n            scanf(\"%d\", &r);\n            a.push_back(r);\n        }\n        for (register int i = 0; i < m; i++)\n            v.push_back(max(a[i], a[i + n - m]));\n        for (register int i = 0, j = 0; i <= k; i++)\n        {\n            for (; j < i + m - k; j++)\n            {\n                while (!q.empty() && v[q.back()] >= v[j])\n                    q.pop_back();\n                q.push_back(j);\n            }\n            while (!q.empty() && q.front() < i)\n                q.pop_front();\n            ans = max(ans, v[q.front()]);\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n```\n\n","tags":["2020寒假","CodeForces"]},{"title":"CF1295B题解","url":"/2020/02/04/CF1295B-Solution/","content":"\n### 链接：[CF1295B Infinite Prefixes](https://codeforces.com/problemset/problem/1295/B) [洛谷CF1295B](https://www.luogu.com.cn/problem/CF1295B)  \n\n- **数学 字符串  \\*1700 **\n<!--more-->\n# 思路：\n由于可以无限拼接输入的01串，前缀和一定会周期性变化。先记录一个周期的所有前缀和，又因为空串也算是一个前缀，所以记录01串时从下标$1$开始，如图：\n\n| 下标 $i$ | 0    | 1    | 2    | 3    | 4    | 5    |6|\n| ------ | ---- | ---- | ---- | ---- | ---- | ---- |---- |\n| 01串 $m_i$ | /    | 0 | 1 | 0 | 0 | 1 |0|\n| 前缀和 $s_i$ | 0 | 1 | 0 | 1 | 2 | 1 |2|\n\n所以每拼接一个完整的串，前缀和增加$2$，第$k$个前缀和$s_k$也可以算出：\n$$\nS_k=s_{k\\mathscr{mod}len}+s_{len}\\times k/len\n$$\n对于$s_{len}$，若其不为0，则从$s_1$遍历到$s_len$，当$x-s_i$是$s_{len}$的**正**整数倍时，说明找到了一个答案。如果$x=0$则还需要再算上最前面空的串。若$s_{len}=0$，就只需要在$s_0$到$s_{len}$中寻找，若有$s_i$ 与$x$相等，那么在接上任意长度的整串后$s_{i+k*len}$也与$x$相等，即有无数答案；若找不到，说明无解。\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint m[100002], s[100002];\nint main()\n{\n    int ans, x, len, t;\n    scanf(\"%d\", &t);\n    while (t--)\n    {\n        scanf(\"%d%d\", &len, &x);\n        ans = 0;\n        for (int i = 1; i <= len; i++)\n        {\n            scanf(\"%1d\", &m[i]);\n            s[i] = s[i - 1];\n            if (m[i])\n                s[i]--;\n            else\n                s[i]++;\n        }\n        if (s[len])\n        {\n            for (int i = 1; i <= len; i++)\n                if ((x - s[i]) % abs(s[len]) == 0 && (x - s[i]) / s[len] >= 0)\n                    ans++;\n            if (x == 0)\n                ans++;\n            printf(\"%d\\n\", ans);\n        }\n        else\n        {\n            for (int i = 0; i <= len; i++)\n                if (s[i] == x)\n                {\n                    ans++;\n                    break;\n                }\n            if (ans)\n                printf(\"-1\\n\");\n            else\n                printf(\"0\\n\");\n        }\n    }\n    return 0;\n}\n```\n\n","tags":["2020寒假","CodeForces"]},{"title":"树状数组","url":"/2020/02/04/Fenwick_Tree/","content":"\n### 简介：\n\n树状数组（二叉索引树，Fenwick树）的结构与线段树相似，功能上可以一些处理区间修改查询问题。相比线段树，树状数组的优点在于代码量少，操作方便，效率高于线段树，但它的缺点在于一般只能单点修改且用途不如线段树广泛。\n\n<!--more-->\n\n模板题[P3374](https://www.luogu.com.cn/problem/P3374)。\n\n**Lowbit**\n\n正整数的存储采用补码表示，对于一个正数$n$，$-n$的补码就是$n$的补码按位取反后加$1$的结果。定义$lowbit(x)$是$x$的二进制表示中最右边的$1$所对应的值（即$2$的某个幂），则可以使用$x\\&-x$来实现$lowbit(x)$。\n\n**树状数组的实现**\n\n树状数组$F$中的每个元素都是原数组$S$中连续的一段（之和），包含的每一段的长度都等于树状数组下标$i$的$lowbit$。可以推导出$F_i=S_{i-lowbit(i)+1}+S_{i-lowbit(i)+2}+...+S_i$。显然，每个奇数下标的树状数组元素所包含的区间长度是$1$。\n\n**查询：**\n\n相当于前缀数组的操作，当查询某个区间$[a,b]$的元素之和时，只需计算$query(b)-query(a-1)$即可。而前缀和的计算方式如下：\n\n```c++\nint query(int x)\n{\n\tint ans=0;\n\tfor(;x;x^=lowbit(x))//在这里^=和-=效果相同\n\t\tans=ans+tree[x];\n\treturn ans;\n}\n```\n\n**维护：**\n\n修改所以含有被修改项的树状数组元素。\n\n```c++\nvoid update(int x,int k)\n{\n    for(;x<=n;x+=lowbit(x))\n        tree[x]+=k;\n}\n```\n\n**P3374AC代码：**\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 500002;\nint tree[maxn], n, m, k, x, y;\ninline int lowbit(int i)\n{\n    return i & -i;\n}\nint query(int x)\n{\n    int ans = 0;\n    for (; x; x ^= lowbit(x))\n        ans = ans + tree[x];\n    return ans;\n}\nvoid update(int x, int k)\n{\n    for (; x <= n; x += lowbit(x))\n        tree[x] += k;\n}\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    for (register int i = 1; i <= n; i++)\n    {\n        scanf(\"%d\", &k);\n        update(i, k);\n    }\n    while (m--)\n    {\n        scanf(\"%d%d%d\", &k, &x, &y);\n        if (k == 1)\n            update(x, y);\n        else\n            printf(\"%d\\n\", query(y) - query(x - 1));\n    }\n    return 0;\n}\n```\n\n","tags":["数据结构","洛谷"]},{"title":"CF2A题解","url":"/2020/02/03/CF2A-Solution/","content":"\n### 链接：[CF2A Winner](https://codeforces.com/problemset/problem/2/A) [洛谷CF2A](https://www.luogu.com.cn/problem/CF2A)  \n\n- **哈希 模拟   \\*1600 **\n<!--more-->\n# 思路：\n这道题比较适合用来练习STL中map的操作。先建立一个从string到int的映射，表示姓名与得分，再模拟比分改变的过程并使用迭代器遍历整个容器找到最高分。最后由于题目所求的是最先达到最高分且最终分数最高的人，所以需要再开一个map将比分改变的过程再模拟一次，找到符合要求的人。\n\n**map容器的迭代器是一个指向pair类型的指针，其成员first保存有关键字，因此是只读的，无法改变其值，成员second保存成员值，可以修改。**\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nmap<string, int> m, p;\nstring s[100002], w;\nint n, a[100002], maxn;\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cin >> n;\n    for (register int i = 1; i <= n; i++)\n    {\n        cin >> s[i] >> a[i];\n        m[s[i]] += a[i];\n    }\n    for (auto it = m.begin(); it != m.end();it++)\n        maxn = max(maxn, it->second);\n    for (register int i = 1; i <= n; i++)\n    {\n        p[s[i]] += a[i];\n        if (m[s[i]] == maxn && p[s[i]] >= maxn)\n        {\n            w = s[i];\n            break;\n        }\n    }\n    cout << w << endl;\n    return 0;\n}\n```\n\n","tags":["2020寒假","CodeForces"]},{"title":"单调队列","url":"/2020/02/03/Monotone_Queue/","content":"\n### 简介：\n\n顾名思义，单调队列是所有元素大小单调变化的队列。单调队列可以用于优化一些算法，也可以完成一些区间查询问题。单调队列可以在队首和队尾插入和删除，所以可以使用STL的deque来实现。\n\n<!--more-->\n\n**单调队列与优先队列的区别：单调队列的下标是单调递增的，但优先队列的下标会改变。**\n\n#### 模板题[P1886](https://www.luogu.com.cn/problem/P1886)题解：\n\n建立两个双端队列分别模拟递增和递减的单调队列，实现方式如下：\n\n当一个元素准备进队时，从队尾向前逐个比对，将所有不大于(不小于)该元素的队列成员从队尾出队，然后将该元素进队。然后从队首开始逐个检验成员的下标，将下标超出范围的从队首出队。\n\nSTL的deque使用方式与vector类似，并拥有独特的push_front和pop_back。\n\n### AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nstruct ele\n{\n    int val, n;\n} x;\ndeque<ele> maxq, minq;\nint main()\n{\n    int n, k;\n    scanf(\"%d%d\", &n, &k);\n    vector<int> v;\n    for (int i = 1; i <= n; i++)\n    {\n        scanf(\"%d\", &x.val);\n        x.n=i;\n        while (!maxq.empty() && x.val >= maxq.back().val)\n            maxq.pop_back();\n        while (!minq.empty() && x.val <= minq.back().val)\n            minq.pop_back();\n        maxq.push_back(x);\n        minq.push_back(x);\n        while (maxq.front().n + k < i + 1)\n            maxq.pop_front();\n        while (minq.front().n + k < i + 1)\n            minq.pop_front();\n        if (i >= k)\n        {\n            printf(\"%d \", minq.front().val);\n            v.push_back(maxq.front().val);\n        }          \n    }\n    printf(\"\\n\");\n    for (int i = 0; i <v.size(); i++)\n       printf(\"%d \", v[i]);\n    return 0;\n}\n```\n\n","tags":["数据结构","洛谷"]},{"title":"线段树","url":"/2020/02/03/Segment_Tree/","content":"\n### 简介：\n\n线段树可以处理一些区间修改和查询的操作，相比ST表(稀疏表)，线段树能够处理动态的区间最值问题。线段树每一次修改与查询的时间复杂度都是$O(logn)$。\n\n但是，如果一个问题不能满足拆分成子问题来解决，就不能使用线段树。\n\n<!--more-->\n\n由于模板题[(P3372)](https://www.luogu.com.cn/problem/P3372)询问的是区间和，本文查询、更新等操作都是求区间和。\n\n#### 建树：\n\n**存储时数组开4倍确保空间足够($2^{\\log_2(n-1)+2}\\approx 4\\times n$)。**\n\n线段树的每一个节点都对应序列中的一个区间，其中根节点表示整个区间，然后通过将每个节点对应的序列不断二分向下建树，直到序列中只有一个点为止。因此，线段树的最大深度不会超过$\\lfloor \\log _2 (n-1) \\rfloor +2$。这种建树方式先确定父亲节点，再确定两个儿子节点，所以在第一次经过父亲节点时不能确定其值，还需要在儿子节点的值确定后再更新父亲节点的值。代码如下：\n\n```c++\nvoid push_up_sum(long long p)\n{\n    seg_tree[p] = seg_tree[p << 1] + seg_tree[p << 1 | 1];\n}//由两个儿子确定父亲的值\nvoid build(long long p, long long l, long long r)\n{\n    tag[p] = 0;\n    if (l == r)//区间只有一个点了\n    {\n        seg_tree[p] = a[l];\n        return;\n    }\n    long long mid = (l + r) >> 1;\n    build(p << 1, l, mid);//左半段\n    build(p << 1 | 1, mid + 1, r);//右半段\n    push_up_sum(p);//递归回来的时候确定父亲的值\n}\n```\n\n观察建树的过程可以发现，第$k$层的节点是数组中$2^{k-1}$到$2^k-1$的点，点$p$的左儿子在点$p\\times2$，右儿子在点$p\\times2+1$。\n\n#### 修改：\n\n区间修改如果一个一个修改叶子节点的值，再不断向上更新，时间复杂度过高，因此引入懒标记(lazy-tag)。当一个区间被修改时，找到这个区间各个部分的公共祖先并修改它们的懒标记，而如果未来某个被打上懒标记的公共祖先的后代也要被标记时，就需要将懒标记下放。代码如下：\n\n```c++\nvoid flag(long long p, long long l, long long r, long long k)//打标记\n{\n    tag[p] = tag[p] + k;\n    seg_tree[p] = seg_tree[p] + k * (r - l + 1);//只修改公共祖先\n}\nvoid push_down(long long p, long long l, long long r)//向下推标记\n{\n    long long mid = (l + r) >> 1;\n    flag(p << 1, l, mid, tag[p]);\n    flag(p << 1 | 1, mid + 1, r, tag[p]);\n    tag[p] = 0;\n}\nvoid update(long long newl, long long newr, long long l, long long r, long long p, long long k)//更新\n{\n    if (newl <= l && r <= newr)\n    {\n        seg_tree[p] += k * (r - l + 1);\n        tag[p] += k;\n        return;\n    }\n    push_down(p, l, r);\n    long long mid = (l + r) >> 1;\n    if (newl <= mid)\n        update(newl, newr, l, mid, p << 1, k);\n    if (newr > mid)\n        update(newl, newr, mid + 1, r, p << 1 | 1, k);\n    push_up_sum(p);\n}\n```\n\n#### 查询：\n\n和修改思想类似，代码如下：\n\n```c++\nlong long query(long long q_x, long long q_y, long long l, long long r, long long p)\n{\n    if (q_x <= l && r <= q_y)\n        return seg_tree[p];\n    long long ans = 0, mid = (l + r) >> 1;\n    push_down(p, l, r);\n    if (q_x <= mid)\n        ans += query(q_x, q_y, l, mid, p << 1);\n    if (q_y > mid)\n        ans += query(q_x, q_y, mid + 1, r, p << 1 | 1);\n    return ans;\n}\n```\n\n\n\n# 完整代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1000002;\nlong long a[maxn], seg_tree[maxn << 2], tag[maxn << 2]; \nvoid push_up_sum(long long p)\n{\n    seg_tree[p] = seg_tree[p << 1] + seg_tree[p << 1 | 1];\n}\nvoid build(long long p, long long l, long long r)\n{\n    tag[p] = 0;\n    if (l == r)\n    {\n        seg_tree[p] = a[l];\n        return;\n    }\n    long long mid = (l + r) >> 1;\n    build(p << 1, l, mid);\n    build(p << 1 | 1, mid + 1, r);\n    push_up_sum(p);\n}\nvoid flag(long long p, long long l, long long r, long long k)\n{\n    tag[p] = tag[p] + k;\n    seg_tree[p] = seg_tree[p] + k * (r - l + 1);\n}\nvoid push_down(long long p, long long l, long long r)\n{\n    long long mid = (l + r) >> 1;\n    flag(p << 1, l, mid, tag[p]);\n    flag(p << 1 | 1, mid + 1, r, tag[p]);\n    tag[p] = 0;\n}\nvoid update(long long newl, long long newr, long long l, long long r, long long p, long long k)\n{\n    if (newl <= l && r <= newr)\n    {\n        seg_tree[p] += k * (r - l + 1);\n        tag[p] += k;\n        return;\n    }\n    push_down(p, l, r);\n    long long mid = (l + r) >> 1;\n    if (newl <= mid)\n        update(newl, newr, l, mid, p << 1, k);\n    if (newr > mid)\n        update(newl, newr, mid + 1, r, p << 1 | 1, k);\n    push_up_sum(p);\n}\nlong long query(long long q_x, long long q_y, long long l, long long r, long long p)\n{\n    if (q_x <= l && r <= q_y)\n        return seg_tree[p];\n    long long ans = 0, mid = (l + r) >> 1;\n    push_down(p, l, r);\n    if (q_x <= mid)\n        ans += query(q_x, q_y, l, mid, p << 1);\n    if (q_y > mid)\n        ans += query(q_x, q_y, mid + 1, r, p << 1 | 1);\n    return ans;\n}\nint main()\n{\n    int n, m, k;\n    long long b, c, d;\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; i++)\n        scanf(\"%lld\", &a[i]);\n    build(1, 1, n);\n    while (m--)\n    {\n        scanf(\"%d\", &k);\n        if (k == 1)\n        {\n            scanf(\"%lld%lld%lld\", &b, &c, &d);\n            update(b, c, 1, n, 1, d);\n        }\n        else\n        {\n            scanf(\"%lld%lld\", &b, &c);\n            printf(\"%lld\\n\", query(b, c, 1, n, 1));\n        }\n    }\n    return 0;\n}\n```\n\n","tags":["数据结构","洛谷"]},{"title":"二叉堆","url":"/2020/02/02/Binary_Heap/","content":"\n# 简介：\n\n(二叉)堆是一个数组，类似于一棵完全二叉树，树上的每一个节点对应数组中的一个元素。除了树的最底层，该树是完全充满的，而且是从左向右填充。表示堆的数组通常需要给出数组长度$len$和包含的有效数据个数(堆中数据个数)$size$两个属性。显然，有$0\\le size\\le len$。\n对于下标$i$指向的元素，可以算出它的父节点、左孩子和右孩子的下标分别为$\\lfloor i/2\\rfloor$、$2i$和$2i+1$。\n\n堆可以分为两种，大根堆和小根堆。顾名思义，大根堆的最大元素存放在根节点，且在任意子树中子树包含的节点的值都不大于该子树的根节点的值。小根堆的存放方式正好相反。\n\n<!--more-->\n\n# 模板题[(P3378)](https://www.luogu.com.cn/problem/P3378)简述：\n\n初始小根堆为空，支持以下3种操作：\n\n输入$1$   $x$：将$x$插入到堆中；\n\n输入$2$：输出堆中最小数；\n\n输入$3$：删除堆中最小数。\n\n# 题解：\n\n## 1、手写堆\n\n只需要实现插入元素和删除堆顶两个功能，插入时将新元素放到堆底，并逐层与所在的子树的根节点相比较，若小于根节点则与其交换位置；删除操作与插入相反，先用堆底元素替换堆顶，再逐层向下比较，将原堆底元素交换到它应该在的位置。\n\n## 2、STL优先队列\n\nSTL的优先队列(priority_queue)就是一个堆，但是它默认是一个大根堆，需要手动改成小根堆或者将输入变为相反数，输出时再反一次。\n\n## 3、pb_ds库的堆(优先队列)\n\npb_ds：Policy-Based Data Structures\n\npb_ds库是GNU-C++自带的一个C++扩展库，封装了哈希表，平衡二叉树，字典树，堆等数据结构。\n\n**该库只在Linux下可以用！**\n\n其中的优先队列用法与STL的基本相同，包括 size()，empty()，push()，top()，pop()，clear()。\n\n定义时由于名称与STL的相同，要带上命名空间：\n\n```c++\n__gnu_pbds::priority_queue<int, greater<int>, pairing_heap_tag> q;\n```\n\nTag表示使用堆的类型，有配对堆（pairing_heap_tag）、二叉堆（binary_heap_tag）、二项堆（binomial_heap_tag）、经改良的斐波那契堆（thin_heap_tag）、冗余计数二项式堆（rc_binomial_heap_tag）等。\n\n更多：可以用 begin() 和 end() 来获取 iterator 从而遍历；\n\n可以 increase_key，decrease_key 和删除单个元素；\n\n可以合并。\n\n在不开O2优化的情况下，pb_ds库的二叉堆效率高于STL的优先队列。\n\n# AC代码：\n\n## 1、手写堆\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint heap[1000001];\nint heap_size = 0;\nvoid insert(int x)\n{\n    heap[++heap_size] = x;//放到堆底\n    int i = heap_size;\n    while (i > 1)//判断是否升到堆顶\n    {\n        if (heap[i] >= heap[i >> 1])\n            return;\n        swap(heap[i], heap[i >> 1]);\n        i >>= 1;//再向上找一个根\n    }\n}\nvoid del()\n{\n    int i = 1, j;\n    heap[1] = heap[heap_size--];//删除堆顶，换成堆底\n    while ((i << 1) <= heap_size)//是否到了最下层\n    {\n        j = (i << 1);\n        if (j < heap_size && heap[j + 1] < heap[j])//找到左右孩子中小的一个\n            j++;\n        if (heap[i] <= heap[j])\n            return;\n        swap(heap[i], heap[j]);\n        i = j;//新的根\n    }\n}\nint main()\n{\n    int n, k, x;\n    scanf(\"%d\", &n);\n    while (n--)\n    {\n        scanf(\"%d\", &k);\n        if (k == 1)\n        {\n            scanf(\"%d\", &x);\n            insert(x);\n        }\n        else if (k == 2)\n            printf(\"%d\\n\", heap[1]);\n        else\n            del();\n    }\n    return 0;\n}\n```\n\n## 2、STL优先队列\n\n```c++\n#include <cstdio>\n#include <queue>\nusing namespace std;\npriority_queue<int, vector<int>, greater<int> > q;//默认大根堆\nint main()\n{\n    int n, k, x;\n    scanf(\"%d\", &n);\n    while (n--)\n    {\n        scanf(\"%d\", &k);\n        if (k == 1)\n        {\n            scanf(\"%d\", &x);\n            q.push(x);\n        }\n        else if (k == 2)\n            printf(\"%d\\n\", q.top());\n        else\n            q.pop();\n    }\n    return 0;\n}\n```\n\n## 3、pb_ds的堆\n\n```c++\n#include <cstdio>\n#include <ext/pb_ds/priority_queue.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n__gnu_pbds::priority_queue<int, greater<int>, pairing_heap_tag> q;\nint main()\n{\n    int n, k, x;\n    scanf(\"%d\", &n);\n    while (n--)\n    {\n        scanf(\"%d\", &k);\n        if (k == 1)\n        {\n            scanf(\"%d\", &x);\n            q.push(x);\n        }\n        else if (k == 2)\n            printf(\"%d\\n\", q.top());\n        else\n            q.pop();\n    }\n    return 0;\n}\n```\n\n","tags":["数据结构","洛谷"]},{"title":"洛谷P1280题解","url":"/2020/02/02/P1280-Solution/","content":"\n### 链接：[P1280](https://www.luogu.com.cn/problem/P1280)   \n<!--more-->\n\n# 题解：\n这是一个线性动态规划问题。可以发现：如果希望**某一时刻的工作**能带来*最大的休息时间*，那么在**这个工作完成的时间点**能找到*最大的休息时间*。\n因此，做这道题需要从时间上从后往前逆推。先使用结构体和sort对每个任务的开始时间从大到小进行排序，用$f_i$表示第$i$分钟的最大休息时间，然后从最后1分钟开始向前枚举，如果时间$i$没有任务，$f_i=f_{i+1}+1$，如果有任务，遍历所有任务的结束时间并取其中最大的休息时间，即\n\n```c++\nfor(int j=1; j<=s[i]; j++)//选结束后休息时间最大的任务\n{\n\tf[i]=max(f[i],f[i+t[num].ed]);\n\tnum++;\n}\n```\n\n在这里不用考虑$i$时间之前的时刻的任务占用时间点$i$造成的影响，因为如果时间$i$被某个任务占用，推到这个任务的时候也不会用到$f_i$。\n\n最后$f_1$就是全过程的最大休息时间。\n\n# AC代码：\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nint s[10001],f[10001];\nstruct task\n{\n    int bgn,ed;\n};\ntask t[10001];\nbool cmp(task a,task b)\n{\n    return a.bgn>b.bgn;\n}\nint main()\n{\n    int n,k,num=1;\n    scanf(\"%d%d\",&n,&k);\n    for(register int i=1; i<=k; i++)\n    {\n        scanf(\"%d%d\",&t[i].bgn,&t[i].ed);\n        s[t[i].bgn]++;\n    }\n    sort(t+1,t+k+1,cmp);\n    for(register int i=n; i>=1; i--)\n    {\n        if(s[i]==0)\n            f[i]=f[i+1]+1;\n        else\n        {\n            for(register int j=1; j<=s[i]; j++)\n            {\n                f[i]=max(f[i],f[i+t[num].ed]);\n                num++;\n            }\n\t\t}\n    }\n    printf(\"%d\\n\",f[1]);\n    return 0;\n}\n```\n\n","tags":["2020寒假","洛谷"]},{"title":"离散化练习 (P2082 P2070)","url":"/2020/02/01/Discretization-Solution/","content":"\n# 离散化：\n\n在不改变数据相对大小的情况下对数据进行相应的缩小，例如在以下问题中通过只保存区间的左右端点来存储一个大区间，从而提高算法的时空效率。\n\n[P2082](https://www.luogu.com.cn/problem/P2082)    [P2070](https://www.luogu.com.cn/problem/P2070)\n<!--more-->\n\n# P2082简述：\n已知有N个区间，每个区间的范围是$[S_i,T_i]$，请求出区间覆盖后的总长。\n输入：第一行1个正整数$N$，第接下来$N$行每行两个数，为$S_i$,$T_i$。\n输出：1个正整数，为覆盖后的区间总长。\n本题数据范围非常大，$0<S_i<T_i<=10^{17}$。\n\n# 题解：\n\n首先，看到这么大的数据范围开一个桶来存储一定会MLE+TLE，所以要用离散化的思想。用一个结构体储存每个区间的左右端点，然后对左端点进行排序，再遍历一遍。 \n用一个变量p来存储每次到达的右端点，如果下一个区间的右端点不比p大，说明这个区间已经被覆盖，再往后遍历；如果下一个区间的右端点比p大，说明有新的一段被覆盖，检测p是否小于左端点，若小于，说明不重合，左端点未被覆盖，计算答案时由于是闭区间需要+1，若p不小于左端点则不必+1。\n\n# AC代码：\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ul;\nstruct section\n{\n    ul l, r;\n};\nsection s[100001];\nbool cmp(section a,section b)\n{\n    return a.l < b.l;\n}\nint main()\n{\n    int n;\n    ul ans = 0,p=0;\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    std::cout.tie(0);\n    cin >> n;\n    for (register int i = 0; i < n;i++)\n        cin >> s[i].l >> s[i].r;\n    sort(s, s + n, cmp);\n    for (register int i = 0; i < n;i++)\n    {\n        if (s[i].r > p)\n        {\n            if(p>=s[i].l)\n                ans += s[i].r - p;\n            else\n                ans += s[i].r - s[i].l + 1;\n            p = s[i].r;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n```\n\n# P2070简述：\n\n与上一题类似，但是需要求出被覆盖至少两次的区间长度。\n\n数据范围$\\pm10^9$（正好满足int型）。\n\n# 题解：\n\n离散化与排序操作与上一题类似，在计算总数时采用两个变量left和right分别维护只被覆盖一次的最左端和只被覆盖一次的最右端即可。\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nstruct section\n{\n    int l, r;\n};\nsection s[100001];\nbool cmp(section a, section b)\n{\n    return a.l < b.l;\n}\nint main()\n{\n    int n, m, start = 0, ans = 0, left, right;\n    char c;\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    std::cout.tie(0);\n    cin >> n;\n    for (register int i = 0; i < n; i++)\n    {\n        cin >> m >> c;\n        if (c == 'L')\n        {\n            s[i].l = start - m;\n            s[i].r = start;\n            start -= m;\n        }\n        else\n        {\n            s[i].l = start;\n            s[i].r = start + m;\n            start += m;\n        }\n    }\n    sort(s, s + n, cmp);\n    left = s[0].l;\n    right = s[0].r;\n    for (register int i = 1; i < n; i++)\n    {\n        if (right > s[i].l)\n        {\n            if (min(s[i].r, right) > max(left, s[i].l))\n            {\n                ans += min(s[i].r, right) - max(left, s[i].l);\n                left = min(s[i].r, right);\n            }\n        }\n        right = max(s[i].r, right);\n    }\n    cout << ans << endl;\n    return 0;\n}\n```\n\n","tags":["洛谷","算法"]},{"title":"ST表(Sparse Table)","url":"/2020/02/01/Sparse_Table/","content":"\n# 简介：\n\nST表类似于树状数组和线段树，是一种用于解决RMQ(Range Minimum/Maximum Query,区间最值查询)问题的离线算法。\n与线段树相比，ST表预处理复杂度同为$O(nlogn)$，查询时间上，ST表为$O(1)$,线段树为$O(nlogn)$。\nST表的主体是一个二维数组$ST{_i}{_j}$，表示需要查询的数组的从下标$i$到下标$i+2^j - 1$的最值。\n\n<!--more-->\n\n# 模板题[(P3865)](https://www.luogu.com.cn/problem/P3865)简述：\n\n给定一个长度为$N$的数列，和$M$次询问，求出每一次询问的区间内数字的最大值。\n\n## 输入:\n第一行包含两个整数$N$，$M$，分别表示数列的长度和询问的个数。\n第二行包含$N$个整数（记为$a_i$），依次表示数列的第$i$项。\n接下来$M$行，每行包含两个整数$l_i$，$r_i$，表示查询的区间为$[l_i,r_i]$。\n\n## 输出:\n输出包含$M$行，每行一个整数，依次表示每一次询问的结果。\n# 题解：\n\n首先，对输入数据进行预处理：$ST{_i}{_j}$表示区间上从第$i$个位置（包括自己）开始，向后数$2^j$个数中的最值；\n显然，$ST{_i}{_0}$即为输入的数组本身，而$j>0$时，$ST{_i}{_j}$取其包含的两个小区间的最（大）值。\n由于ST表需要一层一层地生成，在预处理时要将某个长度的每一段都生成后再生成更长的段，其循环部分的书写比较特殊，将$j$写在$i$的外面看起来更为直观。\n在查询时，因为区间长度都是2的幂，需要先找到不大于查询区间的2的最大次幂，并以查询的区间的左端点为起点查询一次，再以查询的区间的右端点为终点查询一次，然后进行比较。这样可以保证在最少的查询次数下获得所求的最值。\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint ST[100001][21];\nint query(int left, int right)\n{\n    int k = log2(right - left + 1);\n    return max(ST[left][k], ST[right - (1 << k) + 1][k]);\n}\nint main()\n{\n    int n, m, left, right;\n    scanf(\"%d%d\", &n, &m);\n    for (register int i = 1; i <= n; i++)\n        scanf(\"%d\", &ST[i][0]);\n    for (register int j = 1; j <= 21; j++)\n        for (register int i = 1; i + (1 << j) - 1 <= n; i++)\n            ST[i][j] = max(ST[i][j - 1], ST[i + (1 << (j - 1))][j - 1]);\n    for (register int i = 1; i <= m; i++)\n    {\n        scanf(\"%d%d\", &left, &right);\n        printf(\"%d\\n\", query(left, right));\n    }\n    return 0;\n}\n```\n\n","tags":["数据结构","洛谷"]},{"title":"学习记录等","url":"/2020/01/31/record/","content":"\n## 做题记录（更新中）\n\n### 2019\n\n![2019luogu.png](https://i.loli.net/2020/02/01/WlKINLGt19P6XhQ.png)\n\n\n\n### 2020\n\n<!--more-->\n\n#### Jan\n\n![2020Jan.png](https://i.loli.net/2020/02/01/UlCBKd8ZpYDIkAt.png)\n\n**01-15 AC100**\n\n#### Feb\n\n![2020Feb.png](https://i.loli.net/2020/03/01/QbFGCyOgAKiSjoI.png)\n\n\n\n图片可能无法加载\n\n![v2-d664916b89031571cb36e5657009ce1e_720w.jpg](https://i.loli.net/2020/03/01/RzVIuQd6LsbN3Kg.jpg)","tags":["其它"]}]