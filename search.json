[{"title":"CF#698div2总结","url":"/2021/01/29/CF698div2/","content":"\n\nRound #697是Div.3的比赛，所以就不补了。\n\n\n<!--more-->\n\n## A\n\n水题。\n\n```c++\nint a[maxn];\nsigned main()\n{\n    int T;\n    cin >> T;\n    while (T--)\n    {\n        int n, ans = 0, tmp = 1;\n        cin >> n;\n        for (int i = 1; i <= n; ++i)\n        {\n            cin >> a[i];\n            if (a[i] == a[i - 1])\n                tmp++;\n            else\n                tmp = 1;\n            ans = max(ans, tmp);\n        }\n        cout << ans << '\\n';\n    }\n    return 0;\n}\n```\n\n## B\n\n水题。\n\n```c++\nsigned main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    std::cout.tie(0);\n    int T;\n    cin >> T;\n    while (T--)\n    {\n        int n, k;\n        cin >> n >> k;\n        for (int i = 1, x; i <= n; ++i)\n        {\n            cin >> x;\n            if (x >= k * 10 || k == 1 || x % 10 == k)\n            {\n                cout << \"YES\\n\";\n                continue;\n            }\n            bool f = false;\n            for (int t = 1; t < k; ++t)\n            {\n                for (int j = 0; j * (k + 10 * t) <= x; ++j)\n                {\n                    int y = x - j * (k + 10 * t);\n                    if (y % k == 0)\n                    {\n                        f = true;\n                        break;\n                    }\n                }\n                if (f)\n                    break;\n            }\n            cout << (f ? \"YES\\n\" : \"NO\\n\");\n        }\n    }\n    return 0;\n}\n```\n\n写的很丑。\n\n## C\n\n考虑每个数的贡献，可以发现贡献总是一对数中绝对值更大的数的两倍。所以 `sort` 以后稍微推导一下就好了。\n\n```c++\nll d[maxn];\nunordered_map<ll, int> mp;\nsigned main()\n{\n    int T;\n    read(T);\n    while (T--)\n    {\n        int n;\n        bool flag = true;\n        ll sum = 0;\n        mp.clear();\n        read(n);\n        for (int i = 1; i <= n * 2; ++i)\n        {\n            read(d[i]);\n            mp[d[i]]++;\n        }\n        sort(d + 1, d + 2 * n + 1);\n        for (ll cnt = n; cnt >= 1; --cnt)\n        {\n            ll pos = cnt * 2;\n            if (mp[d[pos]] != 2 || d[pos] <= sum * 2 || (d[pos] - sum * 2) % pos != 0)\n            {\n                flag = false;\n                break;\n            }\n            sum += (d[pos] - sum * 2) / pos;\n        }\n        puts(flag ? \"YES\" : \"NO\");\n    }\n    return 0;\n}\n```\n\n## D\n\n可以发现，经过若干次操作后得到的多项式系数和始终为 $1$，这意味着凡是可以表示为一个原有的数加上若干个“间隔”的数都可以被构造出来。\n\n间隔的数量一开始就是 $n^2$ 级别的，并且会越来越多，注意到能构造出的最小间隔是所有间隔的 $\\gcd$，所以只要扫一遍就可以了（想想辗转相除法的原理）。\n\n然后枚举原有的那个数即可。\n\n```c++\nll a[maxn];\nsigned main()\n{\n    int T;\n    read(T);\n    while (T--)\n    {\n        ll n, k, g = 0;\n        bool flag = false;\n        read(n, k);\n        for (int i = 1; i <= n; ++i)\n            read(a[i]);\n        sort(a + 1, a + n + 1);\n        for (int i = 2; i <= n; ++i)\n            g = __gcd(g, a[i] - a[i - 1]);\n        for (int i = 1; i <= n; ++i)\n        {\n            if ((k - a[i]) % g == 0)\n            {\n                flag = true;\n                break;\n            }\n        }\n        puts(flag ? \"YES\" : \"NO\");\n    }\n    return 0;\n}\n```\n\n严谨证明需要用裴蜀定理，然而这个东西我很早之前就忘记了。。。\n\n## E\n\n给一个01串，初始为 $s$ 串，目标为 $f$ 串，$q$ 次操作，每次给出左右端点 $[l,r]$，如果该区间内所有元素一致则修改其中严格小于长度一半的元素，否则把串丢弃。问最后能否把 $s$ 变为 $f$。\n\n按照时间逆序操作，就是先修改再判断是否相同，用一个区间赋值线段树就可以解决。\n\n代码改天再写。\n\n## F\n\n改天补。\n\n- 87054415\n\n![87054415](https://i.loli.net/2021/01/29/1PdMetJxq97ARg2.jpg)","tags":["CodeForces"]},{"title":"CF#694div2补题","url":"/2021/01/27/CF694div2/","content":"\n\n无语\n\n\n<!--more-->\n\n## A\n\n水题，循环终点 $n$ 写成 $x$ WA了一发。\n\n```c++\nll a[maxn];\nsigned main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    std::cout.tie(0);\n    int T;\n    cin >> T;\n    while (T--)\n    {\n        ll n, x, ans1 = 0, ans2 = 0;\n        cin >> n >> x;\n        for (int i = 1; i <= n; ++i)\n        {\n            cin >> a[i];\n            ans2 += a[i] / x + !!(a[i] % x);\n            ans1 += a[i];\n        }\n        ans1 = ans1 / x + !!(ans1 % x);\n        cout << ans1 << ' ' << ans2 << '\\n';\n    }\n    return 0;\n}\n```\n\n## B\n\n看起来有点烦，其实拿个队列模拟一下就好了。也是水题。计算答案的时候忘记乘 `tmp.t` 了，又WA一发。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 3e5 + 9;\nconst ll mod = 998244353;\nll n, x;\nstruct node\n{\n    ll val, t;\n    node() {}\n    node(ll a, ll b) : val(a), t(b) {}\n};\n\nqueue<node> q;\nvoid work()\n{\n    while (!q.empty())\n        q.pop();\n    ll ans = 0;\n    cin >> n >> x;\n    for (ll i = 1, t; i <= n; ++i)\n    {\n        cin >> t;\n        q.push(node(t, 1));\n        ans += t;\n    }\n    while (!q.empty())\n    {\n        node tmp = q.front();\n        q.pop();\n        if (tmp.val % x != 0)\n            break;\n        q.push(node(tmp.val / x, x * tmp.t));\n        ans += tmp.val * tmp.t;\n    }\n    cout << ans << '\\n';\n}\n\nsigned main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    std::cout.tie(0);\n    int T;\n    cin >> T;\n    while (T--)\n    {\n        work();\n    }\n    return 0;\n}\n```\n\n## C\n\n就是前几天看到的所谓“反悔贪心”，想法很简单。显然直接给钱不如买礼物，所以要尽可能多的买礼物，我们先假设所有人都送钱，然后从钱数最多的人开始逐渐改成礼物，直到不能再节省为止。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\ntemplate <typename T, typename... Args>\ninline void read(T &t, Args &...args)\n{\n    read(t);\n    read(args...);\n}\n\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 3e5 + 9;\nconst ll mod = 998244353;\nint n, m;\n\nll k[maxn], c[maxn];\npriority_queue<ll> bigpq;\npriority_queue<ll, vector<ll>, greater<ll>> smallpq;\nvoid solve()\n{\n    while (!bigpq.empty())\n        bigpq.pop();\n    while (!smallpq.empty())\n        smallpq.pop();\n    ll ans = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        bigpq.push(c[k[i]]);\n        ans += c[k[i]];\n    }\n    for (int i = 1; i <= m; ++i)\n    {\n        smallpq.push(c[i]);\n    }\n    while (1)\n    {\n        if (bigpq.empty() || smallpq.empty())\n            break;\n        ll a = bigpq.top(), b = smallpq.top();\n        bigpq.pop();\n        smallpq.pop();\n        if (a <= b)\n            break;\n        ans = ans - a + b;\n    }\n    cout << ans << '\\n';\n}\nsigned main()\n{\n    int T;\n    read(T);\n    while (T--)\n    {\n        read(n, m);\n        for (int i = 1; i <= n; ++i)\n            read(k[i]);\n        for (int i = 1; i <= m; ++i)\n            read(c[i]);\n        solve();\n    }\n    return 0;\n}\n```\n\n其实就是用两个堆模拟一下。\n\n## D\n\n题意是这样的：如果 $A,B$ 满足 $\\dfrac{\\text{lcm}(A,B)}{\\gcd(A,B)}$ 是完全平方数，那么称 $A,B$ 是相邻的。定义一个数组的美观度为该数列中与某个元素相邻的数的最大个数（包括自身）。给出一个数组，其中的每个元素每秒会改变一次，变为所有和自身相邻的数的积（包括自身），有 $q$ 次询问，问某次改变后数组的美观度。\n\n很容易发现以下规律：\n\n1. 相邻是具有传递性的（甚至可以推出相邻的数的质因数的指数奇偶性相同）\n2. 两个相邻的数除以它们的最大公约数得到的都是完全平方数\n\n所以很自然的可以将所有数根据除去因数中最大的完全平方数得到的商分类（记作core）。这样我们也就得到了最初情况下的美观度。\n\nvp的时候思路就到这里。\n\n其实应该继续往下想，每次修改的时候，如果core相等的数有奇数个，那么它们乘起来的core不变，否则会变为 $1$。即后续所有答案都和 $1$ 时刻是一样的。\n\n那先筛一下core然后用 `map` 找一下答案就好了。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\ntemplate <typename T, typename... Args>\ninline void read(T &t, Args &...args)\n{\n    read(t);\n    read(args...);\n}\n\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 1e6 + 9;\nconst ll mod = 998244353;\nint core[maxn];\nvoid init()\n{\n    for (int i = 1000; i > 0; --i)\n    {\n        int tmp = i * i;\n        for (int j = tmp; j <= 1000000; j += tmp)\n        {\n            if (core[j] == 0)\n                core[j] = j / tmp;\n        }\n    }\n}\nmap<int, int> mp;\n\nsigned main()\n{\n    init();\n    int T;\n    read(T);\n    while (T--)\n    {\n        int n, q, ans0 = 0, ans1 = 0;\n        read(n);\n        mp.clear();\n        for (int i = 1, x; i <= n; ++i)\n        {\n            read(x);\n            mp[core[x]]++;\n            ans0 = max(ans0, mp[core[x]]);\n        }\n        ans1 = mp[1];\n        for (auto i : mp)\n        {\n            if (i.second && i.first > 1 && i.second % 2 == 0)\n                ans1 += i.second;\n        }\n        for (auto i : mp)\n        {\n            if (i.second && i.first > 1 && i.second % 2 != 0)\n                ans1 = max(ans1, i.second);\n        }\n        read(q);\n        while (q--)\n        {\n            ll w;\n            read(w);\n            cout << (w ? ans1 : ans0) << '\\n';\n        }\n    }\n    return 0;\n}\n```\n\n希望下次能把D给过了。\n\n\n## E\n\n2500分的构造题，以后再说吧。\n\n## F\n\n2200分的图论，有空补一下。\n\n- 87147693\n\n![87147693](https://i.loli.net/2021/01/27/MudkJT7GRBo63gq.jpg)","tags":["CodeForces"]},{"title":"【专题笔记#10】斜率优化","url":"/2021/01/26/Note_010/","content":"\n\n\n在满足决策单调性的前提下，有时候可以使用斜率优化。\n\n\n\n<!--more-->\n\n## P3648 [APIO2014]序列分割\n\n详细分析之后再写\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\ntemplate <typename T, typename... Args>\ninline void read(T &t, Args &...args)\n{\n    read(t);\n    read(args...);\n}\n\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 1e5 + 9;\nconst ll mod = 998244353;\n\nint n, k, ans[209][maxn];\nll s[maxn], f[maxn], g[maxn];\nint que[maxn], l, r;\nint sgn(double x)\n{\n    if (fabs(x) < eps)\n        return 0;\n    else if (x > 0)\n        return 1;\n    else\n        return -1;\n}\n\ndouble slope(int a, int b)\n{\n    ll x1 = -s[a], y1 = g[a] - s[a] * s[a];\n    ll x2 = -s[b], y2 = g[b] - s[b] * s[b];\n    if (sgn(x1 - x2))\n        return (double)(y2 - y1) / (double)(x2 - x1);\n    else\n        return (double)-1e12;\n}\n\nsigned main()\n{\n    read(n, k);\n    for (int i = 1; i <= n; ++i)\n    {\n        read(s[i]);\n        s[i] += s[i - 1];\n    }\n    for (int t = 1; t <= k; t++)\n    {\n        for (int i = 1; i <= n; i++)\n            g[i] = f[i];\n        l = r = 0;\n        for (int i = 1; i <= n; i++)\n        {\n            while (r - l >= 2 && slope(que[l], que[l + 1]) <= s[i])\n                l++;\n            f[i] = 0;\n            if (l < r)\n            {\n                int &j = que[l];\n                ans[t][i] = j;\n                f[i] = g[j] + s[j] * (s[i] - s[j]);\n            }\n            while (r - l >= 2 && slope(que[r - 1], que[r - 2]) >= slope(i, que[r - 1]))\n                r--;\n            que[r++] = i;\n        }\n    }\n    cout << f[n] << '\\n';\n    vi tmp;\n    for (int i = ans[k][n]; k > 0; i = ans[--k][i])\n        tmp.push_back(i);\n    for (auto i = tmp.rbegin(); i != tmp.rend(); ++i)\n        cout << *i << ' ';\n    return 0;\n}\n```\n\n## P3628 [APIO2010]特别行动队\n\n有空再做","tags":["专题笔记"]},{"title":"2021洛谷1月月赛","url":"/2021/01/25/LGR-081/","content":"\n最近学车没时间打洛谷比赛。\n\n<!--more-->\n\n## A\n\n签到题。显然 $x-y$ 的最大值是数组中 $1$ 的个数，所以直接把所有的 $0$ 改成 $1$ 就好了。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 9;\nint a[maxn];\nint main(){\n    int T;\n    scanf(\"%d\", &T);\n    while (T--){\n        int n, ans = 0;\n        scanf(\"%d\", &n);\n        for (int i = 1; i <= n; ++i){\n            scanf(\"%d\", &a[i]);\n            if (a[i] == 1)\n                ans++;\n        }\n        printf(\"%d\\n1\", ans);\n        for (int i = 1; i < n; ++i)\n            printf(\" 1\");\n        printf(\"\\n\");\n        memset(a, 0, sizeof(int) * (n + 1));\n    }\n    return 0;\n}\n```\n\n## B\n\n后面的题以后再补。\n\n洛谷月赛的题有很多有趣的小套路，还是值得一做的。\n\n- 87230559\n\n![87230559](https://i.loli.net/2021/01/25/xrZdVaElmJQDXRo.jpg)","tags":["洛谷"]},{"title":"AtCoder Beginner Contest 189","url":"/2021/01/24/ABC189/","content":"\n\n\n还是做不出E和F。\n\n\n\n<!--more-->\n\n## A\n\n签到题。\n\n```c++\nif (s[0] == s[1] && s[0] == s[2]) puts(\"Won\");\nelse puts(\"Lost\");\n```\n\n## B\n\n签到题。\n\n```c++\nint v[maxn], p[maxn];\nsigned main()\n{\n    int n, x, ans = -1, sum = 0, sign = 0;\n    cin >> n >> x;\n    x *= 100;\n    for (int i = 1; i <= n; ++i)\n    {\n        cin >> v[i] >> p[i];\n        sum += v[i] * p[i];\n        if (sum > x && !sign)\n        {\n            sign = 1;\n            ans = i;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n```\n\n## C\n\n给一个序列，让你求出区间长度与区间最小值之积的最大值。\n\n就是“柱状图中最大矩形”问题。\n\n数据范围1e4，先写了个DFS+ST表，莫名其妙T了，可能是复杂度算假了。然后交了个 $O(n^2)$ 的暴力就过了。\n\n其实可以用单调栈优化到 $O(n)$。\n\n\n## D\n\n本来应该是个DP，如果是 `AND`，$dp[i]=dp[i-1]$，如果是 `OR`，$dp[i]=dp[i-1]+2^i$。\n\n但是看到有人两分钟就把它秒了，显然不需要写这种代码。\n\n```c++\nsigned main()\n{\n    int n;\n    cin >> n;\n    for (ll i = 1; i <= n; ++i)\n    {\n        cin >> s[i];\n        if (s[i] == \"OR\")\n            ans += (1LL << i);\n    }\n    cout << ans << endl;\n    return 0;\n}\n```\n\n感觉比C简单多了。\n\n## E\n\n平面上有 $N$ 个点，给出坐标，对它们进行 $M$ 次操作，操作分为四种：\n\n1. 以原点为中心顺时针旋转所有点\n2. 以原点为中心逆时针旋转所有点\n3. 以直线 $x=p$ 为对称轴翻转所有点\n4. 以直线 $y=p$ 为对称轴翻转所有点\n\n进行 $Q$ 次询问，每次问某次操作结束后某个点的坐标。\n\n数量级都是 $2\\times 10^5$。不会做，看题解。\n\n这些操作都是仿射变换，可以用旋转矩阵来做。\n\n如果只有前两种操作，那么矩阵是这样的：\n\n$$\n\\left(\n\\begin{array}{r}\n\\cos\\theta & -\\sin\\theta\\\\\n\\sin\\theta & \\cos\\theta\n\\end{array}\n\\right)\n$$\n\n但是这样没法搞后两种操作，所以要增加一个维度。\n\n设原来的坐标是 $(x,y)$，矩阵是 $(x,y,1)^T$，于是：\n\n经过第一种操作后变为 $(y,-x,1)^T$，也就是左乘一个矩阵\n\n$$\n\\left(\n\\begin{array}{l}\n0 & 1 & 0\\\\\n-1 & 0 & 0\\\\\n0 & 0 & 1\n\\end{array}\n\\right)\n$$\n\n经过第二种操作后变为 $(-y,x,1)^T$，也就是左乘一个矩阵\n\n$$\n\\left(\n\\begin{array}{l}\n0 & -1 & 0\\\\\n1 & 0 & 0\\\\\n0 & 0 & 1\n\\end{array}\n\\right)\n$$\n\n经过第三种操作后变为 $(2p-x,y,1)^T$，也就是左乘一个矩阵\n\n$$\n\\left(\n\\begin{array}{l}\n-1 & 0 & 2p\\\\\n0 & 1 & 0\\\\\n0 & 0 & 1\n\\end{array}\n\\right)\n$$\n\n经过第四种操作后变为 $(x,2p-y,1)^T$，也就是左乘一个矩阵\n\n$$\n\\left(\n\\begin{array}{l}\n1 & 0 & 0\\\\\n0 & -1 & 2p\\\\\n0 & 0 & 1\n\\end{array}\n\\right)\n$$\n\n那我们只要 $O(n)$ 求出前缀积就可以了。总复杂度是 $O(n)$ 的。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\ntemplate <typename T, typename... Args>\ninline void read(T &t, Args &...args)\n{\n    read(t);\n    read(args...);\n}\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 2e5 + 9;\nconst ll mod = 998244353;\nstruct point\n{\n    ll x, y;\n    point() {}\n    point(int a, int b) : x(a), y(b) {}\n};\npoint p[maxn];\nll mat[maxn][4][4];\n\nsigned main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    std::cout.tie(0);\n    int n, m, q;\n    read(n);\n    for (int i = 1; i <= n; ++i)\n        read(p[i].x, p[i].y);\n    read(m);\n    mat[0][1][1] = mat[0][2][2] = mat[0][3][3] = 1;\n    for (int i = 1, op, d; i <= m; ++i)\n    {\n        read(op);\n        if (op <= 2)\n        {\n            if (op == 1)\n            {\n                for (int j = 1; j <= 3; ++j)\n                {\n                    mat[i][1][j] = mat[i - 1][2][j];\n                    mat[i][2][j] = -mat[i - 1][1][j];\n                    mat[i][3][j] = mat[i - 1][3][j];\n                }\n            }\n            else\n            {\n                for (int j = 1; j <= 3; ++j)\n                {\n                    mat[i][1][j] = -mat[i - 1][2][j];\n                    mat[i][2][j] = mat[i - 1][1][j];\n                    mat[i][3][j] = mat[i - 1][3][j];\n                }\n            }\n        }\n        else\n        {\n            read(d);\n            if (op == 3)\n            {\n                for (int j = 1; j <= 3; ++j)\n                {\n                    mat[i][1][j] = -mat[i - 1][1][j] + 2LL * d * mat[i - 1][3][j];\n                    mat[i][2][j] = mat[i - 1][2][j];\n                    mat[i][3][j] = mat[i - 1][3][j];\n                }\n            }\n            else\n            {\n                for (int j = 1; j <= 3; ++j)\n                {\n                    mat[i][2][j] = -mat[i - 1][2][j] + 2LL * d * mat[i - 1][3][j];\n                    mat[i][1][j] = mat[i - 1][1][j];\n                    mat[i][3][j] = mat[i - 1][3][j];\n                }\n            }\n        }\n    }\n    read(q);\n    while (q--)\n    {\n        int a, b;\n        read(a, b);\n        ll x = p[b].x * mat[a][1][1] + p[b].y * mat[a][1][2] + mat[a][1][3];\n        ll y = p[b].x * mat[a][2][1] + p[b].y * mat[a][2][2] + mat[a][2][3];\n        cout << x << ' ' << y << '\\n';\n    }\n    return 0;\n}\n```\n\n代码写的有点丑，矩阵乘法的地方可以优化很多，即便如此也只跑了112ms，可见复杂度之优秀。\n\n## F\n\n概率DP。\n\n倒推，设 $dp[i]$ 表示从终点走到 $i$ 位置需要的步数，那么答案就是 $dp[0]$，状态转移方程是 $dp[i]=\\dfrac{\\sum_{j=1}^mdp[i+j]}{m}+1$，如果是传送点就是 $dp[0]$。这样递推下去可以发现，$dp[i]$ 都是可以用 $dp[0]$ 来表示的。所以设 $dp[i]=k\\times dp[0]+b$，从后往前推一遍即可，时间复杂度 $O(n)$。\n\n注意特判一下，推到 $dp[0]$ 的时候如果 $k=1$，就无解了。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-6;\nconst int maxn = 3e5 + 9;\nconst ll mod = 998244353;\n\nint sgn(const double &x)\n{\n    if (fabs(x) < eps)\n        return 0;\n    else if (x > 0)\n        return 1;\n    else\n        return -1;\n}\nint n, m, k;\ndouble dp[maxn][2];\nbool vis[maxn];\nsigned main()\n{\n    scanf(\"%d%d%d\", &n, &m, &k);\n    for (int i = 1; i <= k; ++i)\n    {\n        int x;\n        scanf(\"%d\", &x);\n        vis[x] = true;\n    }\n    int l = n + 1, r = n + m;\n    double k = 0, b = 0;\n    for (int i = n - 1; i >= 0; --i)\n    {\n        if (vis[i + m + 1])\n            k -= 1, b -= 0;\n        else\n            k -= dp[i + m + 1][0], b -= dp[i + m + 1][1];\n        if (vis[i + 1])\n            k += 1, b += 0;\n        else\n            k += dp[i + 1][0], b += dp[i + 1][1];\n        if (vis[i])\n            continue;\n        dp[i][0] = k / m;\n        dp[i][1] = b / m + 1;\n    }\n    if (sgn(dp[0][0] - 1) == 0)\n        puts(\"-1\");\n    else\n        printf(\"%.4f\\n\", dp[0][1] / (1.0 - dp[0][0]));\n    return 0;\n}\n```\n\n\n\n- 83471842\n\n![83471842](https://i.loli.net/2021/01/24/VjNkAlSKC3hOicw.jpg)","tags":["AtCoder"]},{"title":"【专题笔记#9】数位DP","url":"/2021/01/23/Note_009/","content":"\n\n\n数位DP基础。\n\n\n\n<!--more-->\n\n## P2602 [ZJOI2010]数字计数\n\n\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\ntemplate <typename T, typename... Args>\ninline void read(T &t, Args &...args)\n{\n    read(t);\n    read(args...);\n}\n\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 1e5 + 9;\nconst ll mod = 998244353;\nll dp[20][20], num[20];\nll dfs(int pos, int dig, ll sum, bool limit, bool lead)\n{\n    ll ret = 0;\n    if (pos == 0)\n        return sum;\n    if (!limit && lead && dp[pos][sum] != -1)\n        return dp[pos][sum];\n    int up = limit ? num[pos] : 9;\n    for (int i = 0; i <= up; ++i)\n        ret += dfs(pos - 1, dig, sum + ((i || lead) && (i == dig)), (i == up) && limit, lead || i);\n    if (!limit && lead)\n        dp[pos][sum] = ret;\n    return ret;\n}\n\nll solve(ll x, int d)\n{\n    memset(dp, -1, sizeof(dp));\n    int len = 0;\n    for (; x; x /= 10)\n        num[++len] = x % 10;\n    return dfs(len, d, 0, 1, 0);\n}\n\nsigned main()\n{\n    ll a, b;\n    read(a, b);\n    for (int i = 0; i <= 9; ++i)\n        cout << solve(b, i) - solve(a - 1, i) << ' ';\n    return 0;\n}\n```\n\n\n\n## P4127 [AHOI2009]同类分布\n\n\n\n## P3413 SAC#1 - 萌数\n\n\n\n","tags":["专题笔记"]},{"title":"C++神奇语法","url":"/2021/01/23/magic/","content":"\n\n\n整理一些不怎么常见的神奇语法。\n\n\n\n<!--more-->\n\n## 数组嵌套访问\n\n`A[B[C[D[i]]]]` 等价于 `i[D][C][B][A]`\n\n","tags":["cpp"]},{"title":"CF#696div2总结","url":"/2021/01/21/CF696div2/","content":"\n\n连A都秒不掉了，看来我确实是变菜了。\n\n\n<!--more-->\n\n## A\n\n虽然是水题但还是做的很慢。\n\n```c++\nchar str[maxn], ans[maxn];\nsigned main()\n{\n    int T;\n    scanf(\"%d\", &T);\n    while (T--)\n    {\n        int n, sign = 0;\n        scanf(\"%d\", &n);\n        scanf(\"%s\", str + 1);\n        ans[1] = '1';\n        for (int i = 2; i <= n; ++i)\n        {\n            ans[i] = '1';\n            if (ans[i] + str[i] == ans[i - 1] + str[i - 1])\n                ans[i] = '0';\n        }\n        for (int i = 1; i <= n; ++i)\n            printf(\"%c\", ans[i]);\n        printf(\"\\n\");\n        memset(ans, 0, sizeof(char) * (n + 1));\n    }\n    return 0;\n}\n```\n\n## B\n\n求拥有至少四个因数且任意两个因数的差至少为 $d$ 的最小的数。\n\n显然这个数的因数可能是 $(1,p,q,pq)$ 或是 $(1,p,p^2,p^3)$，而第二种情况总是比第一种大，不需要考虑。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\ntemplate <typename T, typename... Args>\ninline void read(T &t, Args &...args)\n{\n    read(t);\n    read(args...);\n}\n\n//mt19937 rnd(time(0));\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 2e5 + 9;\nconst ll mod = 998244353;\nbool num[maxn];\nvector<int> prime;\ninline void init(int n)\n{\n    for (int i = 2; i <= n; ++i)\n    {\n        if (!num[i])\n            prime.push_back(i);\n        for (int j = 0; j < prime.size(); ++j)\n        {\n            if (i * prime[j] >= n)\n                break;\n            num[i * prime[j]] = 1;\n            if (i % prime[j] == 0)\n                break;\n        }\n    }\n}\nsigned main()\n{\n    init(50000);\n    int T;\n    read(T);\n    while (T--)\n    {\n        int d;\n        read(d);\n        int p = *lower_bound(prime.begin(), prime.end(), 1 + d);\n        int q = *lower_bound(prime.begin(), prime.end(), p + d);\n        cout << p * q << '\\n';\n    }\n    return 0;\n}\n```\n\n其实复杂度劣一些的也能过。\n\n## C\n\n每次取的两个数中必然包含当前的最大值，所以直接暴力枚举第一次和最大值一起取的就好了。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\ntemplate <typename T, typename... Args>\ninline void read(T &t, Args &...args)\n{\n    read(t);\n    read(args...);\n}\n\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 1e5 + 9;\nconst ll mod = 998244353;\nint a[maxn];\nvector<pii> ans;\nmultiset<int> st;\nsigned main()\n{\n    int T;\n    read(T);\n    while (T--)\n    {\n        int n, res;\n        read(n);\n        for (int i = 1; i <= 2 * n; ++i)\n        {\n            read(a[i]);\n            st.insert(a[i]);\n        }\n        bool flag;\n        sort(a + 1, a + 2 * n + 1, greater<int>());\n        for (int k = 2; k <= 2 * n; ++k)\n        {\n            st.clear();\n            ans.clear();\n            flag = true;\n            int sum = a[1];\n            res = a[1] + a[k];\n            ans.push_back(make_pair(a[1], a[k]));\n            for (int i = 2; i <= 2 * n; ++i)\n                if (i != k)\n                    st.insert(a[i]);\n            for (int i = 2; i <= n; ++i)\n            {\n                auto maxpos = st.end();\n                maxpos--;\n                int maxi = *maxpos;\n                st.erase(maxpos);\n                auto now = st.find(sum - maxi);\n                if (now != st.end())\n                {\n                    sum = maxi;\n                    ans.push_back(make_pair(maxi, *now));\n                    st.erase(now);\n                }\n                else\n                {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag)\n                break;\n        }\n        if (!flag)\n        {\n            puts(\"NO\");\n        }\n        else\n        {\n            puts(\"YES\");\n            printf(\"%d\\n\", res);\n            for (auto i : ans)\n                printf(\"%d %d\\n\", i.first, i.second);\n        }\n        ans.clear();\n        st.clear();\n    }\n    return 0;\n}\n```\n\n代码实现起来有点麻烦。\n\n## D\n\n当时口胡了一个差分+线段树的做法，想复杂了。\n\n其实很简单，求出前缀和、后缀和，swap一次只需要检验周围两个的情况。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint pre[maxn], suf[maxn], a[maxn];\n\nsigned main()\n{\n    int T;\n    read(T);\n    while (T--)\n    {\n        int n;\n        read(n);\n        for (int i = 1; i <= n; ++i)\n            read(a[i]);\n        for (int i = 1; i <= n; ++i)\n        {\n            if (pre[i - 1] == -1 || a[i] < pre[i - 1])\n                pre[i] = -1;\n            else\n                pre[i] = a[i] - pre[i - 1];\n        }\n        suf[n + 1] = 0;\n        for (int i = n; i > 0; --i)\n        {\n            if (suf[i + 1] == -1 || a[i] < suf[i + 1])\n                suf[i] = -1;\n            else\n                suf[i] = a[i] - suf[i + 1];\n        }\n        bool flag = false;\n        if (pre[n] == 0)\n            flag = true;\n        for (int i = 1; i < n; ++i)\n        {\n            if (pre[i - 1] == -1 || suf[i + 2] == -1)\n                continue;\n            else\n            {\n                if (a[i] >= suf[i + 2] && a[i + 1] >= pre[i - 1] && a[i + 1] - pre[i - 1] == a[i] - suf[i + 2])\n                {\n                    flag = true;\n                    break;\n                }\n            }\n        }\n        puts(flag ? \"YES\" : \"NO\");\n    }\n    return 0;\n}\n```\n\n希望下次能把D给过了。\n\n\n## E\n\n有空再看。\n\n## 后记\n\n终于上1700分了（之前一个1699一个1696），可以换号了。\n\n- 87147820\n\n![87147820](https://i.loli.net/2021/01/21/fO3DBtFhgdwozI4.jpg)","tags":["CodeForces"]},{"title":"【专题笔记#8】树形DP","url":"/2021/01/21/Note_008/","content":"\n\n\n通过DFS自底向上更新。\n\n\n\n<!--more-->\n\n## P3574 [POI2014]FAR-FarmCraft\n\n$n$ 个点形成一棵树，一个人只往返每条路径一次派送电脑，经过每条边的时间都是 $1$，每个位置的人装配电脑的时间为 $b_i$，问最晚装完电脑的人最早可以什么时候完成。\n\n题意很简单，但是有点无从下手。记 $g(i)$ 为遍历 $i$ 的子树的最短时间，$f(i)$ 为遍历 $i$ 的子树且装好所有电脑的时间，那么显然 $f(i)>g(i)$，它们的差就是等待的时间。所以可以先把儿子排序再转移。其中从儿子返回父亲的时间已经算在等待时间中了，所以路程时间只需要算一半。\n\n```c++\nconst int maxn = 5e5 + 9;\nint n, val[maxn], f[maxn], g[maxn], son[maxn];\nvi vg[maxn];\nvoid dfs(int pos, int fa)\n{\n    int cnt = 0;\n    if (pos != 1)\n        f[pos] = val[pos];\n    for (auto i : vg[pos])\n        if (i != fa)\n            dfs(i, pos);\n    for (auto i : vg[pos])\n        if (i != fa)\n            son[++cnt] = i;\n    sort(son + 1, son + cnt + 1, [](int x, int y) {\n        return f[x] - g[x] > f[y] - g[y];\n    });\n    for (int i = 1; i <= cnt; ++i)\n    {\n        f[pos] = max(f[pos], f[son[i]] + g[pos] + 1);\n        g[pos] += g[son[i]] + 2;\n    }\n}\nsigned main()\n{\n    read(n);\n    for (int i = 1; i <= n; ++i)\n        read(val[i]);\n    for (int i = 1, u, v; i < n; ++i)\n    {\n        read(u, v);\n        vg[u].emplace_back(v);\n        vg[v].emplace_back(u);\n    }\n    dfs(1, 0);\n    cout << max(f[1], g[1] + val[1]) << '\\n';\n    return 0;\n}\n```\n\n不要DFS一个儿子以后直接记录这个儿子，这样记录的信息会被后面DFS的过程破坏。\n\n## P2014 [CTSC1997]选课\n\n每门课都有相应的学分和至多一个先修课，有先修课的课程必须学了先修课才能选，一共有 $n$ 门课，至多选 $m$ 门，问最多能拿多少学分。\n\n显然这些课程会构成一个森林，所以先把 $0$ 做成超级根节点把它们合并成一棵树，然后就相当于可以选 $m+1$ 门课。 这就变成树形背包的问题。\n\n用 $dp[x][y][z]$ 表示在 $x$ 的子树中前 $y$ 个结点选 $z$ 门课的最大学分，那么对于根结点，$dp[root][1][1]=val[root]$ 是显然的。可以得到状态转移方程 $dp[root][j][k]=\\max(dp[root][j-1][k],dp[son][i][l]+dp[root][j-1][k-l])$。\n\n因为我们之前已经递归求解过子树的信息，只需要考虑根结点这边的信息。这里可以对空间进行优化，上面式子中的 $l$ 是小于 $k$ 的，可以用类似于01背包的思想倒着循环 $k$，把中间这一维优化掉。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 400;\nint n, m;\nint fa[maxn], dp[maxn][maxn];\nvector<int> g[maxn];\nvoid dfs(int u)\n{\n    for (auto i : g[u])\n    {\n        dfs(i);\n        for (int j = m + 1; j > 0; --j)\n            for (int k = 0; k < j; ++k)\n                dp[u][j] = max(dp[u][j], dp[i][k] + dp[u][j - k]);\n    }\n}\nint main()\n{\n    cin >> n >> m;\n    for (int i = 1; i <= n; ++i)\n    {\n        cin >> fa[i] >> dp[i][1];\n        g[fa[i]].emplace_back(i);\n    }\n    dfs(0);\n    cout << dp[0][m + 1] << endl;\n    return 0;\n}\n```\n\n## P1272 重建道路\n\n令 $dp[i][j]$ 表示以 $i$ 为根结点，保留 $j$ 个结点且根节点与父亲连接的情况下断开的最少边数。\n\n这题还没完全搞明白，以后再回来做一遍。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 200;\nconst ll mod = 998244353;\n\nint n, k, root, ans;\nint dp[maxn][maxn], cnt[maxn];\nvi g[maxn];\nbool son[maxn];\n\nint dfs(int fa)\n{\n    int sum = 1;\n    for (auto u : g[fa])\n    {\n        sum += dfs(u);\n        for (int i = sum; i > 0; --i)\n        {\n            for (int j = 1; j < i; ++j)\n                dp[fa][i] = min(dp[fa][i], dp[fa][i - j] + dp[u][j] - 1);\n        }\n    }\n    return sum;\n}\n\nsigned main()\n{\n    read(n, k);\n    memset(dp, 0x3f, sizeof(dp));\n    for (int i = 1, u, v; i < n; ++i)\n    {\n        read(u, v);\n        cnt[u]++;\n        son[v] = true;\n        g[u].emplace_back(v);\n    }\n    for (int i = 1; i <= n; ++i)\n    {\n        dp[i][1] = cnt[i];\n        if (!son[i])\n            root = i;\n    }\n    dfs(root);\n    int ans = dp[root][k];\n    for (int i = 1; i <= n; ++i)\n        ans = min(ans, dp[i][k] + 1);\n    cout << ans << '\\n';\n    return 0;\n}\n```\n\n\n\n## P3354 [IOI2005]Riv 河流\n\n以后再做。\n\n- 86806585\n- 狂风，听我号令！[doge]\n\n![86806585](https://i.loli.net/2021/01/21/yXmKqtJp2ofgTvl.jpg)","tags":["专题笔记"]},{"title":"【专题笔记#7】反悔贪心","url":"/2021/01/20/Note_007/","content":"\n\n\n本来这篇笔记想继续写DP的，但是在今天的新生培训作业里发现了一个有趣的题，就来这里写一下。\n\n\n\n<!--more-->\n\n## 模板题：CF865D Buy Low Sell High\n\n已知接下来 $N$ 天某支股票的价格 $p_i$，每天可以买进一股股票、卖出一股股票或者什么都不做，$N$ 天后拥有的股票数量为 $0$，资金数量无限多，问 $N$ 天后最多赚多少钱。\n\n很自然的想法是，在价格为极小值的时候买入，在价格为极大值的时候卖出。但是这样是不对的：\n\n```\n9\n10 5 4 7 9 12 6 2 10\n```\n\n如果我们在 $4$ 处买入，$12$ 处卖出，$2$ 处买入，$10$ 处卖出，可以赚 $16$。但是这并没有考虑到在 $5$ 处买入，$9$ 处卖出的情况。这个样例的答案应该是 $20$。\n\n我们很难知道在最优策略中，买入一个物品后应该什么时候卖出，但是观察上面的例子，可以发现：$9-7+7-4=9-4$，我们可以设计一种策略，让非最优选择在计算中被抵消掉。\n\n考虑维护一个可重集，每天我们都卖出之前最低价格的股票，并买入当前的。如果在这时候卖股票是最优解，那么买进来的东西今后再也不会被卖掉了（否则就不是最优解），不会影响正确性；如果并不是最优解，意味着卖股票这个操作会被抵消掉，也不会影响正确性。\n\n因此可以用一个堆来模拟这种反悔操作。\n\n```c++\npriority_queue<int, vi, greater<int>> pq;\nsigned main()\n{\n    ll n, ans = 0;\n    read(n);\n    for (int i = 1, x; i <= n; ++i)\n    {\n        read(x);\n        if (!pq.empty() && pq.top() < x)\n        {\n            ans += x - pq.top();\n            pq.pop();\n            pq.push(x);\n        }\n        pq.push(x);\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n```\n\n## P2949 [USACO09OPEN]Work Scheduling G\n\n[题目链接](https://www.luogu.com.cn/problem/P2949)\n\n改天再做。\n\n## P1792 [国家集训队]种树\n\n[题目链接](https://www.luogu.com.cn/problem/P1792)\n\n改天再做。\n\n\n\n- 85847132\n\n![85847132](https://i.loli.net/2021/01/20/dTJUqeNWjK6OE3u.jpg)","tags":["专题笔记"]},{"title":"【专题笔记#6】单调队列优化DP","url":"/2021/01/19/Note_006/","content":"\n\n\n常见的单调队列优化DP。\n\n\n\n<!--more-->\n\n## 模板\n\n模板题链接：[P1886](https://www.luogu.com.cn/problem/P1886)\n\n原理：当一个元素准备进队时，从队尾向前逐个比对，将所有不大于该元素的队列成员从队尾出队，然后将该元素进队。然后从队首开始逐个检验成员的下标，将下标超出范围的从队首出队。\n\n用 `deque` 或者数组都行。\n\n优化DP的模板：[P1725 琪露诺](https://www.luogu.com.cn/problem/P1725)\n\n```c++\nint n, l, r, ans = -inf;\nint a[maxn], dp[maxn];\ndeque<int> dq;\nsigned main()\n{\n    read(n, l, r);\n    fill(dp + 1, dp + n + 1, -inf);\n    for (int i = 0; i <= n; ++i)\n        read(a[i]);\n    for (int i = l; i <= n; ++i)\n    {\n        while (!dq.empty() && dp[dq.back()] <= dp[i - l])\n            dq.pop_back();\n        dq.push_back(i - l);\n        while (!dq.empty() && dq.front() + r < i)\n            dq.pop_front();\n        dp[i] = dp[dq.front()] + a[i];\n        if (i + r > n)\n            ans = max(ans, dp[i]);\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n```\n\n\n## CF372C Watching Fireworks is Fun\n\n一个城镇有 $n$ 个区域，编号从 $1$ 到 $n$，每个区域之间距离 $1$ 个单位距离。\n节日中有 $m$ 个烟火要放，给定放的地点 $a_i$，时间 $t_i$，如果你当时在区域 $x$，那么你可以获得 $b_i - \\vert a_i - x\\vert$ 的开心值。\n你每个单位时间可以移动不超过 $d$ 个单位距离。 你的初始位置是任意的（初始时刻为 $1$），求你通过移动能获取到的最大的开心值。\n\n设 $\\large f_{i,j}$ 表示在放第 $i$ 个烟花时在 $j$ 位置所能获得的最大快乐值，状态转移方程就是 $\\large f_{i,j}=\\max\\{f_{i-1,k}+b_i- \\vert a_i - j\\vert\\}$，其中 $k$ 的范围是 $\\large [\\max(1,j-\\Delta t\\times d),\\min(n,j+\\Delta t\\times d)]$。\n\n最后我们只要求出 $\\large \\max\\{f_{m,i}\\}$ 即可。\n\n但是这样的话时空复杂度都会爆炸，需要做几个优化。\n\n首先观察状态转移方程，在 $i$ 与 $j$ 确定的时候，$\\large f_{i,j}=\\max\\{f_{i-1,k}\\}+b_i- \\vert a_i - j\\vert$，所以可以用一个单调队列维护 $\\large \\max\\{f_{i-1,k}\\}$，将复杂度从 $O(n^2m)$ 降低到 $O(nm)$。\n\n空间上使用滚动数组优化，不然也会炸。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\ntemplate <typename T, typename... Args>\ninline void read(T &t, Args &...args)\n{\n    read(t);\n    read(args...);\n}\n\nconst int inf = 0x3f3f3f3f;\nconst ll linf = 0x3f3f3f3f3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 150000 + 9;\nconst int maxm = 309;\nconst ll mod = 998244353;\n\nll a[maxm], b[maxm], t[maxm];\nll dp[maxn], tmp[maxn], que[maxn];\n\nsigned main()\n{\n    ll n, m, d, ans = -linf;\n    read(n, m, d);\n    ll sz = max(n, m) + 1;\n    for (int i = 1; i <= m; ++i)\n        read(a[i], b[i], t[i]);\n    for (int i = 1; i <= m; ++i)\n    {\n        ll l = 1, r = 0, pos = 1, x = (t[i] - t[i - 1]) * d;\n        for (int j = 1; j <= n; ++j)\n        {\n            for (; pos <= min(n, x + j); ++pos)\n            {\n                while (l <= r && tmp[que[r]] <= tmp[pos])\n                    r--;\n                que[++r] = pos;\n            }\n            while (l <= r && que[l] < j - x)\n                l++;\n            dp[j] = tmp[que[l]] + b[i] - abs(a[i] - j);\n        }\n        memcpy(tmp, dp, sizeof(ll) * sz);\n    }\n    for (int i = 1; i <= n; ++i)\n        ans = max(ans, dp[i]);\n    cout << ans << endl;\n    return 0;\n}\n```\n\n\n\n\n## P1776 宝物筛选\n\n多重背包，最简单的办法是二进制拆分转化成01背包：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 50000;\nconst double eps = 1e-8;\nconst int maxn = 5e4 + 9;\nconst ll mod = 998244353;\n\nint n, maxw;\nint t[maxn], c[maxn], p[maxn], dp[maxn];\nint v[maxn], w[maxn], m[maxn];\nint cnt, cost[maxn], val[maxn];\nvoid init()\n{\n    for (int i = 1; i <= n; ++i)\n    {\n        int tot = 1;\n        while (m[i] > 0)\n        {\n            cost[++cnt] = tot * w[i];\n            val[cnt] = tot * v[i];\n            m[i] -= tot;\n            tot *= 2;\n            if (m[i] < tot)\n            {\n                cost[++cnt] = w[i] * m[i];\n                val[cnt] = v[i] * m[i];\n                break;\n            }\n        }\n    }\n}\n\nsigned main()\n{\n    scanf(\"%d%d\", &n, &maxw);\n    for (int i = 1; i <= n; ++i)\n        scanf(\"%d%d%d\", &v[i], &w[i], &m[i]);\n    init();\n    for (int i = 1; i <= cnt; ++i)\n    {\n        for (int j = maxw; j >= cost[i]; --j)\n            dp[j] = max(dp[j], dp[j - cost[i]] + val[i]);\n    }\n    printf(\"%d\\n\", dp[maxw]);\n    return 0;\n}\n```\n\n但是也可以用单调队列优化：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 4e4 + 9;\nconst ll mod = 998244353;\nint n, m, ans, head, tail, q[maxn], q2[maxn], dp[maxn];\nsigned main()\n{\n    cin >> n >> m;\n    for (int i = 1; i <= n; ++i)\n    {\n        int v, w, c;\n        cin >> w >> v >> c;\n        if (v == 0)\n        {\n            ans += w * c;\n            continue;\n        }\n        c = min(c, m / v);\n        for (int d = 0; d < v; d++)\n        {\n            head = tail = 0;\n            int k = (m - d) / v;\n            for (int j = 0; j <= k; j++)\n            {\n                while (head < tail && dp[d + j * v] - j * w >= q2[tail - 1])\n                    tail--;\n                q[tail] = j;\n                q2[tail++] = dp[d + j * v] - j * w;\n                while (head < tail && q[head] < j - c)\n                    ++head;\n                dp[d + j * v] = max(dp[d + j * v], q2[head] + j * w);\n            }\n        }\n    }\n    cout << ans + dp[m] << '\\n';\n    return 0;\n}\n```\n\n\n\n\n\n\n- 86464521\n\n![86464521](https://i.loli.net/2021/01/18/o8UkbtXPaf7pZlC.jpg)\n\n","tags":["专题笔记"]},{"title":"CF#695div2补题","url":"/2021/01/18/CF695div2/","content":"\n\n寒假第一次补题。\n\n\n<!--more-->\n\n## A\n\n一个长度为 $n$ 的数字板初始全为 $0$，每秒钟增加 $1$，对 $10$ 取模，一个位置暂停后相邻的板也会延迟 $1$ 秒暂停，问在一个位置暂停后等所有板都暂停形成的最大数字是多少。\n\n显然，高位数字越大越好，所以形成的序列应该是 `9890123...` 这样的。\n\n```c++\nsigned main()\n{\n    int T;\n    cin >> T;\n    while (T--)\n    {\n        int n;\n        cin >> n;\n        if (n == 1)\n            cout << 9 << '\\n';\n        else if (n == 2)\n            cout << 98 << '\\n';\n        else\n        {\n            cout << 98;\n            int tmp = 8;\n            for (int i = 1; i <= n - 2; ++i)\n            {\n                tmp = (tmp + 1) % 10;\n                cout << tmp;\n            }\n            cout << '\\n';\n        }\n    }\n    return 0;\n}\n```\n\n水题，没什么好说的。\n\n## B\n\n给一个长度为 $n$ 的序列，在 $[2,n-1]$ 中比相邻元素都小的叫 valley，比相邻元素都大的叫 hill，问最多调整一次的情况下，hill 和 valley 的个数之和最少是多少。\n\n显然，不可能存在相邻的 hill 或者 valley。\n\n手动模拟一些情况，可以发现：\n\n- 如果一个 hill 的两边都是 valley，那么一次修改可以使答案减少 $3$，这也是最优的情况。\n- 如果一个 hill 的左边是 valley，那么修改一次减少 $1$ 或 $2$，取决于 $i-1$ 和 $i-2$ 位置的值。如果在右边也是一样。\n- 如果一个 hill 的两边都没有 valley，那么一次修改只能使答案减少 $1$。\n- valley 的情况和 hill 类似。\n\n所以分类讨论即可。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 3e5 + 9;\nconst ll mod = 998244353;\nint a[maxn];\nbool valley[maxn], hill[maxn];\nsigned main()\n{\n    int T;\n    cin >> T;\n    while (T--)\n    {\n        int n, ans = 0, cnt = 0;\n        cin >> n;\n        for (int i = 1; i <= n; ++i)\n            cin >> a[i];\n        a[0] = a[1], a[n + 1] = a[n];\n        for (int i = 2; i <= n - 1; ++i)\n        {\n            if (a[i] < a[i - 1] && a[i] < a[i + 1])\n            {\n                valley[i] = true;\n                ans++;\n            }\n            if (a[i] > a[i - 1] && a[i] > a[i + 1])\n            {\n                hill[i] = true;\n                ans++;\n            }\n        }\n        for (int i = 2; i <= n - 1; ++i)\n        {\n            if (valley[i])\n            {\n                if (hill[i - 1] && hill[i + 1])\n                    cnt = max(cnt, 3);\n                else if (hill[i - 1])\n                {\n                    if (a[i + 1] >= a[i - 1] || a[i + 2] == a[i + 1])\n                        cnt = max(cnt, 2);\n                    else\n                        cnt = max(cnt, 1);\n                }\n                else if (hill[i + 1])\n                {\n                    if (a[i + 1] <= a[i - 1] || a[i - 2] == a[i - 1])\n                        cnt = max(cnt, 2);\n                    else\n                        cnt = max(cnt, 1);\n                }\n                else\n                    cnt = max(cnt, 1);\n            }\n            if (hill[i])\n            {\n                if (valley[i - 1] && valley[i + 1])\n                    cnt = max(cnt, 3);\n                else if (valley[i - 1])\n                {\n                    if (a[i + 1] <= a[i - 1] || a[i + 2] == a[i + 1])\n                        cnt = max(cnt, 2);\n                    else\n                        cnt = max(cnt, 1);\n                }\n                else if (valley[i + 1])\n                {\n                    if (a[i + 1] >= a[i - 1] || a[i - 2] == a[i - 1])\n                        cnt = max(cnt, 2);\n                    else\n                        cnt = max(cnt, 1);\n                }\n                else\n                    cnt = max(cnt, 1);\n            }\n        }\n        cout << ans - cnt << '\\n';\n        memset(valley, 0, sizeof(bool) * (n + 2));\n        memset(hill, 0, sizeof(bool) * (n + 2));\n    }\n    return 0;\n}\n```\n\n一开始以为B题不会这么复杂，写了这个：\n\n```c++\nbool pre = valley[i - 1] | hill[i - 1];\nbool nxt = valley[i + 1] | hill[i + 1];\nif ((pre | nxt) == false)\n\tcnt = max(cnt, 1);\nelse {\n\tif ((pre & nxt) == false) cnt = max(cnt, 2);\n\telse cnt = max(cnt, 3);\n}\n```\n\n喜提 Wrong answer on test 3。\n\n\n## C\n\n有三个数集，每个集合中含有若干个正整数，每次从两个不同集合中取出 $a$ 和 $b$，删去 $b$ 并把 $a$ 修改为 $a-b$，问最后剩下的一个数最大可以是多少。\n\n假设有 $a$，$b$，$c$ 三个集合，并满足 $ \\min_a\\le  \\min_b \\le  \\min_c$，大概可以发现是这样的流程：先选择最小的数，并用这个数减去其它两个集合中除去最小数之外的所有数，大概是这样的情况：$\\{ \\min_a+ \\min_b+ \\min_c-\\sum_b-\\sum_c,a_2,\\cdots\\}$，$\\{ \\min_b\\}$，$\\{ \\min_c\\}$。\n\n然后可以把 $a$ 集合第一项减到一个集合中，把 $a$ 集合的其它元素减到另一个集合中，最后会得到 $\\sum_{a,b,c}-2\\min_a-2\\min_b$。\n\n如果这样写，又会喜提 Wrong answer on test 3，因为如果 $a$ 集合中的元素都非常小，而其它集合中的元素都很大，还可以先把 $\\min_c$ 减到 $a$ 集合中，再把 $a$ 集合全部减到 $\\min_b$ 上面，这样的答案是 $\\sum_{b,c}-\\sum_a$。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 1e5 + 9;\nconst ll mod = 998244353;\nll m[4], sum[4];\nsigned main()\n{\n    int a, b, c;\n    ll x;\n    cin >> a >> b >> c;\n    m[1] = m[2] = m[3] = inf;\n    for (int i = 1; i <= a; ++i)\n    {\n        cin >> x;\n        sum[1] += x;\n        m[1] = min(m[1], x);\n    }\n    for (int i = 1; i <= b; ++i)\n    {\n        cin >> x;\n        sum[2] += x;\n        m[2] = min(m[2], x);\n    }\n    for (int i = 1; i <= c; ++i)\n    {\n        cin >> x;\n        sum[3] += x;\n        m[3] = min(m[3], x);\n    }\n    x = sum[1] + sum[2] + sum[3];\n    ll y = min(sum[1], min(sum[2], sum[3]));\n    ll z = m[1] + m[2] + m[3] - max(m[1], max(m[2], m[3]));\n    cout << x - 2 * min(y, z) << endl;\n    return 0;\n}\n```\n\n这题虽然不难，但也没那么容易想。\n\n## D\n\n一排有 $n$ 个格子，第 $i$ 个的权值是 $a_i$，有 $q$ 次单点修改某个权值，每次修改后求机器人在这些格子里来回走总路程为 $k$ 的所有路径上权值之和。\n\n因为 $k$ 是不变的，很自然的想到计算每个格子的贡献，修改的时候只需要计算对单点的影响即可。\n\n所以令 `dp[i][j]` 表示第 $j$ 步经过 $i$ 的方案数，那么 `dp[i][j] = dp[i - 1][j - 1] + dp[i + 1][j - 1]`，注意特判边界。\n\n思路到这里就断了。其实应该继续下去找方案数和次数的联系。之前设计的状态是第 $j$ 步经过 $i$ 的方案数，那么将所有路径反向，可以发现这也是从 $i$ 出发走了 $j$ 步的合法方案数。那么就可以知道所有方案经过 $i$ 点的次数了。\n\n接下来计算答案和更新就非常简单。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\ntemplate <typename T, typename... Args>\ninline void read(T &t, Args &...args)\n{\n    read(t);\n    read(args...);\n}\n\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 1e4 + 9;\nconst ll mod = 1e9 + 7;\nint n, k, q;\nll a[maxn], dp[5009][5009], cnt[maxn], ans;\nsigned main()\n{\n    read(n, k, q);\n    for (int i = 1; i <= n; ++i)\n        read(a[i]);\n    for (int i = 1; i <= n; ++i)\n        dp[i][0] = 1;\n    for (int j = 1; j <= k; ++j)\n    {\n        for (int i = 1; i <= n; ++i)\n        {\n            if (i == 1)\n                dp[i][j] = dp[i + 1][j - 1];\n            else if (i == n)\n                dp[i][j] = dp[i - 1][j - 1];\n            else\n                dp[i][j] = (dp[i + 1][j - 1] + dp[i - 1][j - 1]) % mod;\n        }\n    }\n    for (int i = 1; i <= n; ++i)\n    {\n        for (int j = 0; j <= k; ++j)\n        {\n            cnt[i] = (cnt[i] + dp[i][j] * dp[i][k - j]) % mod;\n        }\n    }\n    for (int i = 1; i <= n; ++i)\n        ans = (ans + cnt[i] * a[i]) % mod;\n    while (q--)\n    {\n        ll x, y;\n        read(x, y);\n        ans = (ans - a[x] * cnt[x] % mod + mod + y * cnt[x] % mod) % mod;\n        a[x] = y;\n        printf(\"%I64d\\n\", ans % mod);\n    }\n    return 0;\n}\n```\n\n## E\n\n给定一个大小为 $n(1\\leq n \\leq 2\\times 10^5)$ 的树，每个点有一个权值 $a_i(1\\leq a_i\\leq 10^9)$ ，求有多少个点 $u$ 满足从 $u$ 出发的任意一条路径上的点的权值不重复。\n\n改天再补。\n\n\n\n- 84958354\n\n![84958354](https://i.loli.net/2021/01/19/E37zxDwinXWmcVI.jpg)","tags":["CodeForces"]},{"title":"【专题笔记#5】区间DP","url":"/2021/01/18/Note_005/","content":"\n\n\n区间DP基础。断环成链。\n\n\n\n<!--more-->\n\n## P1043 [NOIP2003 普及组] 数字游戏\n\n\n\n## CF149D Coloring Brackets\n\n\n\n## UVA12991 Game Rooms\n\n\n\n[kuangbin](https://www.luogu.com.cn/blog/hhz6830975/kuangbin-dai-ni-fei-zhuan-ti-er-shi-er-ou-jian-dp)","tags":["专题笔记"]},{"title":"KEYENCE Programming Contest 2021","url":"/2021/01/17/AtCoderKEYENCE2021/","content":"\n\n\n快一个月没打比赛，又变菜了。。。\n\n[比赛链接](https://atcoder.jp/contests/keyence2021)\n\n\n\n<!--more-->\n\n\n\n## A\n\n给两个长度为 $N$ 的序列 $a_N$ 和 $b_N$，让你输出一个序列 $c_N$ 满足 $c_k=\\max_{1\\le i\\le j\\le k}a_ib_j$。\n\n注意到 $i\\le j$，所以 $c_k=\\max(c_{k-1},b_k\\times \\max_{1\\le i \\le k}a_i)$。\n\n```c++\nll a[maxn], b[maxn];\npriority_queue<ll> pq;\nsigned main()\n{\n    int n;\n    read(n);\n    for (int i = 1; i <= n; ++i)\n        read(a[i]);\n    for (int i = 1; i <= n; ++i)\n        read(b[i]);\n    ll ans = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        pq.push(a[i]);\n        ans = max(ans, pq.top() * b[i]);\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}\n```\n\n当时写了这个，其实完全不需要用到堆。\n\n## B\n\n有 $n$ 个数和 $k$ 个集合，每个数字可以随意放入集合中，放完后每个集合上显示未出现在该集合内的最小自然数，求集合上的这些数的和的最大值。\n\n为了让第一个未出现在集合中的数尽可能大，我们需要让同一个数尽可能分散在多个集合中。如果某个集合显示的数已经确定了，那就不需要再往里面添加了。\n\n当时绕了一些弯路才想到正解。\n\n```c++\nint cnt[maxn];\nsigned main()\n{\n    ll n, k, ans = 0;\n    read(n, k);\n    for (int i = 1, x; i <= n; ++i)\n    {\n        read(x);\n        cnt[x]++;\n    }\n    for (int i = 0; i <= 300001; ++i)\n    {\n        if (cnt[i] >= k)\n            continue;\n        ans += (k - cnt[i]) * i;\n        k = cnt[i];\n        if (k == 0)\n            break;\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n```\n\n## C\n\n一个 $H\\times W$ 的矩阵，里面 $k$ 个格子里有字符，`D` 表示向下走，`R` 表示向右走，`X` 表示两种均可。现在让你在空格子里填这三种字符，问有多少种填法可以从 $(1,1)$ 走到 $(H,W)$。答案对 $998244353$ 取模。\n\n写了快一个小时的DP都没把样例过去。。。\n\n令 `dp[i][j][k]` 表示从 $(1,1)$ 走到 $(i,j)$ 经过 $k$ 个空格的路径数，显然在路径上的空格只有两种选择，否则有三种选择。所以答案是 $\\sum_{i=0}^{H+W}\\text{dp}[H][W][i]2^i3^{HW-k-i}$。\n\n这个式子可以化简为 $3^{HW-k}\\sum_{i=0}^{H+W}\\text{dp}[H][W][i](\\dfrac{2}{3})^i$，这样一个 $O(HW)$ 的DP就可以写出来了。\n\n```c++\n#include <bits/stdc++.h>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n//#include <ext/pb_ds/priority_queue.hpp>\n//#include <ext/pb_ds/hash_policy.hpp>\nusing namespace std;\n//using namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n//typedef gp_hash_table<int, int> hashmap;\n//typedef tree<pii, null_type, std::less<pii>, splay_tree_tag, tree_order_statistics_node_update> splaytree;\n//typedef tree<pii, null_type, std::less<pii>, rb_tree_tag, tree_order_statistics_node_update> rbtree;\n//typedef __gnu_pbds::priority_queue<int, std::greater<int>, __gnu_pbds::binary_heap_tag> binheap;\n//typedef __gnu_pbds::priority_queue<int, std::greater<int>, __gnu_pbds::pairing_heap_tag> pairingheap;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\ntemplate <typename T, typename... Args>\ninline void read(T &t, Args &...args)\n{\n    read(t);\n    read(args...);\n}\n\n//mt19937 rnd(time(0));\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 5e3 + 9;\nconst ll mod = 998244353;\nchar mp[maxn][maxn];\nll dp[maxn][maxn];\n\nll ksm(ll n, ll k)\n{\n    int ret = 1;\n    while (k)\n    {\n        if (k & 1)\n            ret = ret * n % mod;\n        k /= 2;\n        n = n * n % mod;\n    }\n    return ret;\n}\n\nsigned main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    std::cout.tie(0);\n    ll h, w, k;\n    cin >> h >> w >> k;\n    for (int i = 1, x, y; i <= k; ++i)\n    {\n        cin >> x >> y;\n        cin >> mp[x][y];\n    }\n    dp[1][1] = 1;\n    ll inv = ksm(3, mod - 2);\n    for (int i = 1; i <= h; ++i)\n    {\n        for (int j = 1; j <= w; ++j)\n        {\n            if (mp[i][j] == 'R' || mp[i][j] == 'X')\n                dp[i][j + 1] = (dp[i][j] + dp[i][j + 1]) % mod;\n            if (mp[i][j] == 'D' || mp[i][j] == 'X')\n                dp[i + 1][j] = (dp[i][j] + dp[i + 1][j]) % mod;\n            if (mp[i][j] == 0)\n            {\n                dp[i][j + 1] = (dp[i][j] * 2 * inv % mod + dp[i][j + 1]) % mod;\n                dp[i + 1][j] = (dp[i][j] * 2 * inv % mod + dp[i + 1][j]) % mod;\n            }\n        }\n    }\n    cout << ksm(3, h * w - k) * dp[h][w] % mod << '\\n';\n    return 0;\n}\n```\n\n## D\n\n没看懂题意。\n\n有个人的[代码](https://atcoder.jp/contests/keyence2021/submissions/19490745)非常有意思，但是我不知道是什么原理。先放在这里。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint n, siz[1 << 8];\nint main()\n{\n    scanf(\"%d\", &n);\n    printf(\"%d\\n\", (1 << n) - 1);\n    for (int i = 0; i < 1 << n; i++)\n        siz[i] = siz[i >> 1] ^ (i & 1);\n    for (int i = 1; i <= (1 << n) - 1; i++, puts(\"\"))\n        for (int j = 0; j < (1 << n); j++)\n            putchar('A' + siz[i & j]);\n    return 0;\n}\n```\n\n\n\n- 85762463\n\n![85762463](https://i.loli.net/2021/01/17/GaUVncpqEQIkYfg.jpg)","tags":["AtCoder"]},{"title":"【专题笔记#4】动态规划基础","url":"/2021/01/17/Note_004/","content":"\n\n\n记录几种基础的动态规划技巧。未完待续。\n\n\n\n<!--more-->\n\n## P5694 [NOI2001] 陨石的秘密\n\n[题目链接](https://www.luogu.com.cn/problem/P5694)\n\n这题最直接的状态设计方法是令 `dp[i][j][k][d]` 表示使用了 $i$ 个 `{}`，$j$ 个 `[]`，$k$ 个 `()` 组成深度为 $d$ 的序列的个数。然后状态转移方程就搞不出来了。\n\n所以需要改变一下状态，参考数位DP的想法，令 `dp[i][j][k][d]` 表示使用了 $i$ 个 `{}`，$j$ 个 `[]`，$k$ 个 `()` 组成深度**不超过** $d$ 的序列的个数，那么转移到当前状态有两种可能性：\n\n1. 在一个序列外部加括号\n2. 将两个序列拼接起来\n\n注意到第二种转移方式在统计时可能会重复计算，比如 `()()()` 可能是 `()` 与 `()()` 拼起来的，也有可能是反过来的情况。重复的原因在于这样的序列的断点不止一个，因此我们可以强制在第一个断点处拼接来避免重复。\n\n然后还可以发现，在一个序列外面加括号也就相当于把空串拼接到一个序列前面。\n\n这样就得到了一个暴力至极的代码，复杂度是 $O(DL^6)$。\n\n```c++\nconst ll mod = 11380;\nll dp[15][15][15][50];\nint i, j, k, d;\n\nsigned main()\n{\n    cin >> i >> j >> k >> d;\n    for (int ii = 0; ii <= i; ++ii)\n    {\n        for (int jj = 0; jj <= j; ++jj)\n        {\n            for (int kk = 0; kk <= k; ++kk)\n            {\n                for (int dd = 0; dd <= d; ++dd)\n                {\n                    if (ii == 0 && jj == 0 && kk == 0)\n                    {\n                        dp[ii][jj][kk][dd] = 1;\n                        continue;\n                    }\n                    if (dd == 0)\n                        continue;\n                    for (int a = 0; a < ii; ++a)\n                    {\n                        for (int b = 0; b <= jj; ++b)\n                        {\n                            for (int c = 0; c <= kk; ++c)\n                            {\n                                dp[ii][jj][kk][dd] += dp[a][b][c][dd - 1] * dp[ii - a - 1][jj - b][kk - c][dd] % mod;\n                                dp[ii][jj][kk][dd] %= mod;\n                            }\n                        }\n                    }\n                    for (int b = 0; b < jj; ++b)\n                    {\n                        for (int c = 0; c <= kk; ++c)\n                        {\n                            dp[ii][jj][kk][dd] += dp[0][b][c][dd - 1] * dp[ii][jj - b - 1][kk - c][dd] % mod;\n                            dp[ii][jj][kk][dd] %= mod;\n                        }\n                    }\n                    for (int c = 0; c < kk; ++c)\n                    {\n                        dp[ii][jj][kk][dd] += dp[0][0][c][dd - 1] * dp[ii][jj][kk - c - 1][dd] % mod;\n                        dp[ii][jj][kk][dd] %= mod;\n                    }\n                }\n            }\n        }\n    }\n    if (d == 0)\n        cout << dp[i][j][k][d] << endl;\n    else\n        cout << (dp[i][j][k][d] - dp[i][j][k][d - 1] + mod) % mod << endl;\n    return 0;\n}\n```\n\n## P1833 樱花\n\n[题目链接](https://www.luogu.com.cn/problem/P1833)\n\n很不错的混合背包问题。商品费用为 $T_i$，质量为 $C_i$，数量为 $P_i$，问费用不超过 $t$ 的前提下能获得的最大质量。\n\n二进制拆分转化为01背包求解即可。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int inf = 1025;\nconst double eps = 1e-8;\nconst int maxn = 1e4 + 9;\nconst int maxm = 1e6 + 9;\nconst ll mod = 998244353;\n\nint h1, h2, m1, m2, n;\nint t[maxn], c[maxn], p[maxn], dp[maxn];\nint cnt, cost[maxm], val[maxm];\nvoid init()\n{\n    for (int i = 1; i <= n; ++i)\n    {\n        int tot = 1;\n        while (p[i] > 0)\n        {\n            cost[++cnt] = tot * t[i];\n            val[cnt] = tot * c[i];\n            p[i] -= tot;\n            tot *= 2;\n            if (p[i] < tot)\n            {\n                cost[++cnt] = t[i] * p[i];\n                val[cnt] = c[i] * p[i];\n                break;\n            }\n        }\n    }\n}\n\nsigned main()\n{\n    scanf(\"%d:%d%d:%d%d\", &h1, &m1, &h2, &m2, &n);\n    int maxt = (h2 * 60 + m2) - (60 * h1 + m1);\n    for (int i = 1; i <= n; ++i)\n    {\n        scanf(\"%d%d%d\", &t[i], &c[i], &p[i]);\n        if (p[i] == 0)\n            p[i] = inf;\n    }\n    init();\n    for (int i = 1; i <= cnt; ++i)\n    {\n        for (int j = maxt; j >= cost[i]; --j)\n            dp[j] = max(dp[j], dp[j - cost[i]] + val[i]);\n    }\n    printf(\"%d\\n\", dp[maxt]);\n    return 0;\n}\n```\n\n注意数据范围，`inf` 不能设的太大，否则会RE。\n\n## P1064 [NOIP2006 提高组] 金明的预算方案\n\n[题目链接](https://www.luogu.com.cn/problem/P1064)\n\n有依赖的背包问题。这道题中每个主件最多只有两个附件，所以只要枚举以下几种情况：\n\n1. 一个都不选\n2. 只选主件\n3. 选主件和附件1\n4. 选主件和附件2\n5. 全选\n\n代码如下：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint n, m;\nint mw[maxn], mv[maxn], fw[maxn][3], fv[maxn][3], dp[maxn];\nsigned main()\n{\n    cin >> n >> m;\n    for (int i = 1; i <= m; ++i)\n    {\n        int v, p, q;\n        cin >> v >> p >> q;\n        if (q == 0)\n        {\n            mw[i] = v;\n            mv[i] = v * p;\n        }\n        else\n        {\n            fw[q][0]++;\n            fw[q][fw[q][0]] = v;\n            fv[q][fw[q][0]] = v * p;\n        }\n    }\n    for (int i = 1; i <= m; ++i)\n    {\n        for (int j = n; j >= mw[i]; --j)\n        {\n            dp[j] = max(dp[j], dp[j - mw[i]] + mv[i]);\n            if (j >= mw[i] + fw[i][1])\n                dp[j] = max(dp[j], dp[j - mw[i] - fw[i][1]] + mv[i] + fv[i][1]);\n            if (j >= mw[i] + fw[i][2])\n                dp[j] = max(dp[j], dp[j - mw[i] - fw[i][2]] + mv[i] + fv[i][2]);\n            if (j >= mw[i] + fw[i][1] + fw[i][2])\n                dp[j] = max(dp[j], dp[j - mw[i] - fw[i][1] - fw[i][2]] + mv[i] + fv[i][1] + fv[i][2]);\n        }\n    }\n    cout << dp[n] << endl;\n    return 0;\n}\n\n```\n\n看题解的时候还发现了一种更强的做法：\n\n将依赖关系建成一棵树，根结点为0，主件的父亲全部设置为根结点，这样还可以处理附件有附件的情形。\n\n然后跑树形DP会很复杂，所以求出DFS序转变为线性DP，然后可以像01背包一样转移状态。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 100;\nconst int maxv = 4e4;\nconst ll mod = 998244353;\n\nstruct element\n{\n    int v, w;\n    element() {}\n    element(int a, int b) : v(a), w(b) {}\n};\n\nstruct edge\n{\n    int from, to;\n    edge() {}\n    edge(int a, int b) : from(a), to(b) {}\n};\n\nelement d[maxn], t[maxn];\nedge e[maxn];\nint head[maxn], nxt[maxn], root[maxn], tot;\nvoid add(int u, int v)\n{\n    e[++tot] = edge(u, v);\n    nxt[tot] = head[u];\n    head[u] = tot;\n}\n\nint pre[maxn], dp[maxn][maxv], p;\nvoid dfs(int fa)\n{\n    int tmp = p;\n    for (int i = head[fa]; i; i = nxt[i])\n    {\n        dfs(e[i].to);\n    }\n    d[++p] = t[fa];\n    pre[p] = tmp;\n}\nint n, m;\nsigned main()\n{\n    scanf(\"%d%d\", &m, &n);\n    for (int i = 1; i <= n; i++)\n    {\n        int v, w, fa;\n        scanf(\"%d%d%d\", &v, &w, &fa);\n        t[i] = element(v, v * w);\n        add(fa, i);\n    }\n    dfs(0);\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j <= m; j++)\n        {\n            if (j >= d[i].v)\n                dp[i][j] = max(dp[pre[i]][j], dp[i - 1][j - d[i].v] + d[i].w);\n            else\n                dp[i][j] = dp[pre[i]][j];\n        }\n    }\n    printf(\"%d\\n\", dp[n][m]);\n    return 0;\n}\n\n```\n\n\n\n- 85176627\n\n![85176627](https://i.loli.net/2021/01/17/RDzvLWIke3wf85E.jpg)","tags":["专题笔记"]},{"title":"【专题笔记#3】浅谈AC自动机上DP","url":"/2020/12/17/Note_003/","content":"\n\n\n先占个位置，哪天有空了再写。\n\n\n\n<!--more-->\n\n## P3193 [HNOI2008]GT考试\n\n[链接](https://www.luogu.com.cn/problem/P3193)\n\n## P3715 [BJOI2017]魔法咒语\n\n[链接](https://www.luogu.com.cn/problem/P3715)\n\n## CSP认证202009-5密信与计数\n\n[链接](http://118.190.20.162/view.page?gpid=T109)","tags":["专题笔记"]},{"title":"Java高精度","url":"/2020/12/12/Java-BigInt/","content":"\n\n\nJava的高精度是真他妈难用。\n\n\n\n<!--more-->\n\n例题：\n\nCCPC2016长春J题，给一个 $10^{1000}$ 以内的数，让你拆分成不超过 $50$ 个回文数之和。\n\n做法不难，每次尽量找前一半形成的回文，这样可以每次让位数减少一半左右。\n\n那么我们就来看一看Java的优秀语法：\n\n```Java\nimport java.util.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class Main {\n\n    public static BigInteger n;\n    public static String[] ans = new String[60];\n\n    public static void work(int t) {\n        int len = n.toString().length();\n        if (len == 1) {\n            ans[t] = n.toString();\n            n = n.subtract(n);\n            return;\n        }\n        String str;\n        if (len % 2 == 0) {\n            BigInteger tmp = new BigInteger(n.toString().substring(0, len / 2));\n            str = tmp.toString();\n            int l = str.length();\n            for (int i = l - 1; i >= 0; --i) {\n                str += str.charAt(i);\n            }\n            if (n.compareTo(new BigInteger(str)) >= 0) {\n                n = n.subtract(new BigInteger(str));\n                ans[t] = str;\n            } else {\n                tmp = new BigInteger(n.toString().substring(0, len / 2));\n                tmp = tmp.subtract(BigInteger.ONE);\n                if (tmp.equals(BigInteger.ZERO)) {\n                    n = n.subtract(new BigInteger(\"9\"));\n                    ans[t] = \"9\";\n                    return;\n                }\n                str = tmp.toString();\n                l = str.length();\n                for (int i = l - 1; i >= 0; --i) {\n                    str += str.charAt(i);\n                }\n                n = n.subtract(new BigInteger(str));\n                ans[t] = str;\n            }\n        } else {\n            BigInteger tmp = new BigInteger(n.toString().substring(0, len / 2 + 1));\n            str = tmp.toString();\n            int l = str.length();\n            for (int i = l - 2; i >= 0; --i) {\n                str += str.charAt(i);\n            }\n            if (n.compareTo(new BigInteger(str)) >= 0) {\n                n = n.subtract(new BigInteger(str));\n                ans[t] = str;\n            } else {\n                tmp = new BigInteger(n.toString().substring(0, len / 2 + 1));\n                tmp = tmp.subtract(BigInteger.ONE);\n                if (tmp.equals(BigInteger.ZERO)) {\n                    n = n.subtract(new BigInteger(\"9\"));\n                    ans[t] = \"9\";\n                    return;\n                }\n                str = tmp.toString();\n                l = str.length();\n                for (int i = l - 2; i >= 0; --i) {\n                    str += str.charAt(i);\n                }\n                n = n.subtract(new BigInteger(str));\n                ans[t] = str;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner cin = new Scanner(System.in);\n        int T = cin.nextInt();\n        for (int x = 1; x <= T; ++x) {\n            int cnt = 0;\n            n = cin.nextBigInteger();\n            while (n.equals(BigInteger.ZERO) == false) {\n                cnt++;\n                work(cnt);\n            }\n            System.out.println(\"Case #\" + x + \":\");\n            System.out.println(cnt);\n            for (int i = 1; i <= cnt; ++i) {\n                System.out.println(ans[i]);\n            }\n        }\n    }\n}\n```\n\nJava的大整数类没有重载运算符，也不能用 `Math.max` 比较大小，很多操作都需要转化成 `String` 来完成，而 `String` 转换成 `BigInteger` 的时候要特别注意格式问题。\n\n以后还是学一下Python好了。Java是真的垃圾。越写越暴躁。\n\n- 85781980\n\n![85781980.jpg](https://i.loli.net/2020/12/13/wO7Un38JQEcoiCL.jpg)\n\n","tags":["Java"]},{"title":"CF#688div2总结","url":"/2020/12/05/CF688div2/","content":"\n\n多加练习。\n\n\n<!--more-->\n\n## A\n\n注意到可能出现冲突的线路必然是在横纵坐标相等的点处产生冲突，因此只需要统计这样的点的数量，就是需要取消的线路的数量。\n\n这次的A题质量还是比较高的。\n\n## B\n\n根据题意，当我们修改到第 $i$ 个元素的时候，需要让 $[i,n]$ 的所有元素都变得和第 $i$ 个一样。所以先统计相邻元素的差的绝对值之和，这是不删除元素所需要的总操作数。然后枚举每个元素被删除的情况，找到最小操作数即可。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconst int maxn = 2e5 + 9;\nconst ll mod = 998244353;\n#define int ll\nint a[maxn];\nsigned main()\n{\n    int T;\n    cin >> T;\n    while (T--)\n    {\n        int n;\n        cin >> n;\n        ll sum = 0;\n        for (int i = 1; i <= n; ++i)\n        {\n            cin >> a[i];\n            if (i > 1)\n                sum += abs(a[i] - a[i - 1]);\n        }\n        ll ans = sum - abs(a[2] - a[1]);\n        ans = min(ans, sum - abs(a[n] - a[n - 1]));\n        for (int i = 2; i < n; ++i)\n        {\n            ans = min(ans, sum + abs(a[i - 1] - a[i + 1]) - abs(a[i] - a[i - 1]) - abs(a[i + 1] - a[i]));\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n```\n\n感觉比A还好做。\n\n## C\n\n题面很长读了两遍才读懂。明示了 $O(n^2)$ 做法，固定两个顶点再自己选取一个最优的，然后更新答案。\n\n但是不能在所有值相同的顶点里选两个，那样是 $O(n^4)$ 的，所以会在第五个点T掉。优化非常简单，显然对于同一行的点来说，最优的选法是选距离最远的，这样复杂度就对了。时限很松跑起来毫无压力。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nstruct pii\n{\n    int first, second;\n    pii(){};\n    pii(int a, int b) : first(a), second(b) {}\n};\n\nint ans[12];\nint a[2050][2050], b[2050][2], b2[2050][2];\nint vis[10];\nsigned main()\n{\n    int T;\n    scanf(\"%d\", &T);\n    while (T--)\n    {\n        int n;\n        scanf(\"%d\", &n);\n        vector<pii> v[10];\n        for (int i = 1; i <= n; ++i)\n        {\n            memset(vis, 0, sizeof(vis));\n            for (int j = 1; j <= n; ++j)\n            {\n                scanf(\"%1d\", &a[i][j]);\n                if (vis[a[i][j]] < 2)\n                {\n                    v[a[i][j]].emplace_back(pii(i, j));\n                    vis[a[i][j]]++;\n                }\n                else\n                {\n                    int pos = v[a[i][j]].size() - 1;\n                    v[a[i][j]][pos].second = j;\n                }\n            }\n        }\n        memset(ans, 0, sizeof(ans));\n        for (int i = 0; i < 10; ++i)\n        {\n            if (v[i].size() < 2)\n            {\n                ans[i] = 0;\n                continue;\n            }\n            for (int s = 0; s < v[i].size(); ++s)\n            {\n                for (int t = s + 1; t < v[i].size(); ++t)\n                {\n                    if (v[i][s].first == v[i][t].first)\n                    {\n                        ans[i] = max(ans[i], abs(v[i][s].second - v[i][t].second) * max(v[i][s].first - 1, n - v[i][s].first));\n                    }\n                    else if (v[i][s].second == v[i][t].second)\n                    {\n                        ans[i] = max(ans[i], abs(v[i][s].first - v[i][t].first) * max(v[i][s].second - 1, n - v[i][s].second));\n                    }\n                    else\n                    {\n                        ans[i] = max(ans[i], abs(v[i][s].second - v[i][t].second) * max(v[i][s].first - 1, n - v[i][s].first));\n                        ans[i] = max(ans[i], abs(v[i][s].second - v[i][t].second) * max(v[i][t].first - 1, n - v[i][t].first));\n                        ans[i] = max(ans[i], abs(v[i][s].first - v[i][t].first) * max(v[i][s].second - 1, n - v[i][s].second));\n                        ans[i] = max(ans[i], abs(v[i][s].first - v[i][t].first) * max(v[i][t].second - 1, n - v[i][t].second));\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < 10; ++i)\n        {\n            printf(\"%d \", ans[i]);\n            v[i].clear();\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}c\n```\n\n## D\n\n题面同样读了两遍才明白意思。\n\n先考虑最简单的情况，如果所有的 $n$ 个点都是存档点，显然打通的次数的期望是 $2n$。\n\n如果没有存档点的关卡打输了，会回到最近存档点，也就是说这一系列的关卡会被若干个存档点分成若干个连续段，最终的答案是每个连续段的期望的和。\n\n那么就需要计算连续的没存档点的关卡的期望次数。$E_i = \\dfrac{E_{i-1}+1}{2}+\\dfrac{E_{i-1}+1+E_i}{2}$，即 $E_i=2E_{i-1}+2$。易知 $E_1=2$，故 $E_i=2^{i+1}-2$。\n\n所以对于偶数这样构造一下，对于奇数直接输出。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nsigned main()\n{\n    int T;\n    cin >> T;\n    while (T--)\n    {\n        ull k;\n        cin >> k;\n        if (k & 1)\n        {\n            cout << -1 << endl;\n            continue;\n        }\n        string ans = \"\";\n        int len = 0;\n        for (ull i = 61; i > 0; --i)\n        {\n            while (k >= ((2ULL << i) - 2))\n            {\n                ans += \"1 \";\n                for (ull j = 1; j < i; ++j)\n                    ans += \"0 \";\n                len += i;\n                k -= ((2ULL << i) - 2);\n            }\n        }\n        cout << len << endl;\n        cout << ans << endl;\n    }\n    return 0;\n}\n```\n\n又是差点就过了。要是过了就上1700了，遗憾。\n\n## E\n\n当时感觉是二分+树形DP，但是没写出来。有空再补。\n\n## F\n\n应该也是DP，有空再补。\n\n- 85672701\n\n![85672701](https://i.loli.net/2020/12/05/cRgCvLpwz3le7if.jpg)","tags":["CodeForces"]},{"title":"【专题笔记#2】库函数与STL","url":"/2020/11/07/Note_002/","content":"\n\n\n写几个容易错的地方，希望以后不要再错在这种东西上面了。\n\n\n\n<!--more-->\n\n## `memset`\n\n众所周知，`memset` 的复杂度是 $O(n)$ 的，之前上新生课的时候我还提到过，结果回头打cf的时候就忘了，喜提TLE。\n\n以及 `memset` 的第二个参数一般取以下四种：\n\n1. `memset(dp, 0, sizeof(dp))`，初始化为 $0$\n2. `memset(dp, -1, sizeof(dp))`，初始化为 $-1$\n3. `memset(dp, 0x3f, sizeof(dp))`（$63$），初始化为 $1061109567$（`0x3f3f3f3f`）\n4. `memset(dp, ~0x3f, sizeof(dp))`（$-64$），初始化为 $-1061109568$（`~0x3f3f3f3f`）\n\n## `multiset`\n\n虽然和 `set` 很像，但是用的时候还是要稍微动动脑子的：\n\n`set` 是普通的集合，`erase` 一个元素和对应的迭代器效果是一样的；\n\n`multiset` 是可重集，`erase` 一个元素会删除所有与其相等的，而删除对应的迭代器只会删掉一个。\n\n这就是[P1286 两数之和](https://www.luogu.com.cn/problem/P1286)改了8次才对的原因之一。\n\n## pb_ds\n\n仅作了解就可以了。里面红黑树和可并堆应该是挺厉害的，但是 `trie` 和 `splay` 就很菜。\n\n用起来也很麻烦。以后有空再去看吧。\n\n其实一定要用平衡树和可并堆的情况并不多，很多时候只是没想到正解然后直接上平衡树（比如今年的CSP-J T2）。\n\n## 其它\n\n以后想到了再更新\n\n- 85487595\n\n![85487595](https://i.loli.net/2020/11/08/sWNnfaLgwD2MC5U.jpg)\n\n","tags":["专题笔记"]},{"title":"CF#681div2总结","url":"/2020/11/03/CF681div2/","content":"\n\n\n最近状态起伏太大了，好的时候1900分水平，差的时候1400分水平。\n\n\n\n<!--more-->\n\n## A \n\n[Kids Seating](https://codeforces.com/contest/1443/problem/A)\n\n在 $[1,4n]$ 中找 $n$ 个不互质且两两没有倍数关系的数。\n\n显然 $2n+2,2n+4,\\cdots,4n$ 满足题意。\n\n## B\n\n[Saving the City](https://codeforces.com/contest/1443/problem/B)\n\n给一个01串，连续的1可以通过一次费用为 $a$ 的操作变成0，0可以通过一次费用为 $b$ 的操作变成1，问把所有字符变成0的最小费用。\n\n检查所有连续段1之间的间隔，如果不超过 $\\lfloor\\dfrac{a}{b}\\rfloor$ 说明可以把间隔变成1一起处理，否则不变。\n\n## C\n\n[The Delivery Dilemma](https://codeforces.com/contest/1443/problem/C)\n\n每种货物有 $a_i$，$b_i$ 两种时间，可以选择其中之一送货，消耗的总时间是选择 $a$ 方式运输的货物中的最大值和选择 $b$ 方式运输的总时间两者取大。问总时间的最小可能值。\n\n显然可以二分答案。当然也可以排序以后求后缀和。\n\n## D \n\n[Extreme Subtraction](https://codeforces.com/contest/1443/problem/D)\n\n给一个序列，问能否通过若干次操作使全部元素变成0，操作共两种：\n\n1. 将左边 $k$ 个元素-1\n2. 将右边 $k$ 个元素-1\n\n找规律，模拟。\n\n## E\n\n[Long Permutation](https://codeforces.com/contest/1443/problem/E)\n\n给一个长度为 $n$ 的排列，$m$ 次操作，初始情况下序列是升序的，操作有两种：\n\n1. 询问序列中 $[l,r]$ 的和\n2. 将序列变为下 $k$ 个排列\n\n输出每次询问的答案，$1\\le n,m\\le 2\\times 10^5$，$k\\le 1\\times 10^5$。\n\n显然不会有数据结构支持这样阴间的操作，比赛的时候也毫无思路。\n\n300iq的博客中是这样说的：最多需要我们把序列变成 $2\\times 10^{10}$ 之后的排列，然而即便如此也只有最后的15位会产生变化。因此每次修改只要变最后15位就可以了，询问也只需要暴力统计后面15位。\n\n```c++\n#include <bits/stdc++.h>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n//#include <ext/pb_ds/priority_queue.hpp>\n//#include <ext/pb_ds/hash_policy.hpp>\nusing namespace std;\n//using namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n//typedef gp_hash_table<int, int> hashmap;\n//typedef tree<pii, null_type, std::less<pii>, splay_tree_tag, tree_order_statistics_node_update> splaytree;\n//typedef tree<pii, null_type, std::less<pii>, rb_tree_tag, tree_order_statistics_node_update> rbtree;\n//typedef __gnu_pbds::priority_queue<int, std::greater<int>, __gnu_pbds::binary_heap_tag> binheap;\n//typedef __gnu_pbds::priority_queue<int, std::greater<int>, __gnu_pbds::pairing_heap_tag> pairingheap;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\ntemplate <typename T, typename... Args>\ninline void read(T &t, Args &... args)\n{\n    read(t);\n    read(args...);\n}\n\n//mt19937 rnd(time(0));\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 2e5 + 9;\nconst ll mod = 998244353;\nll frac[20];\nll s[maxn];\nbool vis[maxn];\nsigned main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"data.txt\",\"w\",stdout);\n    //std::ios::sync_with_stdio(false);\n    //std::cin.tie(0);\n    //std::cout.tie(0);\n    int n, q;\n    read(n, q);\n    frac[0] = 1;\n    for (ll i = 1; i <= 16; ++i)\n        frac[i] = frac[i - 1] * i;\n    int st = max(1, n - 15);\n    ll cnt = 1;\n    for (ll i = 1; i <= n; ++i)\n    {\n        s[i] = s[i - 1] + i;\n    }\n    int op, l, r, x;\n    while (q--)\n    {\n        read(op);\n        if (op == 1)\n        {\n            read(l, r);\n            printf(\"%lld\\n\", s[r] - s[l - 1]);\n        }\n        else\n        {\n            read(x);\n            cnt += x;\n            ll now = cnt;\n            for (int i = st; i <= n; ++i)\n                vis[i] = false;\n            for (int i = st; i < n; ++i)\n            {\n                ll tmp = 0;\n                for (int j = st; j <= n; ++j)\n                {\n                    if (!vis[j])\n                    {\n                        tmp += frac[n - i];\n                        if (tmp >= now)\n                        {\n                            now -= tmp - frac[n - i];\n                            s[i] = s[i - 1] + j;\n                            vis[j] = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            for (int i = st; i <= n; ++i)\n                if (!vis[i])\n                    s[n] = s[n - 1] + i;\n        }\n    }\n    //fclose(stdin);\n    //fclose(stdout);\n    return 0;\n}\n```\n\n## F\n\n[Identify the Operations](https://codeforces.com/contest/1443/problem/F)\n\n对于一次操作，假设要加入数组 $b$ 的数是 $a_i$，那么需要删除 $a_{i-1}$ 或 $a_{i + 1}$，分类讨论以下三种情况：\n\n1. $a_{i-1}$ 和 $a_{i + 1}$ 都存在于 $b$ 数组的 $a_i$ 之后，那么一个都不能删去，是无解的情况，最终的答案就是 $0$\n2. $a_{i-1}$ 和 $a_{i + 1}$ 有一个存在于 $b$ 数组的 $a_i$ 之后，那么只能删去另一个，并且今后 $a_i$ 也可以被删除\n3. $a_{i-1}$ 和 $a_{i + 1}$ 都不存在于 $b$ 数组的 $a_i$ 之后，那么有两种删除方式，并且今后 $a_i$ 也可以被删除\n\n如果删除的是 $a_{i-1}$，说明 $a_{i-1}$ 是可删除的，而 $a_i$ 在此之后也变得可删除了，对于两端的影响和删除自身是一样的。如果删除 $a_{i+1}$ 也是一样的道理。\n\n也就是说，对于可以删除的情况，只要更新一下答案，然后把自己删除就行了。这个过程可以用链表来模拟。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\ntemplate <typename T, typename... Args>\ninline void read(T &t, Args &... args)\n{\n    read(t);\n    read(args...);\n}\n\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 2e5 + 9;\nconst ll mod = 998244353;\nint a[maxn], b[maxn], mp[maxn];\nstruct node\n{\n    int val, l, r;\n};\nnode s[maxn];\nvoid del(int pos)\n{\n    mp[s[pos].val] = 0;\n    s[s[pos].r].l = s[pos].l;\n    s[s[pos].l].r = s[pos].r;\n}\nsigned main()\n{\n    int T;\n    read(T);\n    while (T--)\n    {\n        int n, k;\n        read(n, k);\n        memset(mp, 0, sizeof(int) * (n + 2));\n        memset(s, 0, sizeof(node) * (n + 2));\n        a[n + 1] = n + 1;\n        s[0].r = 1, s[n + 1].l = n;\n        mp[0] = mp[n + 1] = n + 1;\n        for (int i = 1; i <= n; ++i)\n        {\n            read(s[i].val);\n            a[s[i].val] = i;\n            s[i].l = i - 1;\n            s[i].r = i + 1;\n        }\n        for (int i = 1; i <= k; ++i)\n        {\n            read(b[i]);\n            mp[b[i]] = i;\n        }\n        ll ans = 1;\n        bool flag = true;\n        for (int i = 1; i <= k; ++i)\n        {\n            int now = b[i], pos = a[now];\n            if (mp[s[s[pos].l].val] && mp[s[s[pos].r].val])\n            {\n                flag = false;\n                break;\n            }\n            else if (mp[s[s[pos].l].val] || mp[s[s[pos].r].val])\n                del(pos);        \n            else\n            {\n                del(pos);\n                ans = ans * 2 % mod;\n            }\n        }\n        if (!flag)\n            printf(\"0\\n\");\n        else\n            printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}\n```\n\n当时代码死活过不去是因为链表头尾没初始化，然后又无脑memset整个数组，所以T了，其实只需要 `memset(mp, 0, sizeof(int) * (n + 2));` 就行了。\n\n- 84819292\n\n![84819292](https://i.loli.net/2020/11/03/HwPnKvCbMxza6je.jpg)","tags":["CodeForces"]},{"title":"2020计蒜之道线上决赛题解","url":"/2020/10/24/jisuanke2020/","content":"\n\n\nRank172，T恤到手。\n\n\n\n<!--more-->\n\n[链接](https://www.jisuanke.com/contest/11347)\n\n## A\n\n签到题，不说了\n\n## B\n\n简单的模拟，也不说了\n\n## C\n\n给一个长度 $n$ 的序列，$m$ 次查询，每次问在区间 $[l,r]$ 内是否存在出现次数严格大于 $\\dfrac{r-l+1}{t}$ 的数字，若存在输出最大的满足要求的数，若不存在输出 $-1$。\n\n赛后有人说这是CF840D的弱化版，但是之前我也没做过这题。正解是主席树上二分，单次查询复杂度 $O(t\\log n)$，比较复杂。比赛的时候看到没有修改操作支持离线就试了试用莫队乱搞一下，用一个 `map` 维护区间中每个数字的出现次数，复杂度大概比 $O(n\\sqrt n \\log n)$ 小一些，反正勉强能过。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\ntemplate <typename T, typename... Args>\ninline void read(T &t, Args &... args)\n{\n    read(t);\n    read(args...);\n}\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 1e5 + 9;\nconst ll mod = 998244353;\nint B;\nstruct qry\n{\n    int l, r, id, t;\n    bool operator<(const qry &b) const\n    {\n        return l / B == b.l / B ? r < b.r : l < b.l;\n    }\n};\nqry q[maxn];\nunordered_map<int, int> mp;\nmap<int, int> mp2;\nint cnt[maxn];\nint tot, maxcnt, maxans, minans;\nint a[maxn], b[maxn], newa[maxn], res[maxn], init[maxn];\ninline void add(int x)\n{\n    mp2[x]++;\n}\ninline void del(int x)\n{\n    mp2[x]--;\n}\nsigned main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"data.txt\",\"w\",stdout);\n    //std::ios::sync_with_stdio(false);\n    //std::cin.tie(0);\n    //std::cout.tie(0);\n    int n, Q, ans;\n    read(n, Q);\n    B = n / sqrt(Q);\n    for (int i = 1; i <= n; ++i)\n    {\n        read(a[i]);\n        b[i] = a[i];\n    }\n    sort(b + 1, b + n + 1);\n    for (int i = 1; i <= n; ++i)\n    {\n        if (!mp[b[i]])\n            mp[b[i]] = ++tot, init[tot] = b[i];\n    }\n    for (int i = 1; i <= n; ++i)\n    {\n        newa[i] = mp[a[i]];\n        //cout << i << ' ' << newa[i] << endl;\n    }\n    for (int i = 1; i <= Q; ++i)\n    {\n        read(q[i].l, q[i].r, q[i].t);\n        q[i].id = i;\n    }\n    sort(q + 1, q + Q + 1);\n    int l = 1, r = 0;\n    for (int i = 1; i <= Q; ++i)\n    {\n        minans = (q[i].r - q[i].l + 1) / q[i].t;\n        maxans = -1;\n        if (q[i].r <= q[i].l || q[i].t == 1)\n        {\n            res[q[i].id] = -1;\n            continue;\n        }\n        while (l < q[i].l)\n        {\n            del(newa[l++]);\n        }\n        while (r > q[i].r)\n        {\n            del(newa[r--]);\n        }\n        while (l > q[i].l)\n        {\n            add(newa[--l]);\n        }\n        while (r < q[i].r)\n        {\n            add(newa[++r]);\n        }\n        for (auto i : mp2)\n            if (i.second > minans)\n                maxans = max(maxans, init[i.first]);\n        res[q[i].id] = maxans;\n        //cout << i << endl;\n    }\n    for (int i = 1; i <= Q; ++i)\n        printf(\"%d\\n\", res[i]);\n    //fclose(stdin);\n    //fclose(stdout);\n    return 0;\n}\n```\n\n这个没优化的代码交上去跑了956ms，评测机非常给力。\n\n## D\n\nNTT和一些奇怪的技巧，不会。\n\n## E\n\n单调栈优化DP，复杂度 $O(n^2 \\log n)$。以后可以看一下。\n\n## F\n\n推了一个神奇的式子 $ans=\\sum_{i=1}^n\\sum_{i=1}^n\\sum_{i=1}^n\\cdots\\sum_{i=1}^n1$，一共 $m$ 重求和，这个东西等于 $\\large C_{m+n-1}^m$，直接线性求一下逆元然后 $O(m)$ 求出答案。\n\n```c++\nll inv[maxn];\nvoid getinv(int n)\n{\n    inv[1] = 1;\n    for (int i = 2; i <= n; ++i)\n        inv[i] = (mod - mod / i) * inv[mod % i] % mod;\n}\nsigned main()\n{\n    ll n, m, p;\n    cin >> n >> m;\n    getinv(m);\n    ll ans = 1;\n    for (int i = 1; i <= m; ++i)\n        ans = ans * (ll)(n + m - i) % mod * inv[i] % mod;\n    cout << ans << endl;\n    return 0;\n}\n```\n\n这个等式究竟是什么原理我还不太清楚。\n\n## G\n\n对区间中所有元素的集合的每个子集，$f(S)$ 表示其异或和，求 $f(S)\\cdot x^{|S|}$ 的和。\n\n正解是按位拆分后用前缀和做，以后有空想一下。\n\n- 84699476\n\n![84699476](https://i.loli.net/2020/10/24/eEiADMY5CQubIjK.jpg)","tags":["比赛"]},{"title":"洛谷10月月赛II","url":"/2020/10/23/LGR-078/","content":"\n前段时间放松了一下比较颓废，五天前的比赛现在回来补题。\n\n<!--more-->\n\n## A\n\n[P6857 梦中梦与不再有梦](https://www.luogu.com.cn/problem/P6857)\n\n一笔画问题，根据奇点个数的结论可以 $O(1)$ 算出答案。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nsigned main()\n{\n    int T;\n    scanf(\"%d\\n\", &T);\n    while (T--)\n    {\n        ll n;\n        scanf(\"%lld\", &n);\n        if (n < 2)\n            printf(\"0\\n\");\n        else if (n & 1)\n            printf(\"%lld\\n\", n * (n - 1) / 2);\n        else\n            printf(\"%lld\\n\", n * (n - 1) / 2 - (n - 2) / 2);\n    }\n    return 0;\n}\n```\n\n签到题，不多说了。\n\n## B\n\n[P6858 深海少女与胖头鱼](https://www.luogu.com.cn/problem/P6858)\n\n设 $n$ 个有圣盾，$m$ 个没圣盾的情况下答案是 $f(n,m)$，先考虑两种特殊情况：\n\n1. $m=0$，显然有 $f(n,0)=1+f(n-1,1)$\n2. $m=1$，显然有 $f(n,1)=\\dfrac{n}{n+1}f(n,1)+\\dfrac{1}{n+1}f(n-1,0)+1$\n\n第二个式子变形一下可以得到 $f(n,1)=f(n,0)+n+1$，所以 $f(n,0)=f(n-1,0)+n+1$，很容易算出 $f(n,0)=\\sum_{i=1}^n{i+1}=\\dfrac{n^2+3n}{2}$。当时我用了一种非常麻烦的推导方法才得出这种特殊情况的解，但是现在已经回忆不起来了。\n\n既然 $f(n,0)$ 可以直接写出通项公式，那么可以代入算出 $f(n,1)=\\dfrac{n^2+5n+2}{2}$。接下来就需要考虑一般情况了。\n\n一般情况的递推式也很容易写出，$m\\gt 1$ 时 $f(n,m)=\\dfrac{n}{n+m}f(n+m-1,1)+\\dfrac{m}{n+m}f(n,m-1)$。注意到这个递推的复杂度是 $O(m)$ 的，所以已经可以写代码了。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 998244353;\nll fstpow(ll n, ll k)\n{\n    ll ret = 1;\n    while (k)\n    {\n        if (k & 1)\n            ret = ret * n % mod;\n        k /= 2;\n        n = n * n % mod;\n    }\n    return ret;\n}\nll calc(ll x)\n{\n    x %= mod;\n    return ((x * x + 5 * x + 2) / 2) % mod;\n}\nll mod_reverse(ll x)\n{\n    return fstpow(x, mod - 2) % mod;\n}\nll f(ll n, ll m)\n{\n    if (m == 0)\n        return (f(n - 1, 1) + 1) % mod;\n    else if (m == 1)\n        return calc(n);\n    else\n        return (n * mod_reverse(m + n) % mod * calc(n + m - 1) % mod + \n                m * mod_reverse(m + n) % mod * f(n, m - 1) % mod + \n                1) % mod;\n}\nsigned main()\n{\n    ll n, m;\n    scanf(\"%lld%lld\", &n, &m);\n    printf(\"%lld\\n\", f(n % mod, m));\n    return 0;\n}\n```\n\n当时推的脑子很乱，数据范围也没看清，就只拿了特殊情况的分。\n\n## C\n\n[P6859 蝴蝶与花](https://www.luogu.com.cn/problem/P6859)\n\n长度为 $n$ 的序列，所有元素不是 $1$ 就是 $2$，$m$ 次操作：\n\n1. 询问是否有一个区间的和是 $s$，若有输出符合条件的左数第一个区间，没有就输出 `none`；\n2. 单点修改元素的值为 $1$ 或 $2$ 中的一个。\n\n数据范围 $1\\le n,m\\le 2\\times 10^6$。\n\n显然是数据结构题，当时大概是这样想的：\n\n- 前缀和+二分，那么查询操作复杂度 $O(n\\log n)$，修改操作 $O(n)$，显然是不行的。\n- 树状数组+二分，那么查询操作复杂度 $O(n\\log^2 n)$，修改操作 $O(\\log n)$，依然非常差。\n\n所以肯定是要结合所有元素都是 $1$ 或 $2$ 这一条件来做的，但是当时并没有什么想法。\n\n由于所有元素都是 $1$ 或 $2$，如果我们要查询的数是 $x$，二分查出最小位置，$\\sum_{i=1}^{pos}a_i$ 只能是 $x$ 或 $x+1$，那么只需要考虑和是 $x+1$ 的情况：此时 $a_{pos}$ 必然为 $2$，如果 $a_1=1$，区间就是 $[2,pos]$；如果 $a_1=2$，需要找到左端点右边最近的 $1$ 和右端点右边最近的 $1$，选最近的那个并去掉 $1$，就是答案。无解的情况是位置超过了 $n$。\n\n所以可以用一个树状数组维护区间和，用一个 `set` 维护 $1$ 的位置，复杂度 $O(n \\log^2 n)$，开O2能过。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\ntemplate <typename T, typename... Args>\ninline void read(T &t, Args &... args)\n{\n    read(t);\n    read(args...);\n}\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 2e6 + 9;\nconst ll mod = 998244353;\nint n, m;\nint a[maxn], bit[maxn];\ninline int lowbit(int x)\n{\n    return x & (-x);\n}\nvoid add(int x, int k)\n{\n    for (int i = x; i <= n; i += lowbit(i))\n        bit[i] += k;\n}\nint ask(int x)\n{\n    int ret = 0;\n    for (int i = x; i; i -= lowbit(i))\n        ret += bit[i];\n    return ret;\n}\nint query(int l, int r)\n{\n    return ask(r) - ask(l - 1);\n}\nset<int> s;\nsigned main()\n{\n    read(n, m);\n    for (int i = 1; i <= n; ++i)\n    {\n        read(a[i]);\n        add(i, a[i]);\n        if (a[i] == 1)\n            s.insert(i);\n    }\n    char op;\n    int pos, x;\n    while (m--)\n    {\n        op = getchar();\n        while (op != 'A' && op != 'C')\n            op = getchar();\n        if (op == 'A')\n        {\n            read(x);\n            if (x < 1 || x > query(1, n))\n            {\n                puts(\"none\");\n                continue;\n            }\n            int l = 1, r = n, mid, ans;\n            while (l <= r)\n            {\n                mid = (l + r) / 2;\n                if (query(1, mid) >= x)\n                    ans = mid, r = mid - 1;\n                else\n                    l = mid + 1;\n            }\n            int y = query(1, ans);\n            if (y == x)\n                printf(\"1 %d\\n\", ans);\n            else if (a[1] == 1)\n                printf(\"2 %d\\n\", ans);\n            else\n            {\n                int posl = inf, posr = inf;\n                if (!s.empty())\n                    posl = *s.begin();\n                auto it = s.lower_bound(ans);\n                if (it != s.end())\n                    posr = *it;\n                if (posl + ans - 1 > n && posr > n)\n                    puts(\"none\");\n                else if (posl >= posr - ans + 1)\n                    printf(\"%d %d\\n\", posr - ans + 1, posr);\n                else\n                    printf(\"%d %d\\n\", posl + 1, posl + ans - 1);\n            }\n        }\n        else\n        {\n            read(pos, x);\n            if (a[pos] == 1 && x == 2)\n                s.erase(pos);\n            if (a[pos] == 2 && x == 1)\n                s.insert(pos);\n            if (x != a[pos])\n            {\n                add(pos, x - a[pos]);\n                a[pos] = x;\n            }\n        }\n    }\n    return 0;\n}\n```\n\n这个代码居然比一些线段树上二分的还慢，说明一些地方有很大的改进空间。\n\n## D\n\n[P6860 象棋与马](https://www.luogu.com.cn/problem/P6860)\n\n杜教筛/莫比乌斯反演，不会，以后学了再看。\n\n- 85168224\n\n![85168224.jpg](https://i.loli.net/2020/10/23/9LHMhEUloVmSaAb.jpg)","tags":["洛谷"]},{"title":"【专题笔记#1】KMP","url":"/2020/10/13/Note_001/","content":"\n\n\n遇到有关字符串周期的问题可以考虑一下KMP算法。\n\n\n\n<!--more-->\n\n## 求最小周期\n\n[P4391 [BOI2009]Radio Transmission 无线传输](https://www.luogu.com.cn/problem/P4391)\n\n给一个长度为 $n$ 的串 $s$，$s$ 可以由串 $t$ 不断复制形成，求 $t$ 的最短长度。\n\n复制的最后一段可以不是完整的，比如 `cabcabca` 的最短周期就是 `cab`。\n\n第一眼看上去没什么规律，先把next数组求出来看看。然后可以发现答案就是 $n - \\text{next}[n]$。\n\n对于 $i$ 位置的字符，$\\text{next}[i]$ 表示上一个周期对应的该字符的位置。那么，两个下标相减得到的就是周期的长度了。\n\n## 求前缀的最大周期和\n\n[P3435 [POI2006]OKR-Periods of Words](https://www.luogu.com.cn/problem/P3435)\n\n给一个长度为 $n$ 的串 $s$，求 $s$ 的所有前缀的最大周期长度之和。\n\n如果某个前缀不是循环的，它的最大周期就是 $0$ 而非它的长度。\n\n和上一题差不多，但是这里求的是最大周期，就需要跳到next数组最远的地方去，也就是这样：\n\n```c++\nwhile (n[j]) j = n[j];\n```\n\n那么问题就来了：这样会被卡成 $O(n^2)$。所以需要用类似于路径压缩的思想优化一下：\n\n```c++\nif (n[i]) n[i] = j;\n```\n\n这样就是 $O(n)$ 的了。\n\n\n\n- 84065035\n\n![84065035](https://i.loli.net/2020/10/13/vkhZDpgUmEG7bTQ.jpg)","tags":["专题笔记"]},{"title":"后缀自动机","url":"/2020/10/07/Suffix-Automaton/","content":"\n\n\n\n“阅读全文大约需要60分钟”\n\n<!--more-->\n\n## 简介\n\n**后缀自动机** (suffix automaton, SAM) 是一个能解决许多字符串相关问题的有力的数据结构。\n\n举个例子，以下的字符串问题都可以在线性时间内通过 SAM 解决。\n\n- 在另一个字符串中搜索一个字符串的所有出现位置。\n- 计算给定的字符串中有多少个不同的子串。\n\n直观上，字符串的 SAM 可以理解为给定字符串的 **所有子串** 的压缩形式。值得注意的是，SAM 将所有的这些信息以高度压缩的形式储存。对于一个长度为 $n$ 的字符串，它的空间复杂度仅为 $O(n)$。此外，构造 SAM 的时间复杂度仅为 $O(n)$。准确的说，一个 SAM 最多有 $2n-1$ 个节点和 $3n-4$ 条转移边。\n\n——摘自[OI Wiki](https://oi-wiki.org/string/sam/)\n\nSAM是一个接受字符串的所有后缀的最小**确定性有限状态自动机**。\n\n简单的说，对于某个有限状态自动机A，若它能识别某个字符串 $s$，那么 `A(s) == true`，否则 `A(s) == false`。\n\n自动机由五个部分组成：\n\n1. 字符集 `Alpha`\n2. 状态集合 `state`\n3. 初始状态 `st`\n4. 结束状态 `end`\n5. 状态转移函数 `trans()`\n\n若当前状态是 `s`，读入某个字符 `ch` 后的状态就是 `trans(s, ch)`。\n\n那么自动机能识别的字符串就是所有满足 $\\text{trans}(st,x)\\in \\text{end}$ 的字符串 $x$。\n\n对于字符串 $s$ 的后缀自动机SAM，`SAM(x) == true` 当且仅当 $x$ 是 $s$ 的后缀。\n\n——摘自WJMZBMR的PPT\n\n## 原理\n\n### 暴力建Trie\n\n如果我们要识别某个字符串的所有后缀，最简单的办法是把所有后缀全部插到一个Trie里面。很明显，这样的插入操作是 $O(n^2)$ 的。这个Trie上的所有路径都是原串的子串，而不在这个Trie上的路径都不是原串的子串（一一对应）。\n\n但是在建完Trie以后可以发现，Trie上的很多路径都是重复的，这也是这样做复杂度很高的原因，而后缀自动机就解决了这个问题。\n\n### 后缀自动机\n\n对于一个子串，它可能会出现在原串的若干个不同的位置，我们将某个字串出现在的所有位置的右端点标记为该子串的 `endpos`。\n\n**三个引理：**\n\n1. 如果两个子串的 `endpos` 相同，那么短的子串一定是长的子串的后缀。正确性非常显然。\n2. 对于任意两个子串 $s$、$t$ 满足 $|s|\\le|t|$，$\\text{endpos}(t)\\in\\text{endpos}(s)$ 或 $\\text{endpos}(t)\\cap\\text{endpos}(s)=\\varnothing$。这是第一条的逆命题，也不难证明。\n3. 对于 `endpos` 相同的子串，我们视为一个 `endpos` 等价类，把一个 `endpos` 等价类中的所有子串按长度降序排序，则相邻子串长度相差 $1$ 且后面的子串都是前面的子串的后缀。正确性也很显然。\n\n根据上面三个比较简单的引理，可以得到这样的推论：`endpos` 等价类的个数的级别是 $O(n)$ 的。\n\n这是因为对于两个子串 $a$、$b$，它们的 `endpos` 集合要么不相交，要么一个是另一个的真子集。仔细想想这一点也是比较显然的。\n\n对于一个类，其中有最长的一个子串 $p$，在 $p$ 的前面添加一个字符得到的合法新子串必然不属于当前的类，因此可以通过这个方式将一个类分割成若干个不相交的子类。显然总的分割次数不会超过全集中的元素个数，所以最终形成的集合个数也不会超过 $2n$。\n\n那么类之间有了父子关系，可以搞出一个parent tree。那么对于树上存在父子关系的两个类，父亲的最长子串的长度恰好比儿子的最短子串的长度少一个字符。根据上面的推导，这个结论同样是显然的。这也就意味着只需要保存一个结点的最长子串长度，最短长度可以由父亲的长度推出来。\n\n后缀自动机上的结点和parent tree上的结点是一样的，但是边有所不同。后缀自动机的源点是parent tree的根结点的，而中止结点是原串对应的叶子结点以及它所有的祖先。\n\n连边的部分改日再写。贴个[博客链接](https://www.luogu.com.cn/blog/Kesdiael3/hou-zhui-zi-dong-ji-yang-xie)。\n\n这个[博客](https://www.cnblogs.com/maomao9173/p/10447821.html)的图可以看看。\n\n## 构造\n\n[P3804 【模板】后缀自动机 (SAM)](https://www.luogu.com.cn/problem/P3804)\n\n```c++\nconst int maxn = 2e6 + 9;\nint tot = 1, las = 1;\nstruct node\n{\n    int ch[26];\n    int len, fa;\n    node()\n    {\n        memset(ch, 0, sizeof(ch));\n        len = fa = 0;\n    }\n} trie[maxn];\nstruct Edge\n{\n    int t, nexty;\n} edge[maxn];\nint head[maxn], cnt = 0;\nvoid add(int a, int b)\n{\n    cnt++;\n    edge[cnt].t = b;\n    edge[cnt].nexty = head[a];\n    head[a] = cnt;\n}\nll val[maxn];\nvoid ins(int c)\n{\n    int p = las, np = las = ++tot;\n    val[tot] = 1;\n    trie[np].len = trie[p].len + 1;\n    for (; p && !trie[p].ch[c]; p = trie[p].fa)\n        trie[p].ch[c] = np;\n    if (!p)\n        trie[np].fa = 1;\n    else\n    {\n        int q = trie[p].ch[c];\n        if (trie[q].len == trie[p].len + 1)\n            trie[np].fa = q;\n        else\n        {\n            int nq = ++tot;\n            trie[nq] = trie[q];\n            trie[nq].len = trie[p].len + 1;\n            trie[q].fa = trie[np].fa = nq;\n            for (; p && trie[p].ch[c] == q; p = trie[p].fa)\n                trie[p].ch[c] = nq;\n        }\n    }\n}\nchar s[maxn];\nint len;\nll ans = 0;\nvoid dfs(int n)\n{\n    for (int i = head[n]; i; i = edge[i].nexty)\n    {\n        dfs(edge[i].t);\n        val[n] += val[edge[i].t];\n    }\n    if (val[n] != 1)\n        ans = max(ans, val[n] * trie[n].len);\n}\nint main()\n{\n    scanf(\"%s\", s);\n    len = strlen(s);\n    for (int i = 0; i < len; i++)\n        ins(s[i] - 'a');\n    for (int i = 2; i <= tot; i++)\n        add(trie[i].fa, i);\n    dfs(1);\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n```\n\n- 84060785\n\n![84060785](https://i.loli.net/2020/10/07/LdHEGJ45oRz6xTy.jpg)","tags":["字符串"]},{"title":"子序列自动机","url":"/2020/10/04/Subsequence-Automaton/","content":"\n对于子串匹配的问题我们可以用KMP算法高效求解，但如果是子序列匹配问题就需要换一种全新的思路。\n\n\n<!--more-->\n\n## 思考\n\n### 暴力\n\n表示出所有子序列再进行判断，预处理和查询都是 $O(n^2)$ 的。\n\n### 优化\n\n显然，每个字符在选择向后连接的下一个字符的时候，选最前面的一个一定是最优的。\n\n这样下来预处理似乎还是 $O(n^2)$ 的，但查询变成了线性的。这个复杂度还是不够看，但是已经很接近正解了。\n\n### 正解\n\n和上面类似，对于每种字符，记录它出现的位置，在匹配的时候查找出上一个位置之后的第一个位置。这样做的好处是预处理无需建图，将预处理过程优化到了线性，而查询的时候使用二分查找，复杂度也下降为 $O(n\\log n)$。\n\n查询也可以使用可持久化权值线段树来实现。\n\n## 实现\n\n[P5826 【模板】子序列自动机](https://www.luogu.com.cn/problem/P5826)核心代码：\n\n```c++\n    for (int i = 1; i <= n; ++i)\n    {\n        read(x);\n        v[x].emplace_back(i);\n    }\n    while (q--)\n    {\n        read(x);\n        int pos = 0, tmp;\n        bool flag = true;\n        for (int i = 1; i <= x; ++i)\n        {\n            read(tmp);\n            if (!flag)\n                continue;\n            auto it = upper_bound(v[tmp].begin(), v[tmp].end(), pos);\n            if (it == v[tmp].end())\n                flag = false;\n            else\n                pos = *it;\n        }\n        puts(flag ? \"Yes\" : \"No\");\n    }\n```\n\n## 后记\n\n这个东西的原理很简单，所以也很好理解。其实和自动机没什么关系，叫这个名字可能是适用范围和一些自动机很相似。\n\n如果不用 `vector` 而使用别的容器（平衡树之类），可能可以做到支持修改。\n\n- 84761998\n\n![84761998](https://i.loli.net/2020/10/04/al9uUv2Exi4Dsgt.jpg)","tags":["字符串"]},{"title":"后缀数组","url":"/2020/10/02/Suffix_Array/","content":"\n\n\n后缀数组（Suffix Array）是一个通过对字符串的所有后缀经过排序后得到的数组，是后缀树的一个替代品。\n\n\n\n<!--more-->\n\n## 定义与性质\n\n对于长度为 $n$ 的字符串 $s$（下标从 $1$ 开始），我们定义 $\\text{suf}(k)=s[k,\\cdots,n]$，而后缀数组中的 `sa[k]` 记录了排名为 $k$ 的后缀为 $\\text{suf}(sa[k])$。同时，定义名次数组rank表示后缀的排名，即 $\\text{suf}(k)$ 在所有后缀中的排名是 `rank[k]`。\n\n显然后缀数组和名次数组是互逆的，即 $rank[sa[i]]=sa[rank[i]]=i$。\n\n\n\n## 计算后缀数组\n\n### 暴力排序\n\n`sort` 全部后缀，快排复杂度 $O(n\\log n)$，字符串大小比较 $O(n)$，总复杂度 $O(n^2 \\log n)$，非常慢。\n\n### 二分+哈希\n\n先 $O(n)$ 哈希一遍，然后比较大小时二分查找lcp（最长公共前缀），将比较的复杂度降低为 $O(n\\log n)$，总复杂度 $O(n \\log^2 n)$，也比较慢。\n\n### 倍增\n\n首先，对于每个位置，求出所有子串 $\\text{sub}(i,2^0)$ 即第 $i$ 个字符的排名；\n\n然后依次求出所有 $\\text{sub}(i,2^1)$，$\\text{sub}(i,2^2)$，$\\cdots$，$\\text{sub}(i,2^k)$ 子串的排名，其中 $2^{k-1}\\lt n \\le 2^k$，如果子串的一部分超出了原串，则全部视为最小的字符（`\\0`）。\n\n显然，倍增的次数是 $\\log n$，排序只需要比较两部分，如果用快排总复杂度 $O(n \\log^2 n)$，基数排序可以将其优化到 $O(n \\log n)$。\n\n具体来说，我们已经知道 $rank[i\\cdots n][k]$，要求出 $rank[1\\cdots n][k+1]$，那么先比较 $rank[i][k]$ 和 $rank[j][k]$ 的大小，如果一样就比较 $rank[i+2^k][k]$ 和 $rank[j+2^k][k]$ 的大小，相当于对 `pair<rank[i][k],rank[i+(1<<k)][k]>` 排序，其中rank数组的值域是不超过 $n$ 的正整数，所以用基数排序先按第二关键字排一遍，再按第一关键字排一遍即可。\n\n### DC3\n\n$O(n)$，常数大，难写。\n\n在2009年国家集训队罗穗骞的论文里看到的，把所有后缀分成三部分进行排序，很神奇的样子。\n\n### SA-IS\n\n$O(n)$ 且常数较小。\n\n好像没什么用，贴个[博客链接](https://www.luogu.com.cn/blog/ShadowassIIXVIIIIV/on-hou-zhui-shuo-zu-sa-is-suan-fa)。\n\n## 应用\n\n### LCP\n\n定义 $\\text{lcp}(i,j)$ 为 $\\text{suf}(sa[i])$ 和 $\\text{suf}(sa[j])$ 的最长公共前缀。\n\n显然有：\n\n1. $\\text{lcp}(i,j)=\\text{lcp}(j,i)$\n2. $\\text{lcp}(i,i)=\\text{len}(sa[i])=n-sa[i]+1$\n\n那么可以证明LCP Lemma：\n\n$$\\text{lcp}(i,j)=\\min(\\text{lcp}(i,k),\\text{lcp}(k,j))$$\n\n然后可以推出LCP Theorem：\n\n$$\\text{lcp}(i,j)=\\min(\\text{lcp}(k,k-1))\\;,\\;1\\lt i \\le j\\le k\\le n$$\n\n接下来就是求LCP的过程。\n\n### Height\n\n记 $\\text{height}(i)=\\text{lcp}(\\text{suf}(sa[i]),\\text{suf}(sa[i-1]))$，也就是两个后缀的最长公共前缀长度，$height[1]=0$。\n\n根据上面的公式，可以得到：\n\n $$\\text{lcp}(i,j)=\\min(\\text{height}[k])\\;,\\;i\\lt k \\le j$$\n\n也就是说，两个后缀的LCP等于它们排名区间中height的最小值。那么我们就要求出height：\n\n设 `h[i] = height[rk[i]]`，那么 `height[i] = h[sa[i]]`。\n\n可以证明，$h[i] \\ge h[i-1]-1$。[这篇博客](https://www.luogu.com.cn/blog/blackfrog/sa-algorithm)中的图比较直观。\n\n那么可以 $O(n)$ 求出height数组。\n\nSA的基础部分先写到这里，以后还是要通过做题加深理解。\n\n- 84697235\n\n![84697235](https://i.loli.net/2020/10/02/QX3UWv14M9z75aJ.jpg)\n","tags":["字符串"]},{"title":"Manacher算法","url":"/2020/10/01/Manacher/","content":"\n\n暴力枚举对称中心寻找最长回文子串的复杂度是 $O(n^2)$，Manacher算法可以将复杂度优化为 $O(n)$。\n\n\n\n<!--more-->\n\n先看朴素算法的流程：$O(n)$ 枚举每个元素作为对称中心，然后对于每个对称中心进行 $O(n)$ 的判断，总复杂度 $O(n^2)$。\n\n有一些优化：\n\n1. 用字符串哈希可以在 $O(n\\log n)$ 时间解决问题；\n2. 用后缀数组和LCA可以在 $O(n)$ 时间解决，但是常数很大。\n\n下面看Glenn K. Manacher在1975年提出的巧妙算法。\n\n首先我们简化一下问题：回文串的长度可能是奇数或偶数，对应的对称中心可能是某个字符或者位于两个字符之间。我们可以通过预处理原串，在原串两个字符之间插入字符集中不存在的字符，使得产生的新串只存在奇数长度的回文串。比如对于串 `lipomoea`，可以构造出形如 `@#l#i#p#o#m#o#e#a#$` 的新串。\n\n```c++\nchar str[maxn], str_new[maxn << 1];\nint p[maxn << 1], len, ans;\nint init()\n{\n    int pos = 1;\n    scanf(\"%s\", str);\n    len = strlen(str);\n    str_new[0] = '@';\n    str_new[1] = '#';\n    for (int i = 0; i < len; ++i)\n    {\n        str_new[++pos] = str[i];\n        str_new[++pos] = '#';\n    }\n    str_new[++pos] = '$';\n    return pos;\n}\n```\n\n然后我们需要维护一个右边界 $r$，表示已找到的最靠右的子回文串的右边界。初始情况下 $r = -1$。\n\n在枚举到某个位置 $i$ 时，如果 $i$ 不位于维护的右边界内（$i\\gt r$），那么使用朴素算法计算以该位置为对称中心形成的最长回文串长度并更新右边界 $r$。如果 $i\\le r$，那么我们先找到之前保存的最靠右的回文串的对称中心 $mid$，$i$ 关于 $mid$ 的对称点就是 $2mid-i$，根据回文串的对称性，可以得到以两个对称点为中心形成的回文半径是相等的，即 $p[i]=p[2mid-i]$。需要注意的是，该结论的正确性建立在这两个回文串在我们维护的最右回文串之内，因此如果这两个串的边界超出了，就需要在正确的范围内进行截断，然后再暴力验证剩下部分是否回文。\n\n```c++\nvoid manacher()\n{\n    int mid, r = -1;\n    for (int i = 1; i < len * 2 + 2; ++i)\n    {\n        if (i <= r)\n            p[i] = p[2 * mid - i] < (r - i) ? p[2 * mid - i] : r - i;\n        else\n            p[i] = 1;\n        for (; str_new[i - p[i]] == str_new[i + p[i]]; p[i]++)\n            ;\n        if (i + p[i] > r)\n            mid = i, r = i + p[i];\n        ans = max(ans, p[i]);\n    }\n}\n```\n\n虽然Manacher算法在很多情况下都会用到朴素算法的流程，但它的时间复杂度依然是 $O(n)$，因为我们维护的右边界 $r$ 是不会左移的，实际上暴力验证的流程并不会执行很多次。\n\n- 84758431\n\n![84758431.jpg](https://i.loli.net/2020/12/10/yBUpl1i3DhwJMYx.jpg)\n\n","tags":["字符串"]},{"title":"2020年9月年度总结","url":"/2020/09/30/2020-9/","content":"\n总结与展望。\n\n<!--more-->\n\n看了一下洛谷的个人主页，帐号注册于2019年9月24日，距离现在已经一年多了。10月做了一些最简单的模拟，11月开始接触最简单的排序、二分之类的算法，也逐渐开始写C++的代码。这样算起来，程序设计竞赛也学了快一年了。\n\n去年年底的时候，基本上什么都不会，校赛好像才过了三个题，勉强进基地。年初看了些分治、搜索和背包DP之类的简单算法，然后学了最基础的数据结构和图论的东西，还稍微接触了一点数论，这个时候已经可以做黄题了。开始打cf，基本上只能过div.2AB，rating连1400都不到。\n\n![ozc02k63.png](https://i.loli.net/2020/02/24/RSGKYXz6nTai9mQ.png)\n\n然后因为疫情，宅家上网课，毫无效率，三个多月也没学多少东西，cf也不打了。\n\n但是五月初打了一场校赛，用树状数组过了两题，因为一些大佬没参加，打了全校第四。树状数组真是个好东西，可惜后来几乎就没再用过，现在就像锈在鞘里的剑，已经不能使用自如了。\n\n后来终于返校了，在学校很明显更适合学习。暑假留校打了不少cf，本来计划暑假上蓝，结果就差一点点，还是在9月第一场上了蓝。暑假主要还是学了一些数据结构和图论，但是看起来各方面都是有不少进步的，或许是原来比较菜的原因吧。\n\n![Tifa1.jpg](https://i.loli.net/2020/05/05/bvXKsyZd83aQnhi.jpg)\n\n再后来就是组队，感觉队友都比我厉害。校内训练赛排名还行，还是比较有希望打区域赛的，但是很可惜省赛我们只拿了铜，正常发挥的话银应该是可以的。\n\n队内我主要负责字符串和搜索，所以接下来两个月要把重心放在这两块上。\n\n接下来还有CCSP、计蒜客决赛和天梯赛，希望能打好。\n\n去年这个时候的我大概也想不到一年之后是这样的吧。\n\n![002.jpg](https://i.loli.net/2020/05/05/4jzEUbRx67wOGtu.jpg)\n\n这一年里，各种地方做了差不多四五百题。寒假的时候搭了这个博客，为了完成任务基本上每道题都写了题解，批量生产的质量都不怎么高，后来更新主题的时候全部都撤下了。暑假的时候主要写的是知识点，题解写的很少。但是写题解还是比较有必要的，今后试着按专题写题解，大约一周更新一篇，总结某个知识点的常见套路。\n\n![003.jpg](https://i.loli.net/2020/05/05/6G97InpmXgPzuKr.jpg)","tags":["随笔"]},{"title":"AC自动机","url":"/2020/09/30/AC-Automaton/","content":"\n\n\nAC自动机是由Alfred V. Aho和Margaret J. Corasick于1975年发明的字符串匹配算法，可以实现线性复杂度的多模式匹配。\n\n\n\n<!--more-->\n\n## 原理\n\n先来回顾一下KMP算法：使用next数组保存到某个前缀为止的最长border。\n\nAC自动机是多模式匹配，如果每个模式串都跑一次KMP，时间复杂度还是很高。AC自动机算法首先把所有模式串建成一个Trie，然后在Trie上构造失配（fail）指针。\n\n对于这个Trie，我们知道从根结点到每一个结点的路径都是某个模式串的前缀，这个前缀被称为**状态**。从一个状态添加一个字符得到新的状态的过程称为**转移**。如果某个字符串能对应上某个状态，这个字符串就是**可识别**的。\n\n不同于KMP算法的next数组，AC自动机的fail指针指向**当前状态的最长可识别后缀**，也就是说，fail指针沿着其父节点的fail指针一直向上找，直到找到某个拥有与当前结点字符内容相同的子结点的父结点的那个子结点为止。\n\n这段话虽然听起来很奇怪，但是仔细想想还是比较好理解的。\n\n和border一样，fail也有传递性。\n\n## 构造\n\n首先把所有模式串放进Trie里，然后对Trie进行BFS，类似于KMP中构造next数组的方法，构造出fail指针。为了避免不停跳fail指针，这里可以修改Trie的结构，达到类似于路径压缩的效果。\n\n具体内容以后再来完善。\n\n## 实现\n\n代码来自OI Wiki\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 6;\nint n;\nnamespace AC {\nint tr[N][26], tot;\nint e[N], fail[N];\nvoid insert(char *s) {\n  int u = 0;\n  for (int i = 1; s[i]; i++) {\n    if (!tr[u][s[i] - 'a']) tr[u][s[i] - 'a'] = ++tot;\n    u = tr[u][s[i] - 'a'];\n  }\n  e[u]++;\n}\nqueue<int> q;\nvoid build() {\n  for (int i = 0; i < 26; i++)\n    if (tr[0][i]) q.push(tr[0][i]);\n  while (q.size()) {\n    int u = q.front();\n    q.pop();\n    for (int i = 0; i < 26; i++) {\n      if (tr[u][i])\n        fail[tr[u][i]] = tr[fail[u]][i], q.push(tr[u][i]);\n      else\n        tr[u][i] = tr[fail[u]][i];\n    }\n  }\n}\nint query(char *t) {\n  int u = 0, res = 0;\n  for (int i = 1; t[i]; i++) {\n    u = tr[u][t[i] - 'a'];  // 转移\n    for (int j = u; j && e[j] != -1; j = fail[j]) {\n      res += e[j], e[j] = -1;\n    }\n  }\n  return res;\n}\n}  // namespace AC\nchar s[N];\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%s\", s + 1), AC::insert(s);\n  scanf(\"%s\", s + 1);\n  AC::build();\n  printf(\"%d\", AC::query(s));\n  return 0;\n}\n```\n\n- 82887113\n\n![82887113](https://i.loli.net/2020/10/08/9DYdNHBf6IT8AOb.jpg)","tags":["字符串"]},{"title":"珂朵莉树","url":"/2020/09/23/Chtholly_Tree/","content":"\n\n\n珂朵莉树起源于[CF896C Willem, Chtholly and Seniorious](https://codeforces.com/problemset/problem/896/C)，是一种基于平衡树的神奇数据结构。\n\n<!--more-->\n\n## 背景\n\n这个数据结构以前被称为 `Old Driver Tree`（老驱动树），但是我很怀疑这个 `Driver` 的本意是否真的是“驱动”的意思。可能比较严谨的名字是“基于数据随机的颜色段均摊”，但是这个名字实在是太拗口了，还不如像AVL树一样根据起源来命名。\n\n珂朵莉树一般用平衡树实现，复杂度为 $O(n\\log \\log n)$，也可以用链表等结构降低复杂度，但是并没有这样做的必要，所以这里只研究基于平衡树的珂朵莉树。复杂度分析在[这篇专栏](https://zhuanlan.zhihu.com/p/102786071)。\n\n## 原理与用途\n\n珂朵莉树可以维护一个序列的信息，但是不同于有很多虚点的线段树，珂朵莉树的每个结点表示一个区间并用一棵平衡树维护，任意两个结点表示的区间均不相交且所有区间的并集就是总的序列。因此可以根据序列的左端点排序。珂朵莉树的操作只需要最基本的平衡树功能，因此使用 `std::set` 来实现非常方便。\n\n同时，我们还需要利用C++中的关键字 `mutable`，因为迭代器遍历 `set` 中的元素时需要对其进行修改。\n\n那么可以定义出这样的结点结构：\n\n```c++\nstruct node\n{\n    int l, r;\n    mutable ll val;\n    node() {}\n    node(int l, int r = -1, ll v = 0) : l(l), r(r), val(v) {}\n    bool operator<(const node &b) const\n    {\n        return l < b.l;\n    }\n};\n```\n\n如果要修改一个区间，首先需要分裂出所需的区间：\n\n```c++\nset<node> s;\ntypedef set<node>::iterator sit;\nsit split(int pos)\n{\n    sit it = s.lower_bound(node(pos));\n    if (it != s.end() && it->l == pos)\n        return it;\n    it--;\n    int L = it->l, R = it->r;\n    ll v = it->val;\n    s.erase(it);\n    s.insert(node(L, pos - 1, v));\n    return s.insert(node(pos, R, v)).first;\n}\n```\n\n这样会返回所求区间最左端结点的迭代器。\n\n区间赋值就非常简单：\n\n```c++\nvoid assign(int l, int r, ll v = 0)\n{\n    sit itl = split(l), itr = split(r + 1);\n    s.erase(itl, itr);\n    s.insert(node(l, r, v));\n}\n```\n\n分裂后删除表示原来区间的所有结点，然后插入赋值后的整段区间即可。\n\n区间加也类似：\n\n```c++\nvoid add(int l, int r, ll v = 1)\n{\n    sit itl = split(l), itr = split(r + 1);\n    for (; itl != itr; ++itl)\n        itl->val += v;\n}\n```\n\n很容易看出珂朵莉树的操作非常暴力，因此只在**数据随机或操作次数不多**的时候表现优秀。如果有**区间赋值**的需求可以尝试使用珂朵莉树。与线段树、树状数组等数据结构相比，珂朵莉树的优势在于：\n\n- 非常好写\n- 快速区间赋值\n- 可以实现求区间第k大、区间幂次和等一般数据结构难以实现的操作\n\n求区间第k大还可以用划分树、主席树之类的东西做，求区间幂次和之类的神奇操作绝大部分数据结构都是做不到的。\n\n## 例题\n\n### [P3740 [HAOI2014]贴海报](https://www.luogu.com.cn/problem/P3740)\n\n长度为 $n$ 的序列，$m$ 次操作，每次给区间 $[l_i,r_i]$ 涂一个颜色，问最后能看到多少颜色。\n\n有专门做这种问题的浮水法，也可以用离散化+线段树做，当然最简单无脑的做法是用珂朵莉树，抄个模板就搞定了。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 1e5 + 9;\nstruct node\n{\n    int left, right;\n    mutable int val;\n    node() {}\n    node(int l, int r = -1, int v = 0) : left(l), right(r), val(v) {}\n    bool operator<(const node &b) const\n    {\n        return left < b.left;\n    }\n};\ntypedef set<node>::iterator sit;\nset<node> s;\nsit split(int pos)\n{\n    sit it = s.lower_bound(node(pos));\n    if (it != s.end() && it->left == pos)\n        return it;\n    --it;\n    int l = it->left, r = it->right, v = it->val;\n    s.erase(it);\n    s.insert(node(l, pos - 1, v));\n    return s.insert(node(pos, r, v)).first;\n}\nvoid assign(int l, int r, int v = 0)\n{\n    sit itl = split(l), itr = split(r + 1);\n    s.erase(itl, itr);\n    s.insert(node(l, r, v));\n}\nbool vis[1500];\nsigned main()\n{\n    std::ios::sync_with_stdio(false);\n    int n, m;\n    cin >> n >> m;\n    s.insert(node(1, 10000009, 0));\n    for (int i = 1, x, y; i <= m; ++i)\n    {\n        cin >> x >> y;\n        assign(x, y, i);\n    }\n    for (sit i = s.begin(); i != s.end(); ++i)\n    {\n        vis[i->val] = true;\n    }\n    int ans = 0;\n    for (int i = 1; i <= m; ++i)\n        if (vis[i])\n            ans++;\n    cout << ans << endl;\n    return 0;\n}\n```\n\n### CF896C Willem, Chtholly and Seniorious\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst int INF = 0x3f3f3f3f;\nconst int maxn = 1e5 + 9;\nconst int MOD7 = 1e9 + 7;\nll fstpow(ll a, ll b, ll mod)\n{\n    ll res = 1;\n    ll ans = a % mod;\n    while (b)\n    {\n        if (b & 1)\n            res = res * ans % mod;\n        ans = ans * ans % mod;\n        b /= 2;\n    }\n    return res;\n}\nstruct Node\n{\n    int l, r;\n    mutable ll v;\n    Node(int L, int R = -1, ll V = 0) : l(L), r(R), v(V) {}\n    bool operator<(const Node &o) const\n    {\n        return l < o.l;\n    }\n};\nset<Node> s;\ntypedef set<Node>::iterator sit;\nsit split(int pos)\n{\n    sit it = s.lower_bound(Node(pos));\n    if (it != s.end() && it->l == pos)\n        return it;\n    --it;\n    int L = it->l, R = it->r;\n    ll V = it->v;\n    s.erase(it);\n    s.insert(Node(L, pos - 1, V));\n    return s.insert(Node(pos, R, V)).first;\n}\nvoid add(int l, int r, ll val = 1)\n{\n    sit itl = split(l), itr = split(r + 1);\n    for (; itl != itr; ++itl)\n        itl->v += val;\n}\nvoid assign_val(int l, int r, ll val = 0)\n{\n    sit itl = split(l), itr = split(r + 1);\n    s.erase(itl, itr);\n    s.insert(Node(l, r, val));\n}\nvector<pair<ll, int>> vp;\nll kth(int l, int r, int k)\n{\n    sit itl = split(l), itr = split(r + 1);\n    vp.clear();\n    for (; itl != itr; ++itl)\n        vp.push_back(pair<ll, int>(itl->v, itl->r - itl->l + 1));\n    sort(vp.begin(), vp.end());\n    for (auto it = vp.begin(); it != vp.end(); ++it)\n    {\n        k -= it->second;\n        if (k <= 0)\n            return it->first;\n    }\n    return -1LL;\n}\n\nll sum(int l, int r, int ex, int mod)\n{\n    sit itl = split(l), itr = split(r + 1);\n    ll res = 0;\n    for (; itl != itr; ++itl)\n        res = (res + (ll)(itl->r - itl->l + 1) * fstpow(itl->v, ll(ex), ll(mod))) % mod;\n    return res;\n}\nint n, m;\nll seed, vmax;\nll rnd()\n{\n    ll ret = seed;\n    seed = (seed * 7 + 13) % MOD7;\n    return ret;\n}\nint main()\n{\n    scanf(\"%d %d %lld %lld\", &n, &m, &seed, &vmax);\n    for (int i = 1; i <= n; ++i)\n        s.insert(Node(i, i, (rnd() % vmax) + 1));\n    s.insert(Node(n + 1, n + 1, 0));\n    for (int i = 1; i <= m; ++i)\n    {\n        int op = int(rnd() % 4) + 1;\n        int l = int(rnd() % n) + 1;\n        int r = int(rnd() % n) + 1;\n        if (l > r)\n            swap(l, r);\n        int x, y;\n        if (op == 3)\n            x = int(rnd() % (r - l + 1)) + 1;\n        else\n            x = int(rnd() % vmax) + 1;\n        if (op == 4)\n            y = int(rnd() % vmax) + 1;\n        if (op == 1)\n            add(l, r, ll(x));\n        else if (op == 2)\n            assign_val(l, r, ll(x));\n        else if (op == 3)\n            printf(\"%lld\\n\", kth(l, r, x));\n        else\n            printf(\"%lld\\n\", sum(l, r, x, y));\n    }\n    return 0;\n}\n```\n\n\n\n写珂朵莉树的文章怎么能少了珂朵莉呢\n\n![Chtholly](https://i.loli.net/2020/09/23/LIlKAG1PwYsdipg.jpg)\n\n\n","tags":["数据结构"]},{"title":"博弈论","url":"/2020/09/21/Game_Theory/","content":"\n\n\n之前遇到博弈论的题总是死的很惨，所以有必要好好学一下。\n\n\n\n<!--more-->\n\n先开个坑，正文等以后有空了再写\n\n","tags":["算法"]},{"title":"2020CCPC网络选拔赛","url":"/2020/09/20/CCPC2020online/","content":"\n\n\n2020CCPC网络选拔赛等\n\n<!--more-->\n\n## 01\n\n第一眼看上去是扫描线，但是直接做复杂度是 $O(n^2\\log n)$ 的，显然会T。\n\n后来听说好像是吉如一线段树？以后去了解一下。\n\n## 02\n\n画图模拟了一下大概可以得到这样的结论：$\\large S_n=\\sum_{i=3}^{n+1}i + Sp_{[3,n+1]}$\n\n其中 $Sp$ 表示区间中的质数之和。\n\n前面的求和显然可以直接用等差数列公式 $O(1)$ 求出，但是后面的就很难办，$n$ 的范围达到了 $1\\times 10^{10}$，线性筛都用不了，只能用神奇的Min-25筛。\n\n用Min-25筛求出 $[1,n+1]$ 的质数和再去掉 $2$ 即可，时间复杂度似乎是 $\\large \\dfrac{n^{\\frac 3 4}}{\\log n}$，反正跑的很快。\n\n不得不说Min-25牛逼。\n\n这题其实分段打表说不定也能过。\n\n## 03\n\n水题\n\n## 04\n\n不会\n\n## 05\n\n博弈论，想了很久一直很混乱，最后也没做出来。\n\nSG函数以后还要去看看。\n\n## 06\n\n好像是挺复杂的题，但是数据很弱，可以乱搞过去？\n\n## 07\n\n签到题\n\n## 08\n\n不会\n\n## 09\n\n不会\n\n## 10\n\n签到题\n\n## 11\n\n看起来很恐怖，但是仔细想想只有两种情况。\n\n## 12\n\n不会\n\n## 13\n\n不知道怎么优化，以后可以看一下。\n\n## PTA天梯赛选拔\n\n昨晚的比赛顺便写一下。\n\n前面一堆模拟的水题，但是有两三个题拿不到全分，可能是边界数据之类的问题。\n\nT9-T11题也不难，但是T10没有好的思路，后来想想应该是树状数组之类的东西可以做做看？\n\nT12似乎不太严谨，极角排序能过，但是我不会。\n\nT13看起来像二分图匹配，没模板连匈牙利算法都写不太出来，更不用说Dinic最大流了。\n\n最后两题比较难，也没时间去做，就不管了。\n\n中间一度达到rank8，最后掉到rank20，有点可惜。\n\n- 84437728\n\n![84437728](https://i.loli.net/2020/09/20/D7Ec15rJY8TUnvy.jpg)","tags":["比赛"]},{"title":"配置Java环境等","url":"/2020/09/15/Java/","content":"\n\n\n配Java环境，简单配置IntelliJ IDEA，VS Code，eclipse。\n\n\n\n<!--more-->\n\n## 配置Java11环境\n\n先去[官网](https://www.oracle.com/java/technologies/javase-downloads.html)下载JDK，选Windows x64 Installer，不需要梯子就可以下载，如需要登录帐号就去网上找一个，然后正常安装即可。\n\n然后修改环境变量，可以参考[这个教程](https://www.runoob.com/w3cnote/windows10-java-setup.html)。\n\n配置完以后可以看 `java -version`，或者写一个hello world然后用 `javac XX`，`java XX` 试着编译一下。\n\n## 使用IntelliJ IDEA\n\nIDEA好像内置了JDK，直接新建Java项目无脑下一步就好了。\n\n## 安装配置eclipse\n\n和IDEA相比eclipse太菜了。再见。\n\n控制面板里找不到，根目录里面也没有卸载的地方，文档里也没说，真是垃圾。\n\n网上查了一下，直接把根目录删了好像就行了。\n\n## VS Code插件安装\n\n装 `Java Extension Pack`，会把必要的五六个插件都装上去，就可以用了。\n\n小东西用VS Code写，大的用IDEA，完美。\n\n- 84333405\n\n![84333405](https://i.loli.net/2020/09/15/jvaSFeQsEUnxT3W.jpg)","tags":["Java"]},{"title":"Educational Round 95总结","url":"/2020/09/14/CFedu95/","content":"\n突然unrated了，那就不打了早点睡觉，顺便在这里口胡一下做法。\n\n<!--more-->\n\n## A\n\nunr的罪魁祸首，题面有歧义。\n\n题目修好以后就是很简单的签到题，交换一次stick可以增加 $x-1$ 个stick，而总共需要 $y\\times k+k$ 个stick，除一下向上取整，再加上换coal用的 $k$ 次就是答案了。\n\n## B\n\n很显然的贪心，拿个大根堆模拟一下就好了。\n\n## C\n\n看起来是一个简单的线性DP。\n\n## D\n\n题面太长不看。看样例似乎是简单的数据结构题。后面的题以后有空再看了。\n\n- 84188262\n\n![84188262](https://i.loli.net/2020/09/14/27kewZt6KvQcRaB.jpg)\n\n","tags":["CodeForces"]},{"title":"AtCoder Beginner Contest 178","url":"/2020/09/13/ABC178/","content":"\n\n\n感觉题目变奇怪了，可能是我的思维越来越僵化了。。。\n\n\n\n<!--more-->\n\n## A\n\n送分题\n\n```c++\ncout << (a ? 0 : 1) << endl;\n```\n\n## B\n\n和上一次cf的B有点像\n\n```c++\n\tll a, b, c, d;\n    cin >> a >> b >> c >> d;\n    ll ans = max(a * c, a * d);\n    ans = max(ans, b * c);\n    ans = max(ans, b * d);\n    cout << ans << endl;\n```\n\n## C\n\n反向思维，得到 $N\\ge 2$ 的时候答案是 $10^N-2\\times9^N+8^N$，需要注意取模后算出的东西可能是负的，因为这个WA了一发\n\n```c++\n\tif (n <= 1)\n        cout << 0 << endl;\n    else\n    {\n        ll ans = ksm(10, n) - ksm(9, n) + ksm(8, n) - ksm(9, n);\n        ans %= mod;\n        ans = (ans + mod) % mod; // 不要忘了写这一行\n        cout << ans << endl;\n    }\n```\n\n## D\n\n将序列中所有元素均不小于 $3$，且所有元素和为 $n$ 的序列称为满足条件的序列，给出 $n$，求满足条件的序列个数，答案模 $10^9+7$。\n\n感觉应该是个DP，但是毫无思路。$n\\le2000$ 或许可以暴力？\n\n## E\n\n给出一些点求两点间最大曼哈顿距离。\n\n感觉应该是旋转卡壳求凸包直径，抄了个模板上去居然就过了。奇妙。\n\n计算几何还是需要重视一下。\n\n## F\n\n构造题，给两个长度相等的升序序列，问能不能改变第二个的顺序让两个序列的所有相同位置元素均不同。\n\n比赛的时候想了一下，只要两个里面最多相等元素的个数均不超过长度的一半就可以构造出来。\n\n但是没时间写了。不知道对不对。\n\n## 总结\n\n最近事情开始多起来了，不能再像暑假一样用大块时间学算法、练题了，所以更要规划好时间。\n\n之前觉得自己最大的问题在于代码能力，现在看来也不尽然。今天的CSP认证100+100+90+35+0=325，大模拟拿了90分，耗时也算正常，至少说明这方面的能力也不是那么差。\n\n但是不知道是不是cf换了个号从头打起的原因，心态上好像没有以前那么认真专注了，状态也是起伏很大。不过以前看最后两题往往没什么想法，最近倒是经常差一点做出来，可能在实力上确实是有了提升。\n\nABC和cf Div.3这样简单的比赛想要AK，现在看来并不需要学多少新东西，而是应该多练练各种题目，拓宽一下思维，见一见各种套路。\n\n等下周考完六级，要开始刷题了。有的中学生能做到半年千题，平均下来一天六七道，我就算比他们忙一些又比他们菜一些，一天两三道还是能做到的吧。\n\n- 84306688\n\n![84306688](https://i.loli.net/2020/09/13/MNghzcxWBGjwebQ.jpg)\n\n","tags":["AtCoder"]},{"title":"最小费用最大流","url":"/2020/09/08/MCMF/","content":"\n\n\n最小费用最大流模板。\n\n\n\n<!--more-->\n\n在最大流模型的基础上，给每条边增加了一个费用，于是需要求出费用最小的一条最大流。\n\n可以把求最大流的EK算法中的BFS改成最短路算法来找最小费用最大流。\n\n比较常见的费用流写法有三种：SPFA费用流，Dijkstra费用流以及zkw费用流。\n\n这里先放一个kuangbin的SPFA算法的模板，使用链式前向星存图。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\n\nconst int MAXN = 10000;\nconst int MAXM = 100000;\nconst int INF = 0x3f3f3f3f;\nstruct Edge\n{\n    int to, next, cap, flow, cost;\n} edge[MAXM];\nint head[MAXN], tol;\nint pre[MAXN], dis[MAXN];\nbool vis[MAXN];\nint N; //节点总个数，节点编号从0~N-1\nvoid init(int n)\n{\n    N = 2 * n + 2; // 原模板此处有误，现已改正\n    tol = 0;\n    memset(head, -1, sizeof(head));\n}\nvoid addedge(int u, int v, int cap, int cost)\n{\n    edge[tol].to = v;\n    edge[tol].cap = cap;\n    edge[tol].cost = cost;\n    edge[tol].flow = 0;\n    edge[tol].next = head[u];\n    head[u] = tol++;\n    edge[tol].to = u;\n    edge[tol].cap = 0;\n    edge[tol].cost = -cost;\n    edge[tol].flow = 0;\n    edge[tol].next = head[v];\n    head[v] = tol++;\n}\nbool spfa(int s, int t)\n{\n    queue<int> q;\n    for (int i = 0; i < N; i++)\n    {\n        dis[i] = INF;\n        vis[i] = false;\n        pre[i] = -1;\n    }\n    dis[s] = 0;\n    vis[s] = true;\n    q.push(s);\n    while (!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n        vis[u] = false;\n        for (int i = head[u]; i != -1; i = edge[i].next)\n        {\n            int v = edge[i].to;\n\n            if (edge[i].cap > edge[i].flow && dis[v] > dis[u] + edge[i].cost)\n            {\n                dis[v] = dis[u] + edge[i].cost;\n                pre[v] = i;\n                if (!vis[v])\n                {\n                    vis[v] = true;\n                    q.push(v);\n                }\n            }\n        }\n    }\n    if (pre[t] == -1)\n        return false;\n    else\n        return true;\n}\n//返回的是最大流，cost存的是最小费用\nint minCostMaxflow(int s, int t, int &cost)\n{\n    int flow = 0;\n    cost = 0;\n    while (spfa(s, t))\n    {\n        int Min = INF;\n        for (int i = pre[t]; i != -1; i = pre[edge[i ^ 1].to])\n        {\n            if (Min > edge[i].cap - edge[i].flow)\n                Min = edge[i].cap - edge[i].flow;\n        }\n        for (int i = pre[t]; i != -1; i = pre[edge[i ^ 1].to])\n        {\n            edge[i].flow += Min;\n            edge[i ^ 1].flow -= Min;\n            cost += edge[i].cost * Min;\n        }\n        flow += Min;\n    }\n    return flow;\n}\n\nsigned main()\n{\n    int n, m, s, t;\n    read(n), read(m), read(s), read(t);\n    init(n);\n    for (int i = 1, a, b, c, d; i <= m; i++)\n    {\n        read(a), read(b), read(c), read(d);\n        addedge(a, b, c, d);\n    }\n    int mc = 0;\n    int mf = minCostMaxflow(s, t, mc);\n    cout << mf << ' ' << mc << endl;\n    return 0;\n}\n```\n\n- 79905993 テキサス(アークナイツ)\n\n![79905993](https://i.loli.net/2020/09/08/uRC841zNy9fhHvO.jpg)","tags":["图论"]},{"title":"CF#668div2总结","url":"/2020/09/07/CF668div2/","content":"\n\n\n换了个号，从零开始。\n\n\n\n<!--more-->\n\n## A. Permutation Forgery\n\n给出 $n$ 的一个排列 $p$，定义序列 $\\text{F}(p)=\\text{sort}(p_1+p_2,p_2+p_3,\\cdots,p_{n-1}+p_n)$，让你输出 $n$ 的另一个排列 $p'$ 满足 $\\text{F}(p)=\\text{F}(p')$。\n\n简单的构造题，第一个和最后一个元素只加一次，中间的都和相邻的加两次，所以把序列翻转过来以后的效果是一样的。\n\n```c++\nsigned main()\n{\n    int T;\n    read(T);\n    while (T--)\n    {\n        int n;\n        read(n);\n        v.clear();\n        for (int i = 1, x; i <= n; ++i)\n        {\n            read(x);\n            v.emplace_back(x);\n        }\n        for (int i = 1; i <= n; ++i)\n            printf(\"%d \", v[n - i]);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n```\n\n5分钟过的，不错的开局。\n\n## B. Array Cancellation\n\n给一个元素和为 $0$ 的序列，含有 $n$ 个元素，有两种操作：\n\n1. 选取不同位置的两个数，前一个减少 $1$，后一个增加 $1$，不消耗费用；\n2. 选取不同位置的两个数，前一个增加 $1$，后一个减少 $1$，消耗 $1$ 点费用。\n\n求通过以上两种操作把所有元素全部变成 $0$ 需要花费的最小费用。\n\n前缀和水题，由于和为 $0$，前面的正数一定可以和后面的负数免费消去，但是前面的负数必须要花费代价。\n\n```c++\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 1e5 + 9;\nll a[maxn];\nsigned main()\n{\n    int T;\n    read(T);\n    while (T--)\n    {\n        int n;\n        read(n);\n        ll tmp = 0, ans = 0;\n        for (int i = 1; i <= n; ++i)\n        {\n            read(a[i]);\n            tmp += a[i];\n            if (tmp < 0)\n            {\n                ans -= tmp;\n                tmp = 0;\n            }\n        }\n        cout << ans << '\\n';\n    }\n    return 0;\n}\n```\n\n12分钟的时候过的，当时排名大概900左右，还是不错的。\n\n## C. Balanced Bitstring\n\n给一个长度为 $n$ 的串，包含 `0`，`1`，`?` 三种字符，其中 `?` 可以转化为另外两种，给出间距 $k$，问该串的所有长度为 $k$ 的连续子段能否均满足 `0`，`1` 的数量相等。数据范围 $2\\le k \\le n \\le 3\\times 10^5$，保证 $k$ 为偶数，多组数据。\n\n看到这数据范围就知道暴力和搜索已经死透了，DP似乎也做不了，正解是贪心、模拟，但是打比赛的时候我想的是用双指针。我至今都觉得双指针比贪心更像是正解。\n\n不管用什么做法，首先要注意到一个不变量：如果区间 $[l,r-1]$ 与区间 $[l+1,r]$ 均满足题意，那么 $str[l]=str[r]$，这是显然的。所以我们可以先判断前 $k$ 个字符是否符合条件，然后一位一位向后检查即可。中间需要一些分类讨论。\n\n代码是比赛的时候写的，有点丑陋。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring s;\nint n, k;\nsigned main()\n{\n    int T;\n    cin >> T;\n    while (T--)\n    {\n        cin >> n >> k >> s;\n        bool flag = true;\n        int l = 0, r = k - 1;\n        int cnt0 = 0, cnt1 = 0, cntq = 0, cntq0 = 0, cntq1 = 0;\n        for (int i = 0; i < k; ++i)\n        {\n            if (s[i] == '0')\n                cnt0++;\n            else if (s[i] == '1')\n                cnt1++;\n            else\n                cntq++;\n        }\n        if (cnt1 > k / 2 || cnt0 > k / 2)\n        {\n            puts(\"NO\");\n            continue;\n        }\n        cntq0 = k / 2 - cnt0;\n        cntq1 = k / 2 - cnt1;\n        while (r < n - 1)\n        {\n            r++;\n            if (s[l] != '?' && s[r] != '?' && s[l] == s[r])\n            {\n                l++;\n                continue;\n            }\n            else if (s[l] != '?' && s[r] != '?' && s[l] != s[r])\n            {\n                puts(\"NO\");\n                flag = false;\n                break;\n            }\n            else if (s[l] == '?' && s[r] != '?')\n            {\n                if (s[r] == '0')\n                {\n                    cnt0++;\n                    cntq0--;\n                }\n                else\n                {\n                    cnt1++;\n                    cntq1--;\n                }\n                if (cnt1 > k / 2 || cnt0 > k / 2)\n                {\n                    puts(\"NO\");\n                    flag = false;\n                    break;\n                }\n                l++;\n                continue;\n            }\n            else if (s[l] != '?' && s[r] == '?')\n                s[r] = s[l];\n            else\n            {\n                l++;\n                continue;\n            }\n            l++;\n        }\n        if (flag)\n            puts(\"YES\");\n    }\n    return 0;\n}\n```\n\n如果能注意到题目中的一些不变量，往往可以用尺取法解决。\n\n这题拖到1小时多才过，排名已经下降了很多。\n\n## D. Tree Tag\n\n有一棵树，A和B在两个结点上，给出两人的速度，每人轮流走一步，在 $10^{100}$ 时间内A要是抓到B就A赢，否则B赢，问最后结果。显然 $10^{100}$ 可以看作无穷大了。样例很良心，可以看出A获胜有三种可能：\n\n1. A第一步直接抓到B；\n2. A追上B；\n3. A速度达到树的直径的一半，就可以站在树的中间，不管B在哪里都可以抓到。\n\n读完题目第一反应是求树的直径，但是之前没做过类似的题，所以代码写的很慢也很丑，快结束的时候总算过了样例，交上去WA2，凉凉。\n\n比赛结束后一看，思路没问题，树的直径也没求错，只是第二种情况的判断错了，非常可惜。\n\n求树的直径一般用两次DFS或树形DP，显然这里需要DFS，我也只会DFS，第一次以A为根搜索出最远结点P并得到AB距离，判断第一个条件，然后从P开始DFS求出直径，判断第三个条件。问题在于第二个条件：事实上，只要 $2\\times v_a\\ge v_b$，A就可以追上B，因为A只要不断把B赶到叶子结点就可以了。\n\n可惜当时没考虑到这个简单的情况，判断的是 $v_a\\ge v_b$，令人恼火。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 2e5 + 9;\n\nint a[maxn], d[maxn];\nvi g[maxn];\nbool vis[maxn];\nvoid dfs1(int pos, int dep)\n{\n    vis[pos] = 1;\n    d[pos] = dep;\n    for (auto i : g[pos])\n        if (!vis[i])\n            dfs1(i, dep + 1);\n}\n\nsigned main()\n{\n    int T;\n    read(T);\n    while (T--)\n    {\n        int n, a, b, da, db;\n        bool flag = false;\n        read(n), read(a), read(b), read(da), read(db);\n        for (int i = 1, u, v; i < n; ++i)\n        {\n            read(u), read(v);\n            g[u].emplace_back(v);\n            g[v].emplace_back(u);\n        }\n        if (db < 2 * da + 1)\n            flag = true;\n        memset(vis, 0, sizeof(vis));\n        dfs1(a, 0);\n        if (d[b] <= da)\n            flag = true;\n        int p = 0, maxd = 0;\n        for (int i = 1; i <= n; ++i)\n            if (d[i] > maxd)\n                maxd = d[i], p = i;\n        memset(vis, 0, sizeof(vis));\n        dfs1(p, 0);\n        int maxr = *max_element(d + 1, d + 1 + n);\n        maxr++;\n        if (maxr / 2 <= da)\n            flag = true;\n        if (flag)\n            puts(\"Alice\");\n        else\n            puts(\"Bob\");\n        for (int i = 1; i <= n; ++i)\n            g[i].clear();\n    }\n    return 0;\n}\n```\n\n其实代码非常好写。\n\n## E. Fixed Point Removal\n\n给一个长度为 $n$ 的序列并给出其中元素的值，$q$ 次询问，每次固定区间 $[1,l]$ 和 $[n-r+1,n]$ 的元素，然后不断去掉大小等于序列位置的元素并连接成新序列，求最多可以去掉多少个元素。$1\\le n,q \\le 3\\times 10^5$。\n\n显然，如果同时可以删除多个元素，从后往前删除。预处理用 $i-a_i$ 替换 $a_i$ 并转化成区间 $[l+1,n-r]$ 来做也会方便很多。\n\n这些准备工作做好以后用线段树或树状数组维护，然后二分求答案。\n\n代码改日再补。\n\n## 总结\n\n又是差一点过4题，非常可惜。CD写的太慢了，如果写快一些还可以留出自己造数据的时间，D题的错误还是不难发现的。之前并没有做过求树的直径的题目，接下来要多扩充一下做题的范围。洛谷绿题以下难度的题目尽量不要做了，手速可以通过打ABC和div3来练。\n\n- 84140181 カグラナナ\n\n![84140181](https://i.loli.net/2020/09/07/Pjg8O5MECbzlvwk.jpg)\n\n","tags":["CodeForces"]},{"title":"最大流","url":"/2020/09/05/Maximum_Flow/","content":"\n\n\n整理了一下网络流最基础的概念。\n\n\n\n<!--more-->\n\n# 基本概念\n\n和拓扑排序类似，有向无自环连通图，有一个源点 $S$，一个汇点 $T$。\n\n每条边有一个容量 $c$。\n\n## 性质\n\n显而易见的三个性质：\n\n- 容量限制：$\\large f_{(u,v)}\\le c_{(u,v)}$，每条边的流量当然不会超过其容量；\n- 斜对称性：$\\large f_{(u,v)}=- f_{(v,u)}$，流出了 $f$ 自然就相当于流入了 $-f$；\n- 流量平衡：除了源点和汇点外的任意结点 $u$，$\\large\\sum_{(u,v)\\in E}f_{(u,v)}=0$，就像基尔霍夫电流定律一样。\n\n## 容许流\n\n对于每条边 $e$，给一个流量 $f_e$ 满足 $f_e\\le c_e$，由于存在流量平衡，令总流量 $W=\\sum_{e=(S,i)}f_e=\\sum_{e=(i,T)}f_e$，这样的一组 $f$ 称为该网络的一个容许流。\n\n总流量 $W$ 最大的容许流就是该网络的最大流，显然最大流可能不是唯一的。\n\n## 残余容量\n\n在选取了某个容许流之后，将这个容许流经过的每条边的容量减去相应的流量，剩下的容量就是残余容量（残量）。\n\n网络中所有节点以及剩余容量大于 $0$ 的边构成的子图被称为残量网络。\n\n## 增广路\n\n从源点到汇点的一条残量均大于 $0$ 的路径被称为增广路。\n\n增广路定理：只要残量网络中存在增广路，总流量就可以增大，当不存在增广路的时候当前流也就是最大流了。\n\n## 反向弧\n\n一条边可能被包含于多条增广路中，如果通过不断寻找增广路来求最大流，我们要让一条边拥有被多次选择的机会。\n\n为了解决这个问题，可以给每条边建立一条反向边，初始流量为 $0$，当某条边流出 $f$ 流量时，给它的反向边增加 $f$ 的流量，这样就相当于提供了反悔的机会。\n\n# 算法\n\n$n$ 个点，$m$ 条边，最大流 $f$\n\n## Ford-Fulkerson算法\n\n就是上面说的通过不断找增广路来求最大流的方法，通过DFS实现，时间复杂度 $O(mf)$。\n\n由于复杂度与最大流有关，在数据比较极端的情况下，FF算法的表现会非常离谱。\n\n所以这个算法并没有什么用处。\n\n## Edmond-Karp算法\n\n这是BFS实现的FF算法，每次找到的是最短的增广路，时间复杂度 $O(nm^2)$，看起来稍微靠谱了一点，但是还是会被卡掉。\n\n代码参考紫书。\n\n```c++\nstruct edge\n{\n    int from, to, cap, flow;\n    edge(int u, int v, int c, int f) : from(u), to(v), cap(c), flow(f) {}\n};\nstruct EK\n{\n    int n, m;\n    vector<edge> e;\n    vi g[maxn];\n    int a[maxn], p[maxn];\n    void init(int n)\n    {\n        for (int i = 1; i <= n; ++i)\n            g[i].clear();\n        e.clear();\n    }\n    void add(int from, int to, int cap)\n    {\n        e.push_back(edge(from, to, cap, 0));\n        e.push_back(edge(to, from, 0, 0));\n        m = e.size();\n        g[from].push_back(m - 2);\n        g[to].push_back(m - 1);\n    }\n    ll maxflow(int s, int t)\n    {\n        ll flow = 0;\n        for (;;)\n        {\n            memset(a, 0, sizeof(a));\n            queue<int> q;\n            q.push(s);\n            a[s] = inf;\n            int cnt = 0;\n            while (!q.empty())\n            {\n                int x = q.front();\n                q.pop();\n                for (int i = 0; i < g[x].size(); ++i)\n                {\n                    edge &eg = e[g[x][i]];\n                    if (!a[eg.to] && eg.cap > eg.flow)\n                    {\n                        p[eg.to] = g[x][i];\n                        a[eg.to] = min(a[x], eg.cap - eg.flow);\n                        q.push(eg.to);\n                    }\n                }\n                if (a[t])\n                    break;\n            }\n            if (!a[t])\n                break;\n            for (int u = t; u != s; u = e[p[u]].from)\n            {\n                e[p[u]].flow += a[t];\n                e[p[u] ^ 1].flow -= a[t];\n            }\n            flow += a[t];\n        }\n        return flow;\n    }\n};\nEK solve;\nsigned main()\n{\n    int m, s, t;\n    read(solve.n), read(m), read(s), read(t);\n    solve.init(solve.n);\n    for (int i = 1; i <= m; ++i)\n    {\n        int u, v, w;\n        read(u), read(v), read(w);\n        solve.add(u, v, w);\n    }\n    cout << solve.maxflow(s, t) << '\\n';\n    return 0;\n}\n```\n\n## Dinic算法\n\n这是对EK算法的优化，先用BFS分层，预处理出源点到每个点的距离，再用DFS寻找。\n\n分层会带来的两点好处：\n\n1. 如果不存在到汇点的增广路，就可以停止增广；\n2. 确保找到最短的增广路；\n\n两个优化：\n\n1. 多路增广：每找到一条增广路，如果残量还未用完就再找一条增广路，这样可以在一次DFS中找到多条增广路；\n2. 当前弧优化：如果一条边被增广过了，就不会被增广第二次，下次就不用经过这条边了。\n\n该算法的时间复杂度 $O(n^2m)$，在稠密图上的表现比EK算法好很多。\n\n在求解二分图最大匹配问题时，Dinic算法的时间复杂度是 $O(m\\sqrt n)$，比匈牙利算法更优秀。\n\n模板来自[OI wiki](https://oi-wiki.org/graph/flow/max-flow/)。\n\n```c++\nstruct Edge\n{\n    int from, to, cap, flow;\n    Edge(int u, int v, int c, int f) : from(u), to(v), cap(c), flow(f) {}\n};\n\nstruct Dinic\n{\n    int n, m, s, t;\n    vector<Edge> edges;\n    vector<int> G[maxn];\n    int d[maxn], cur[maxn];\n    bool vis[maxn];\n    void init(int n)\n    {\n        for (int i = 0; i < n; i++)\n            G[i].clear();\n        edges.clear();\n    }\n    void AddEdge(int from, int to, int cap)\n    {\n        edges.push_back(Edge(from, to, cap, 0));\n        edges.push_back(Edge(to, from, 0, 0));\n        m = edges.size();\n        G[from].push_back(m - 2);\n        G[to].push_back(m - 1);\n    }\n    bool BFS()\n    {\n        memset(vis, 0, sizeof(vis));\n        queue<int> Q;\n        Q.push(s);\n        d[s] = 0;\n        vis[s] = 1;\n        while (!Q.empty())\n        {\n            int x = Q.front();\n            Q.pop();\n            for (int i = 0; i < G[x].size(); i++)\n            {\n                Edge &e = edges[G[x][i]];\n                if (!vis[e.to] && e.cap > e.flow)\n                {\n                    vis[e.to] = 1;\n                    d[e.to] = d[x] + 1;\n                    Q.push(e.to);\n                }\n            }\n        }\n        return vis[t];\n    }\n    int DFS(int x, int a)\n    {\n        if (x == t || a == 0)\n            return a;\n        int flow = 0, f;\n        for (int &i = cur[x]; i < G[x].size(); i++)\n        {\n            Edge &e = edges[G[x][i]];\n            if (d[x] + 1 == d[e.to] && (f = DFS(e.to, min(a, e.cap - e.flow))) > 0)\n            {\n                e.flow += f;\n                edges[G[x][i] ^ 1].flow -= f;\n                flow += f;\n                a -= f;\n                if (a == 0)\n                    break;\n            }\n        }\n        return flow;\n    }\n    int Maxflow(int s, int t)\n    {\n        this->s = s;\n        this->t = t;\n        int flow = 0;\n        while (BFS())\n        {\n            memset(cur, 0, sizeof(cur));\n            flow += DFS(s, INF);\n        }\n        return flow;\n    }\n};\n```\n\n## 更高级的算法\n\n更强的优化：ISAP\n\n预流推进算法：HLPP\n\n这两个以后再说。\n\n# 最大流最小割定理\n\n割，就是去掉网络中的一些边使得源点到汇点不再连通。\n\n割的大小是这些去掉的边的容量之和，在所有可行的割中，容量和最小的被称为最小割。\n\n**最大流最小割定理：最大流等于最小割**\n\n因此，任意流不大于任意割。\n\n- 83800932\n\n![83800932](https://i.loli.net/2020/09/05/OAsfXIQBwocSazH.jpg)\n\n\n\n虽然最大流的算法比较好理解，但是每到用的时候都很不熟练。","tags":["图论"]},{"title":"C++作业预想","url":"/2020/09/03/International_Draughts/","content":"\n\n\nC++的信息技术基础认知与实践课需要做一个有图形界面的游戏。棋类游戏的图形界面比较好做，所以我打算做个国际跳棋游戏。\n\n\n\n<!--more-->\n\n## 综述\n\n小学的时候练过一段时间国际跳棋，规则很简单，算法应该不是很难写。先来看规则（波兰规则）：\n\n1. **棋盘：**$10 \\times 10$ 棋盘，相邻格子异色，每人左下角第一个是深色格子，只有深色格子可以落子；\n2. **棋子：**每一方20个子，从下往上四排；\n3. **行棋：**兵只能向左前方或右前方的空格行动，王棋的行动方式与国际象棋的主教完全相同；\n4. **吃子：**在自己行棋路径上如果存在后方没有棋子或棋盘边界支撑的敌方棋子就需要进行吃子操作，走到被吃掉的棋子的后方空位中：\n   1. 只能吃掉敌方棋子，不能跳过己方棋子；\n   2. 有吃必吃，当可以吃子的时候必须选择一条吃子路径；\n   3. 有多吃多，必须选择吃子数量最多的路径（之一）；\n   4. 土耳其打击，即不能重复吃掉一个子；\n5. **升变：**兵在一次行棋后停留在敌方底线就会升变为王棋；\n6. **胜负结算：**如果一方失去所有棋子或无法继续行棋则判负。\n\n规则比较简单，用一个二维数组存放棋盘可以比较好的模拟行棋的过程。\n\n接下来需要考虑如何具体实现。\n\n## 图形界面\n\n本来棋盘这样的东西是很适合用easyx库来画的，但是这次好像一定要面向对象，做Windows桌面应用，事情就变得复杂起来了。\n\n上课演示的VC6.0已经被淘汰太久了，和现在的VS差别巨大，所以还是要自己探索。\n\n这部分等搞明白了再更新。\n\n## 算法\n\n需要写一个AI程序，太强的也写不出来，反正这作业对算法方面的要求也几乎没有，只要写一个并不是特别蠢就可以了。\n\n由于每次行棋的合法选择很少，所以可以考虑搜索：\n\n1. 找出可能的行棋路径\n   1. 判断是否存在吃子情况，如果存在，搜索出若干条最大吃子路径\n   2. 如果不存在，找出可行路径（一般不会超过20种）\n2. 局势判断\n   1. 找出对方的可行送吃路径（一般不会超过5种），计算子力交换后双方的局势，如果会导致局势对己方的不利程度超过阈值则选取避免对方送吃的路径；\n   2. 找出己方的可行送吃路径（一般不会超过5种），计算子力交换后双方的局势，如果会导致局势对己方的有利程度超过阈值则选择最大的此种路径；\n   3. 计算棋子的个数、位置价值之和与密集程度，生成该时刻的局势，选取剩余路径中对局势影响最优的一条。\n3. 优化\n   1. 在局势判断的前2条中，可以使用迭代加深搜索，选取一个较为合适的预测对方的步数作为最大深度；\n   2. 增加残局特殊策略；\n   3. 优化局势计算函数。\n\n等图形界面搞好了再写成代码。\n\n![82229673](https://i.loli.net/2020/09/03/DE946d5NxMIfkih.jpg)\n\n\n\n","tags":["其它"]},{"title":"2020年度大更新","url":"/2020/09/01/2020update/","content":"\n\n\n主题更新完毕，一些隐藏的问题可能会逐渐暴露出来。\n\n\n\n<!--more-->\n\n## 主题\n\n`landscape`->`stun`\n\n增加功能（理论上）：\n\n- 文章置顶\n- 头像\n- 分享链接\n- 友链\n- 背景图片与特效\n- 搜索（可能存在一些问题，已关闭）\n- 夜间模式\n- 显示最后修改时间\n- 代码复制\n- ......\n\n待修复问题：\n\n- 数学公式无法正确渲染（修复完毕）\n  - 因此上半年的博客暂时撤下\n- live2D动画无法显示\n  - 需要使用Git进行一些操作\n  - 珂朵莉装不上了，装miku吧\n- 头像等图片无法正常显示\n  - 调试yml文件（修复完毕）\n- ......\n\n\n\n## 模板更新\n\n1. `math: true` 代替原先的 `mathjax: true`\n2. 置顶：`top: true`\n3. 最后修改时间：`updated: YYYY-MM-DD`\n\n[参考文档](https://liuyib.github.io/hexo-theme-stun/zh-CN/guide/quick-start.html)\n\n## 维修记录\n\n### 主题更换\n\n安装主题：`git clone https://github.com/liuyib/hexo-theme-stun.git themes/stun`\n\n修改博客的 `yml` 文件更换主题。\n\n大部分操作可以在上面的文档中找到。\n\n### 修复数学公式渲染问题\n\n我的大多数博客中都有内联公式，因此这是我首先需要解决的问题。\n\n记得在刚使用 `landscape` 主题的时候也遇到过公式无法渲染的问题，当时的解决方法是根据[这篇博客](https://www.jianshu.com/p/7ab21c7f0674)说的修改了一下一个配置文件。但是之前照着文档里说的把 `hexo-renderer-kramed` 引擎卸载了，装了一个新的，新引擎相应的配置文件并没有找到，所以我还是把新的卸掉了，把 `hexo-renderer-kramed` 装了回来。\n\n然后找到 `node_modules\\kramed\\lib\\rules\\inline.js`，把其中的\n\n```javascript\nescape: /^\\\\([\\\\`*{}\\[\\]()#$+\\-.!_>])/,\n```\n\n改成\n\n```javascript\nescape: /^\\\\([`*\\[\\]()#$+\\-.!_>])/,\n```\n\n并把\n\n```javascript\nem: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n```\n\n改成\n\n```javascript\nem: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/\n```\n\n然后就可以了。\n\n### live2D\n\n本来想装[珂朵莉](https://github.com/phlzy/chtholly_kanban)的，但是装不上去，所以只好装miku了\n\n首先，`npm install --save hexo-helper-live2d`，安装\n\n然后在hexo的 `__config.yml` 中增加\n\n```yml\n# Live2D \n## https://github.com/EYHN/hexo-helper-live2d \nlive2d:\n  # enable: true \n  # enable: false\n  scriptFrom: local # 默认 \n  pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径) \n  pluginJsPath: lib/ # 脚本文件相对与插件根目录路径 \n  pluginModelPath: assets/ # 模型文件相对与插件根目录路径 \n  # scriptFrom: jsdelivr # jsdelivr CDN \n  # scriptFrom: unpkg # unpkg CDN \n  # scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js \n  # 你的自定义 url \n  tagMode: false \n  # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中 \n  debug: false \n  # 调试, 是否在控制台输出日志 \n  model: \n    # scale: 1\n    # use: /assets/chtholly.model.json\n    use: live2d-widget-model-miku\n    # npm-module package name \n    # use: wanko # 博客根目录/live2d_models/ 下的目录名 \n    # use: ./source/live2d/wanko # 相对于博客根目录的路径 \n    # use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url \n    display: \n      position: right\n      width: 150 \n      height: 300 \n    mobile: \n      show: true\n      # 手机中是否展示 \n      scale: 0.5\n```\n\n然后 `npm install live2d-widget-model-miku`\n\n就完成了\n\n### 图片修改\n\n修改头像、网页标签等，用PS改一改就好了\n\n### 评论区\n\n[注册](https://github.com/settings/applications/new)并按照要求填写，然后修改yml相关内容\n\n按照[这篇博客](https://blog.csdn.net/Mart1nn/article/details/87478971)调整可以修复 `Error: Not found` 的问题\n\n### 其他\n\n搜索、阅读量统计等，参考文档即可\n\n头像出处：\n\n![Chtholly](https://i.loli.net/2020/09/01/JRAGqP42Kohb3Tw.jpg)\n\n基本上就是这样了\n\n## 后记\n\n### cmd的问题\n\n出现了名为 `Spawn failed` 的错误，似乎是找不到仓库了，上网查了一下解决方案，发现问题出在Windows的cmd上面。\n\n解决方法如下：\n\n1. 打开Git，输入 `cd` 和 `.deploy_git` 文件夹的路径，打开这个文件夹\n2. 输入 `git log` 查看日志\n3. 输入 `q` 退出日志状态\n4. 找到对应的版本id，输入 `git reset --hard id`，或者根据顺序用 `git reset --hard HEAD^` 来回退到上一个正常的版本\n5. `hexo clean`，`hexo g`，`hexo d` 正常更新一遍\n6. 抛弃cmd，以后使用Git进行更新\n\n### 卸载搜索功能\n\n`npm un hexo-algolia --save`","tags":["其它"]},{"title":"关于博客","url":"/2020/09/01/main/","content":"\n此帖置顶\n\n<!--more-->\n\n这里有各种乱七八糟的东西\n\n内容很少的[CSDN博客](https://me.csdn.net/Pastafarian)\n\n两个CF帐号\n\n[![](https://cfrating.ihcr.top/?user=Theophania&style=for-the-badge)](https://codeforces.com/profile/_Watson)\n\n[![](https://cfrating.ihcr.top/?user=ToyaKoyo&style=for-the-badge)](https://codeforces.com/profile/Watson_2020)\n\n[AtCoder](https://atcoder.jp/users/Kutori)\n\n\n### 代码起手式\n\n- C++11\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\n//* C++ 11\ntemplate <typename T, typename... Args>\ninline void read(T &t, Args &... args)\n{\n    read(t);\n    read(args...);\n}\n\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 1e4 + 9;\n\nsigned main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"data.txt\",\"w\",stdout);\n    //std::ios::sync_with_stdio(false);\n    //std::cin.tie(0);\n    //std::cout.tie(0);\n    \n    //fclose(stdin);\n    //fclose(stdout);\n    return 0;\n}\n```\n\n\n\n### 彩虹\n\n![](https://i.loli.net/2020/02/02/FaQY4pvPuTi2W9S.png)\n\n### 洛谷\n\n\n ![](https://luogu.vercel.app/api?id=256465&hide_title=true)\n\n\n\n### 统计\n\n|    时间    |   成就    |\n| :--------: | :-------: |\n| 2019.11.6  |  做完NOJ  |\n| 2019.11.24 | 洛谷橙名  |\n| 2020.1.15  | 洛谷AC100 |\n| 2020.7.14  | 洛谷AC200 |\n|  2020.9.4  | 洛谷AC300 |\n|  2020.9.5  |  cf蓝名   |\n| 2020.9.26  |  省赛铜   |\n| 2020.10.12 | 洛谷红名  |\n| 2020.11.7  | 洛谷AC400 |\n\n\n","tags":["其它"]},{"title":"有趣的图论和数据结构等","url":"/2020/08/31/2020-8-index/","content":"\n\n\nupdate: 今后如果要写一些有趣但不怎么有用的东西可能会收录在这里。\n\n\n\n<!--more-->\n\n计划每天学一个新东西，比赛多的时候就写简单的或者不重要的，别的就在比赛少的时候写。反正是写给自己看，有些有趣的数据结构也就写一写当做娱乐好了。\n\n|                        内容（原计划）                        |    更新版    |\n| :----------------------------------------------------------: | :----------: |\n|        [LCA](https://phlzy.github.io/2020/08/14/LCA/)        |              |\n| [DFS序，树链剖分](https://phlzy.github.io/2020/08/18/path_decomposition/) |              |\n|  [左偏树](https://phlzy.github.io/2020/08/16/Leftist_Tree/)  |              |\n|                            扫描线                            |              |\n|                        ~~各种生成树~~                        | 计算几何基础 |\n| [zkw线段树](https://phlzy.github.io/2020/08/19/zkw_Segment_Tree/) |              |\n|                            划分树                            |              |\n|                      ~~可持久化线段树~~                      |   旋转卡壳   |\n|      [Splay](https://phlzy.github.io/2020/08/21/Splay/)      |              |\n|                        ~~FHQ-Treap~~                         |   半平面交   |\n|                           ~~斜堆~~                           |  Lucas定理   |\n|                          ~~点分治~~                          |   排列组合   |\n|                          ~~树套树~~                          |              |\n|                           ~~LCT~~                            |              |\n|                          ~~Tarjan~~                          |              |\n|                          ~~网络流~~                          |              |\n\n\n\n顺便放上[模板的链接](https://phlzy.github.io/2020/08/12/Template/)\n\n[踩过的坑](https://phlzy.github.io/2020/08/19/Tips/)\n\n\n\n![阿尔托莉雅](https://i.loli.net/2020/08/19/38fVQGqbd6BZKIe.jpg)\n\n\n\n","tags":["其它"]},{"title":"关于游泳","url":"/2020/08/31/swim/","content":"\n\n是时候，该为我近十五年的游泳运动生涯画上句号了。\n\n\n\n<!--more-->\n\n昨天晚上快要打cf的比赛的时候，学校游泳队的队长大哥问我脚蹼尺码，当时比较忙没有马上回复，直到打完比赛在微信上打字的时候，我突然意识到，这将近15年的游泳运动生涯，似乎是真的结束了。\n\n退出校游泳队的想法并不是昨天突然萌生的，而是在几个月前早就有了，当时由于受到疫情影响游泳队一个学期都没有训练，我也没有提出这个想法。吴清源说的“不搏二兔”我觉得非常有道理，既然我选择将几乎全部业余时间用于ACM的训练，每周一个上午的游泳训练也自然需要放弃了。\n\n虽然我从未真正从心里喜欢过游泳这项运动，小时候也曾多次寻找机会试图放弃，但是毕竟是比较专业的练了五六年，最近几年也有几次比赛需要参加，说完全没有感情也是不可能的。当年在体育场的体能训练、备战市运会的一天双练、打酱油的迎春杯省赛等场景仍然历历在目。大学游泳队的氛围也很好，我在之前的训练中对我们学校游泳队的水平可以说非常了解，作为游泳队的主力，这样退役让我心怀愧疚，但是我必须这么做。\n\n三四年前我虽然已经很久没有训练，但是在自己调整了不到一周后，我的50米自由泳依然可以冲到28秒，还是可以带领团队拿到金牌。自由泳并不是我小时候练的主项，但是三年前的我，称一句“宝刀未老”，应该也不算太过。可是大半年前，在校队训练了几次的我50米自由泳仍然无法游进30秒，虽然客观上泳池规格、出发形式以及赛程都对成绩有影响，但是我的状态确实是不复当年了。又过了大半年，以我目前的竞技状态，也只能在校队中表现一下，如果代表学校外出比赛，必然是没有什么希望的。\n\n本来我的游泳运动生涯可能在几年前选择了学业就早早结束了，但是比赛总是阴魂不散，说不定什么时候，就要重新回去训练一下，应付比赛了。这一次，应该是真的结束了。\n\n还记得小时候父亲逼我坚持练游泳，他不止一次对我说，他并不希望我今后成为职业运动员，但是希望我能够熟练掌握游泳的技能，并获得强健的体魄。在他看来，学会游泳不仅多了一项求生的工具，也多了一种爱好、多掌握了一种门技术。从某种角度来说，他说的并没有问题，但是仔细想想，似乎也并不是那么回事。如今我确实掌握了各种游泳的技术，可能在人群中，能在泳池中超过我的人不到千分之一，但是这只是在泳池的理想环境中，如果在洪水中、海里或是任何未知的水域中，我和绝大多数普通人并没有太大的区别。在湍急的水流中，即便是奥运冠军也不能保证自己的安全。游泳的技能在这十多年中，也并没有给我带来多少好处，除了大一上学期免去了体育锻炼课与30次打卡，就是那几块几乎毫无价值的奖牌，剩下能让我长久铭记的，可能是十年前两次急性肠胃炎的滋味。\n\n对别人来说，游泳代表的可能是夏日的清凉，是暑假的悠闲，是玩水的快乐，而这些对我来说几乎都没有。我并不喜欢去游泳，我更喜欢待在家里，做我想做的事情。\n\n有人觉得，被ACM束缚的大学生活，很亏。我觉得不然。高中的时候比较喜欢化学，也曾希望未来从事化学方面的工作，是因为学习化学的时候我可以感受到化学的美，感受到自然规律的巧妙。由于种种原因，我最终也没有选择化学相关的专业，当年的梦想现在已经用来追忆了。在学习其它科目的过程中，我并不能感受到那种知识的美妙之处，直到接触到了这些算法与数据结构，这是与化学不同的美，是人类用智慧创造出的精妙理论之美。我终于和当年一样，在学习知识的时候能够重新给自己正向的反馈，而不是觉得在浪费自己的生命。\n\n人的生命非常有限，我也只是一个普通人，我很清楚的知道想达到像Tarjan、Dijkstra这样的成就几乎是不可能的，我只希望，我能在我愿意研究的领域中，留下一点探索的痕迹，在未来有和我同样兴趣的人探索到这个地方的时候，能够欣慰的说，原来从前也有这样的一个人和我一样走到了这里，看到了这里的奥秘。如果能够做到这样，我想我生命的价值也就达到了。\n\n总是有人说什么艺多不压身，说到底还是在欺骗自己，人的时间是有限的，搞的好像自己会了很多东西，学一身三脚猫功夫，什么事情都做不好，还让自己看起来很忙很努力，真是毫无意义。几百年前还有所谓的“全才”，后来就没有了，也证明了这个观点。国内有理论计算机科学方向的大学非常少，我也不想在我不感兴趣的东西上浪费我的时间，所以我今后也并不怎么想读研。以后怎样，就随他去吧。\n\n一想到以后可以少做一件不怎么感兴趣的事，多了一些时间追求目前的理想，也就畅快了不少。理想屈服于现实的感受，真的不怎么样，我也不希望再体会一次。\n\n![hikaru](https://i.loli.net/2020/08/31/Vr8IknRaj2SvfGx.png)\n\n在这里放这张图真是再合适不过了","tags":["随笔"]},{"title":"AtCoder Beginner Contest 177","url":"/2020/08/29/ABC177/","content":"\n\n\n虽然题目很水，但是。。。\n\n\n\n<!--more-->\n\n## A\n\n显然\n\n```c++\nll a, b, c;\ncin >> a >> b >> c;\nif (b * c >= a)\n    cout << \"Yes\" << endl;\nelse\n    cout << \"No\" << endl;\n```\n\n## B\n\n看数据范围，直接暴力\n\n```c++\nstring s, t;\ncin >> s >> t;\nint ans = inf;\nint a = s.length(), b = t.length();\nfor (int i = 0; i < a; ++i)\n{\n    int cnt = 0;\n    if (i + b - 1 >= a)\n        break;\n    for (int j = 0; j < b; ++j)\n        if (s[i + j] != t[j])\n            cnt++;\n    ans = min(ans, cnt);\n}\n```\n\n## C\n\n式子都给你了，无脑前缀和，居然Wa了两发，真的傻逼\n\n```c++\nint n;\nread(n);\nfor (int i = 1; i <= n; ++i)\n{\n    read(a[i]);\n    s[i] = (s[i - 1] + a[i]);\n}\nll ans = 0;\nfor (int i = 1; i < n; ++i)\n{\n    ans += a[i] * ((s[n] - s[i]) % mod) % mod;\n    ans %= mod;\n}\ncout << ans % mod << endl;\n```\n\n算前缀和的时候不要取模，这种地方也能错也是没谁了\n\n## D\n\n并查集裸题，求最大集合的大小\n\n```c++\nint fa[maxn], a[maxn];\nint findfa(int x)\n{\n    return fa[x] == x ? x : fa[x] = findfa(fa[x]);\n}\nvoid join(int x, int y)\n{\n    int fx = findfa(x), fy = findfa(y);\n    if (fx != fy)\n        fa[fx] = fy;\n}\nmap<int, int> mp;\nsigned main()\n{\n    int m, n;\n    read(m), read(n);\n    for (int i = 1; i <= m; ++i)\n        fa[i] = i;\n    for (int i = 1; i <= n; ++i)\n    {\n        int u, v;\n        read(u), read(v);\n        join(u, v);\n    }\n    int ans = 0;\n    for (int i = 1; i <= m; ++i)\n    {\n        findfa(i);\n        mp[fa[i]]++;\n        ans = max(ans, mp[fa[i]]);\n    }\n    cout << ans << endl;\n    return 0;\n}\n```\n\n自己写的时候路径压缩还写错了一次，虽然很快就改对了\n\n## E\n\n虽然秒出了正解，但是一直没调对。。。\n\n显然，如果是 `pairwise coprime` 的，说明任意两个不同元素不会有相同质因子，那么用欧拉筛先找出范围内所有质因子然后进行一遍匹配，如果某个质因子匹配到的元素个数超过一个就说明不符合条件。剩下两种情况直接 $O(n)$ 跑一遍就好了。\n\n稍微观察一下就可以发现，上面的匹配过程和埃氏筛的原理差不多，复杂度是 $O(n\\log n)$ 的，没有任何问题。\n\n所以，为什么我在一个小时中尝试了各种写法，但是一次都没过呢？\n\n我居然用欧拉筛找的是 $[1,\\sqrt n]$ 区间中的质数！\n\n真服了。\n\n还有，这题会爆int。\n\n```c++\nconst int maxn = 1e6 + 9;\nbitset<maxn> num;\nvector<int> prime;\ninline void init(int n)\n{\n    for (int i = 2; i <= n; ++i)\n    {\n        if (!num[i])\n            prime.push_back(i);\n        for (int j = 0; j < prime.size(); ++j)\n        {\n            if (i * prime[j] >= n)\n                break;\n            num[i * prime[j]] = 1;\n            if (i % prime[j] == 0)\n                break;\n        }\n    }\n}\nvector<ll> v;\nunordered_map<ll, int> ump;\nint main()\n{\n    init(1000000);\n    int sz = prime.size();\n    int n;\n    ll maxx = 0;\n    read(n);\n    bool flag = true;\n    for (int i = 1; i <= n; ++i)\n    {\n        ll x;\n        maxx = max(maxx, x);\n        read(x);\n        ump[x]++;\n        v.emplace_back(x);\n    }\n    for (int i = 0; i < sz; ++i)\n    {\n        int tot = 0;\n        for (int j = 1;; ++j)\n        {\n            if (1LL * j * prime[i] > 1LL * maxx)\n                break;\n            tot += ump[j * prime[i]];\n        }\n        if (tot > 1)\n        {\n            flag = false;\n            break;\n        }\n    }\n    if (flag)\n    {\n        cout << \"pairwise coprime\" << endl;\n        return 0;\n    }\n    ll g = v[0];\n    for (int i = 1; i < n; ++i)\n        g = __gcd(g, v[i]);\n    if (g == 1)\n        cout << \"setwise coprime\" << endl;\n    else\n        cout << \"not coprime\" << endl;\n    return 0;\n}\n```\n\n这也从侧面证明了队友的重要性。当局者迷，旁观者清，要是有队友在场这种题可能十分钟就过了。\n\n当然，总是出这种傻逼错误也是很需要反省的。\n\n第二天回来一看，这题不仅可以这样做，甚至连 $O(n\\sqrt n)$ 的暴力做法也能过，这就更让人恼火了。\n\n## F\n\n有趣的题目，有趣的做法。\n\n有人用两棵线段树做，也有人用一个 `map` 和一个 `multiset`。下面的这份代码看得我似懂非懂，过两天回头再来看看。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nmap<int, int> m;\nmultiset<int> s;\nint main(){\n    int h, w, a, b;\n    cin >> h >> w;\n    for (int i = 0; i < w; i++)\n        m[i] = i, s.insert(0);\n    for (int i = 0; i < h; i++){\n        cin >> a >> b;\n        a--;\n        auto pos = m.lower_bound(a);\n        int mx = -1;\n        while (pos != m.end() && pos->first <= b){\n            mx = max(mx, pos->second);\n            int x = pos->first - pos->second;\n            s.erase(s.find(x));\n            m.erase(pos++);\n        }\n        if (mx != -1 && b < w){\n            s.insert(b - mx);\n            m[b] = mx;\n        }\n        cout << (s.empty() ? -1 : *s.begin() + i + 1) << endl;\n    }\n    return 0;\n}\n```\n\n根据代码大概可以知道 `multiset` 中存储的是最短水平移动距离，`map` 中的可能是水平移动的起点，并不是很确定。\n\n## 总结\n\n最近两场ABC都是至少可以过5题的，但是目标并没有达到。\n\n虽然ABC大部分题目难度很低，但是刷水题并不是没有意义，多打打这样的比赛可以提升速度与debug能力，也能巩固一些基础知识，还能维持一下比赛的状态。\n\n组队赛告一段落，我们最终排名第四，有点危险。\n\nCCF认证还有两个星期，不知道考什么，这两天还是先全面发展，看看图论和数学好了。这种考试也不可能考很难的数据结构之类的东西。\n\n暑假只剩最后一场cf，差32分上蓝。能不能完成之前立的flag，就看这次的发挥了。虽然说正常发挥的话只要把前三题比较快的过掉，基本就能达到目的了，但是我的状态波动也很大，结果如何还未尝可知。\n\n不管怎样，上蓝是迟早的事，新学期要到了，立一个新的flag，学期结束前上紫。\n\n让我们拭目以待。\n\n![83590230](https://i.loli.net/2020/08/30/nw3GJg8kPUKSBZV.jpg)","tags":["AtCoder"]},{"title":"Splay区间操作","url":"/2020/08/29/Splay_beta/","content":"\n前几天打比赛没时间写博客，这两天终于可以更新了。\n\nSplay虽然常数大，但是其Splay函数拥有一些神奇的性质，可以实现一些别的平衡树难以完成的操作，如序列翻转等。\n\n\n\n<!--more-->\n\n## 区间翻转\n\n有一个序列 $[1,n]$，每次翻转其中的 $[l,r]$，有 $q$ 次操作。\n\n如果直接模拟，复杂度 $O(qn)$。\n\n像AVL树、旋转式Treap、替罪羊树等常见的平衡树很难用来维护序列，因为如果对序列建树，需要修改的区间在平衡树中可能会分散在多个位置，不仅修改起来很复杂还无法发挥出平衡树的优势。而Splay的自我调整过程可以将待修改区间挤到一个子树中，就可以发挥出平衡树的优势了。\n\n具体来说，由于Splay操作每次将一个结点旋转到根结点，那么我们先把结点 $l-1$ Splay到根结点，显然区间 $[l,n]$ 现在就位于根结点的右子树了，然后再把结点 $r+1$ Splay到根结点的右儿子，那么 $r+1$ 的左子树就是区间 $[l,r]$ 了，我们只需要对这个子树的根打标记并像线段树一样传递标记即可实现区间翻转。复杂度 $O(q\\log n)$。\n\n代码如下：（[模板题P3391](https://www.luogu.com.cn/problem/P3391)）\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 1e5 + 9;\n\nstruct node\n{\n    int fa, sz, cnt, val, tag;\n    int son[2];\n    //node(){}\n};\nnode tree[maxn];\nint ori[maxn], root, wz;\ninline bool which(int x)\n{\n    return x == tree[tree[x].fa].son[1]; //left:0 right:1\n}\ninline void update(int x)\n{\n    if (x == 0)\n        return;\n    tree[x].sz = tree[x].cnt;\n    if (tree[x].son[0])\n        tree[x].sz += tree[tree[x].son[0]].sz;\n    if (tree[x].son[1])\n        tree[x].sz += tree[tree[x].son[1]].sz;\n}\ninline void push_down(int x)\n{\n    if (x && tree[x].tag)\n    {\n        tree[tree[x].son[0]].tag ^= 1;\n        tree[tree[x].son[1]].tag ^= 1;\n        swap(tree[x].son[0], tree[x].son[1]);\n        tree[x].tag = 0;\n    }\n}\ninline void rotate(int x)\n{\n    int f = tree[x].fa, gf = tree[f].fa;\n    push_down(x), push_down(f); //* push down the tags\n    bool w = which(x);\n    tree[f].son[w] = tree[x].son[w ^ 1];\n    tree[tree[f].son[w]].fa = f; //* conect son\n    tree[f].fa = x;\n    tree[x].fa = gf;\n    tree[x].son[w ^ 1] = f; //* conect father\n    if (gf != 0)\n        tree[gf].son[tree[gf].son[1] == f] = x; //* update grandpa\n    update(f);\n}\nvoid splay(int x, int to)\n{\n    while (tree[x].fa != to)\n    {\n        int y = tree[x].fa;\n        if (tree[y].fa != to)\n            rotate(which(x) == which(y) ? y : x);\n        rotate(x);\n    }\n    if (to == 0)\n        root = x; //! very important\n}\nint build(int l, int r, int fa)\n{\n    if (l > r)\n        return 0;\n    int mid = (l + r) >> 1;\n    int now = ++wz;\n    tree[now].fa = fa;\n    tree[now].cnt = 1;\n    tree[now].val = ori[mid];\n    tree[now].sz = 1;\n    tree[now].son[0] = build(l, mid - 1, now);\n    tree[now].son[1] = build(mid + 1, r, now);\n    update(now);\n    return now;\n}\nint find_val(int x)\n{\n    int now = root;\n    while (1)\n    {\n        push_down(now);\n        if (x <= tree[tree[now].son[0]].sz)\n            now = tree[now].son[0];\n        else\n        {\n            x -= tree[tree[now].son[0]].sz + 1;\n            if (x == 0)\n                return now;\n            now = tree[now].son[1];\n        }\n    }\n}\nvoid reverse(int x, int y)\n{\n    int l = find_val(x - 1), r = find_val(y + 1);\n    splay(l, 0);\n    splay(r, l);\n    int pos = tree[root].son[1];\n    pos = tree[pos].son[0];\n    tree[pos].tag ^= 1;\n}\nvoid show(int now)\n{\n    push_down(now); //* dfs\n    if (tree[now].son[0])\n        show(tree[now].son[0]);\n    if (tree[now].val != -inf && tree[now].val != inf)\n        cout << tree[now].val << ' ';\n    if (tree[now].son[1])\n        show(tree[now].son[1]);\n}\nsigned main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    std::cout.tie(0);\n    int n, m, x, y;\n    cin >> n >> m;\n    ori[1] = -inf, ori[n + 2] = inf;\n    for (int i = 1; i <= n; ++i)\n        ori[i + 1] = i;\n    root = build(1, n + 2, 0);\n    for (int i = 1; i <= m; i++)\n    {\n        cin >> x >> y;\n        reverse(x + 1, y + 1);\n    }\n    show(root);\n    return 0;\n}\n```\n\n由于是序列操作，不需要逐个插入元素，类似线段树的建树过程即可。\n\n","tags":["数据结构"]},{"title":"Splay（伸展树）","url":"/2020/08/21/Splay/","content":"\n# 简介：\n\n本来这是一个月前写的文章，但是系统出毛病了没保存上，只好重新写一下了，也算是加深印象吧。网上关于splay和treap的博客非常多，但是代码实现一些人用的是指针，一些人的node不保存父亲结点，还有一些代码风格非常鬼畜，所以还是需要存一份适合自己的模板和教程。\n\n“平衡二叉树还有很多其他的变种……或许其中最有趣的要数 Sleator 和 Tarjan 提出的‘伸展树’，它可以‘自我调整’。伸展树不需要明确的平衡条件（如颜色）来维持平衡。替代的是，每次存取时‘伸展操作’（涉及旋转）在树内执行。在一棵有 n 个结点的树上，每个操作的摊还代价是 $O(\\lg n)$。”——《算法导论》\n\n<!--more-->\n\n# 基本性质：\n\n与AVL树类似，splay维持平衡也需要多种旋转的组合。这里将左旋操作称为Zag，右旋操作称为Zig。\n\n正如上文所说，splay没有明确的平衡条件，取而代之的是其特有的splay（伸展）操作：每次访问splay的时候都进行一次该操作，使得目标结点旋转到根节点。在多次伸展下，树的形态会自然趋向于平衡，所以很多人说“有事没事splay一下”就是这个道理。\n\n# 具体实现：\n\n## 1、准备工作\n\n### 存储结构\n\n```c++\nstruct node\n{\n    int v;//值\n    int fa;//父亲\n    int ch[2];//左右儿子\n    int size;//结点大小\n    int sum;//子树大小\n} tree[N];\n```\n\n非常普通，没什么好说的。\n\n## 2、重要功能\n\n### update\n\n更新结点大小\n\n```c++\ninline void update(int x)\n{\n    tree[x].sum = tree[tree[x].ch[0]].sum + tree[tree[x].ch[1]].sum + tree[x].size;\n}\n```\n\n### 确定自己的位置\n\n```c++\ninline bool findd(int x)\n{\n    return tree[tree[x].fa].ch[0] == x ? 0 : 1;\n}\n```\n\n是左儿子返回0，右儿子返回1。\n\n### connect\n\n```c++\ninline void connect(int x, int fa, int son)\n{\n    tree[x].fa = fa;\n    tree[fa].ch[son] = x;\n}\n```\n\n重新确立父子关系\n\n### rotate\n\n搬一下写Treap的文章里的图\n\n![200719rotate.png](https://i.loli.net/2020/07/19/KX6iGy8ZTHAD4pY.png)\n\n由于splay是要把结点旋转上去，所以只要知道自己的位置就自动确定了是左旋还是右旋，那么只需要一个函数就可以完成了：\n\n```c++\ninline void rotate(int x)\n{\n    int Y = tree[x].fa;\n    int R = tree[Y].fa;\n    int Yson = findd(x);\n    int Rson = findd(Y);\n    int B = tree[x].ch[Yson ^ 1];\n    connect(B, Y, Yson);\n    connect(Y, x, Yson ^ 1);\n    connect(x, R, Rson);\n    update(Y), update(x);\n}\n```\n\n### splay\n\n最重要的操作，将这个结点旋转到根部：\n\n1. 如果父亲是根，直接旋转一次\n2. 如果自己和父亲、祖父在同一条直线上，先把父亲转上去（自己也会上去），再把自己转上去，如图：\n\n![200721zigzig.png](https://i.loli.net/2020/08/04/swcuRnGSrO8I4yE.png)\n\n![200721zagzag.png](https://i.loli.net/2020/08/04/ztgJxXUDCcsQB3S.png)\n\n3. 如果自己和父亲、祖父不在同一条直线上，把自己转上去两次，如图：\n\n![200721zagzig.png](https://i.loli.net/2020/08/04/czBh2THp7KQIlAk.png)\n\n![200721zigzag.png](https://i.loli.net/2020/08/04/jDClxS6BTztiXLu.png)\n\n显然splay操作只会使树变得更平衡。\n\n```c++\ninline void splay(int x, int to)\n{\n    to = tree[to].fa;\n    while (tree[x].fa != to)\n    {\n        int y = tree[x].fa;\n        if (tree[y].fa == to)\n            rotate(x);\n        else if (findd(x) == findd(y))\n            rotate(y), rotate(x);\n        else\n            rotate(x), rotate(x);\n    }\n}\n```\n\n### 插入\n\n利用BST的性质找到插入位置，然后splay上去。\n\n```c++\ninline int newpoint(int v, int fa)\n{\n    tree[++tot].fa = fa;\n    tree[tot].v = v;\n    tree[tot].sum = tree[tot].size = 1;\n    return tot;\n}\ninline void ins(int x)\n{\n    int cur = tree[0].ch[1];\n    if (tree[0].ch[1] == 0)\n    {\n        newpoint(x, 0);\n        tree[0].ch[1] = tot;\n    }\n    else\n    {\n        while (1)\n        {\n            ++tree[cur].sum;\n            if (tree[cur].v == x)\n            {\n                ++tree[cur].size;\n                splay(cur, tree[0].ch[1]);\n                return;\n            }\n            int nxt = x < tree[cur].v ? 0 : 1;\n            if (!tree[cur].ch[nxt])\n            {\n                int p = newpoint(x, cur);\n                tree[cur].ch[nxt] = p;\n                splay(p, tree[0].ch[1]);\n                return;\n            }\n            cur = tree[cur].ch[nxt];\n        }\n    }\n}\n```\n\n\n\n### 删除\n\n先找到这个值，这个时候已经splay到根了，删除就比较方便。\n\n```c++\ninline int find(int v)\n{\n    int cur = tree[0].ch[1];\n    while (1)\n    {\n        if (tree[cur].v == v)\n        {\n            splay(cur, tree[0].ch[1]);\n            return cur;\n        }\n        int nxt = v < tree[cur].v ? 0 : 1;\n        if (!tree[cur].ch[nxt])\n            return 0;\n        cur = tree[cur].ch[nxt];\n    }\n}\ninline void del(int x)\n{\n    int pos = find(x);\n    if (!pos)\n        return;\n    if (tree[pos].size > 1)\n    {\n        --tree[pos].size;\n        --tree[pos].sum;\n    }\n    else\n    {\n        if (!tree[pos].ch[0] && !tree[pos].ch[1])\n            tree[0].ch[1] = 0;\n        else if (!tree[pos].ch[0])\n        {\n            tree[0].ch[1] = tree[pos].ch[1];\n            tree[tree[0].ch[1]].fa = 0;\n        }\n        else\n        {\n            int left = tree[pos].ch[0];\n            while (tree[left].ch[1])\n                left = tree[left].ch[1];\n            splay(left, tree[pos].ch[0]);\n            connect(tree[pos].ch[1], left, 1);\n            connect(left, 0, 1);\n            update(left);\n        }\n    }\n}\n```\n\n\n\n### 根据值查询排名\n\n与删除类似，由于会splay到最上面，计算左子树大小就好了。\n\n```c++\ninline int get_rank(int v)\n{\n    int pos = find(v);\n    return tree[tree[pos].ch[0]].sum + 1;\n}\n```\n\n\n\n### 根据排名查找值\n\n与AVL树类似\n\n```c++\ninline int get_val(int x)\n{\n    int cur = tree[0].ch[1];\n    while (1)\n    {\n        int used = tree[cur].sum - tree[tree[cur].ch[1]].sum;\n        if (x > tree[tree[cur].ch[0]].sum && x <= used)\n        {\n            splay(cur, tree[0].ch[1]);\n            return tree[cur].v;\n        }\n        if (x < used)\n            cur = tree[cur].ch[0];\n        else\n            x -= used, cur = tree[cur].ch[1];\n    }\n}\n```\n\n\n\n### 查询前驱/后继\n\n唯二不需要伸展的操作。由于是数组中建的树，实现难度远远低于AVL树。\n\n```c++\ninline int prev(int v)\n{\n    int cur = tree[0].ch[1];\n    int ans = -inf;\n    while (cur)\n    {\n        if (tree[cur].v < v && tree[cur].v > ans)\n            ans = tree[cur].v;\n        if (v > tree[cur].v)\n            cur = tree[cur].ch[1];\n        else\n            cur = tree[cur].ch[0];\n    }\n    return ans;\n}\ninline int succ(int v)\n{\n    int cur = tree[0].ch[1];\n    int ans = inf;\n    while (cur)\n    {\n        if (tree[cur].v > v && tree[cur].v < ans)\n            ans = tree[cur].v;\n        if (v < tree[cur].v)\n            cur = tree[cur].ch[0];\n        else\n            cur = tree[cur].ch[1];\n    }\n    return ans;\n}\n```\n\n\n\n## 3、完整代码（以[P3369](https://www.luogu.com.cn/problem/P3369)为例）\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\n\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 1e5 + 9;\ntemplate <typename T>\ninline void write(T x)\n{\n    if (x == 0)\n        putchar('0');\n    if (x < 0)\n        x = -x, putchar('-');\n    static int sta[36];\n    int tot = 0;\n    while (x > 0)\n        sta[tot++] = x % 10, x /= 10;\n    while (tot)\n        putchar(sta[--tot] + 48);\n}\nstruct node\n{\n    int v;\n    int fa;\n    int ch[2];\n    int size;\n    int sum;\n} tree[maxn];\nint tot;\ninline void update(int x)\n{\n    tree[x].sum = tree[tree[x].ch[0]].sum + tree[tree[x].ch[1]].sum + tree[x].size;\n}\ninline bool findd(int x)\n{\n    return tree[tree[x].fa].ch[0] == x ? 0 : 1;\n}\ninline void connect(int x, int fa, int son)\n{\n    tree[x].fa = fa;\n    tree[fa].ch[son] = x;\n}\ninline void rotate(int x)\n{\n    int Y = tree[x].fa;\n    int R = tree[Y].fa;\n    int Yson = findd(x);\n    int Rson = findd(Y);\n    int B = tree[x].ch[Yson ^ 1];\n    connect(B, Y, Yson);\n    connect(Y, x, Yson ^ 1);\n    connect(x, R, Rson);\n    update(Y), update(x);\n}\ninline void splay(int x, int to)\n{\n    to = tree[to].fa;\n    while (tree[x].fa != to)\n    {\n        int y = tree[x].fa;\n        if (tree[y].fa == to)\n            rotate(x);\n        else if (findd(x) == findd(y))\n            rotate(y), rotate(x);\n        else\n            rotate(x), rotate(x);\n    }\n}\ninline int newpoint(int v, int fa)\n{\n    tree[++tot].fa = fa;\n    tree[tot].v = v;\n    tree[tot].sum = tree[tot].size = 1;\n    return tot;\n}\ninline void ins(int x)\n{\n    int cur = tree[0].ch[1];\n    if (tree[0].ch[1] == 0)\n    {\n        newpoint(x, 0);\n        tree[0].ch[1] = tot;\n    }\n    else\n    {\n        while (1)\n        {\n            ++tree[cur].sum;\n            if (tree[cur].v == x)\n            {\n                ++tree[cur].size;\n                splay(cur, tree[0].ch[1]);\n                return;\n            }\n            int nxt = x < tree[cur].v ? 0 : 1;\n            if (!tree[cur].ch[nxt])\n            {\n                int p = newpoint(x, cur);\n                tree[cur].ch[nxt] = p;\n                splay(p, tree[0].ch[1]);\n                return;\n            }\n            cur = tree[cur].ch[nxt];\n        }\n    }\n}\ninline int find(int v)\n{\n    int cur = tree[0].ch[1];\n    while (1)\n    {\n        if (tree[cur].v == v)\n        {\n            splay(cur, tree[0].ch[1]);\n            return cur;\n        }\n        int nxt = v < tree[cur].v ? 0 : 1;\n        if (!tree[cur].ch[nxt])\n            return 0;\n        cur = tree[cur].ch[nxt];\n    }\n}\ninline void del(int x)\n{\n    int pos = find(x);\n    if (!pos)\n        return;\n    if (tree[pos].size > 1)\n    {\n        --tree[pos].size;\n        --tree[pos].sum;\n    }\n    else\n    {\n        if (!tree[pos].ch[0] && !tree[pos].ch[1])\n            tree[0].ch[1] = 0;\n        else if (!tree[pos].ch[0])\n        {\n            tree[0].ch[1] = tree[pos].ch[1];\n            tree[tree[0].ch[1]].fa = 0;\n        }\n        else\n        {\n            int left = tree[pos].ch[0];\n            while (tree[left].ch[1])\n                left = tree[left].ch[1];\n            splay(left, tree[pos].ch[0]);\n            connect(tree[pos].ch[1], left, 1);\n            connect(left, 0, 1);\n            update(left);\n        }\n    }\n}\ninline int get_rank(int v)\n{\n    int pos = find(v);\n    return tree[tree[pos].ch[0]].sum + 1;\n}\ninline int get_val(int x)\n{\n    int cur = tree[0].ch[1];\n    while (1)\n    {\n        int used = tree[cur].sum - tree[tree[cur].ch[1]].sum;\n        if (x > tree[tree[cur].ch[0]].sum && x <= used)\n        {\n            splay(cur, tree[0].ch[1]);\n            return tree[cur].v;\n        }\n        if (x < used)\n            cur = tree[cur].ch[0];\n        else\n            x -= used, cur = tree[cur].ch[1];\n    }\n}\ninline int prev(int v)\n{\n    int cur = tree[0].ch[1];\n    int ans = -inf;\n    while (cur)\n    {\n        if (tree[cur].v < v && tree[cur].v > ans)\n            ans = tree[cur].v;\n        if (v > tree[cur].v)\n            cur = tree[cur].ch[1];\n        else\n            cur = tree[cur].ch[0];\n    }\n    return ans;\n}\ninline int succ(int v)\n{\n    int cur = tree[0].ch[1];\n    int ans = inf;\n    while (cur)\n    {\n        if (tree[cur].v > v && tree[cur].v < ans)\n            ans = tree[cur].v;\n        if (v < tree[cur].v)\n            cur = tree[cur].ch[0];\n        else\n            cur = tree[cur].ch[1];\n    }\n    return ans;\n}\nint main()\n{\n    int n;\n    read(n);\n    while (n--)\n    {\n        int op, x;\n        read(op), read(x);\n        if (op == 1)\n            ins(x);\n        else if (op == 2)\n            del(x);\n        else if (op == 3)\n        {\n            write(get_rank(x));\n            putchar('\\n');\n        }\n        else if (op == 4)\n        {\n            write(get_val(x));\n            putchar('\\n');\n        }\n        else if (op == 5)\n        {\n            write(prev(x));\n            putchar('\\n');\n        }\n        else\n        {\n            write(succ(x));\n            putchar('\\n');\n        }\n    }\n    return 0;\n}\n\n```\n\n平衡树最基本的操作就都实现了。splay的复杂度是均摊 $O(\\log n)$ 的，不太适合可持久化。\n\n\n\n# 后记\n\n以后还需要写一下splay处理序列问题。\n\n\n\n![83758942](https://i.loli.net/2020/08/20/fEji9Aco5JlFSeL.jpg)\n\n\n\nFGO    アナスタシア・ニコラエヴナ・ロマノヴァ","tags":["数据结构"]},{"title":"非递归式线段树","url":"/2020/08/19/zkw_Segment_Tree/","content":"\n\n\n递归式线段树非常好用，但是常数大，极端情况下可能会被卡掉。非递归式线段树更像是树状数组，常数小，代码也短，当然功能也稍微弱了一点。最近看了几遍zkw的PPT，了解了一下非递归式线段树，感觉对线段树的理解又深了一点。\n\n<!--more-->\n\n先来观察一下这个图：\n\n![完全二叉树](https://i.loli.net/2020/08/19/r8dn2KQy9zm1Ytx.png)\n\n上面是一棵完全二叉树，结点序号用红色标出，黑色的是序号的二进制表示。我们可以发现一个规律：父亲结点的二进制表示是两个儿子的二进制表示的前缀。普通的递归式线段树写法也正是利用了这个性质，所以有 `tree[p]=tree[p<<1]+tree[p<<1|1]` 的写法。\n\n所以有人认为线段树和Trie是一个东西，其实也是有道理的。只不过平时常用的Trie不是二叉树，而是26叉树罢了。\n\n那么递归写法的 `build` 和 `update` 函数都是递归到底部后 `push_up`，如果不采用递归我们就需要更充分利用上面说的前缀性质：直接将数据按顺序存在叶子里面，然后不断除2往上跳就好了。\n\n如果这样的就必须要是一棵完全二叉树，所以空间要足够大，直接和普通的一样四倍就没问题了。\n\n具体实现以后再写。\n\n用的是标记永久化。\n\n目前看来zkw线段树可以像递归式线段树一样做到：\n\n- 单点修改\n- 区间修改（加上一个数）\n- 单点查询\n- 区间查询（和、最值等）\n\n但是似乎不能做到：\n\n- 维护两种运算，如 [这道题](https://www.luogu.com.cn/problem/P3373)\n\n搬个模板：\n\n```c++\n#include <iostream>\n#include<cstdio>\n#define ll long long\nusing namespace std;\nint n,m;\nll a[400005],mark[400005];\nll bit,lb;\ninline int getlong(int k)//查询结点第几层\n{\n    int i=0;\n    while(k>>=1)i++;\n    return i;\n}\ninline int put(int k,int t)//修改\n{\n    int tmp=1<<(lb-getlong(k));\n    while(k>>=1)\n        a[k]+=t*tmp;\n    return 0;\n}\ninline ll get1(ll k)//查询\n{\n    ll tmp=1<<(lb-getlong(k));//tmp有多少叶节点就加几倍\n    ll re=a[k]+mark[k]*tmp;\n    do\n    {\n        k>>=1;\n        re+=mark[k]*tmp;\n    }while(k);\n    return re;\n}\ninline ll get(ll s,ll t)//区间查询\n{\n    ll re=0;\n    for(s=s+bit-1,t=t+bit+1;s^t^1;s>>=1,t>>=1)//s-1和t+1变开区间，s+bit和t+bit到对应叶节点\n    {\n        if(!(s&1))\n            re+=get1(s^1);//*(1<<(lb-getlong(s)));\n        if(t&1)\n            re+=get1(t^1);//*(1<<(lb-getlong(t)));\n    }\n    return re;\n}\ninline int change(ll s,ll t,ll k)//区间修改\n{\n    for(s=s+bit-1,t=t+bit+1;s^t^1;s>>=1,t>>=1)\n    {\n        //int tmp;\n        if(!(s&1))\n        {\n            mark[s^1]+=k;//*(1<<(lb-getlong(s)));\n            put(s^1,k);\n        }\n        if(t&1)\n        {\n            mark[t^1]+=k;//*(1<<(lb-getlong(t)));\n            put(t^1,k);\n        }\n    }\n    return 0;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin>>n>>m;\n    for(bit=1;bit-2<n;bit<<=1);\n    lb=getlong(bit);\n    for(int i=bit+1;i<=bit+n;i++)\n        cin>>a[i];\n    for(int i=bit-1;i;i--)\n    {\n        a[i]=a[i<<1]+a[i<<1|1];//( i*2==i<<1) , (i*2+1==i<<1|1)\n        //a[i<<1]-=a[i];a[i<<1|1]-=a[i];\n    }\n    for(int i=1;i<=m;i++)\n    {\n        ll aa,b,c,d;\n        cin>>aa;\n        if(aa==2)\n        {\n            cin>>b>>c;//cout<<b<<' '<<c<<' '<<get(b,c)<<endl;\n            cout<<get(b,c)<<endl;\n            for(int i=1;i<=n+bit;i++)cout<<get1(i)<<' ';cout<<endl;\n        }\n        else\n        {\n            cin>>b>>c>>d;change(b,c,d);\n            //cout<<b<<' '<<c<<' '<<d<<endl;\n            for(int i=1;i<=n+bit;i++)cout<<get1(i)<<' ';cout<<endl;\n        }\n    }\n\n    return 0;\n}\n```\n\n[PPT链接](https://wenku.baidu.com/view/0c1bbba40029bd64783e2cca.html)\n\n顺便放三篇有趣的文章以后看看：\n\n- [JAVA实现线段树](https://www.luogu.com.cn/blog/AldonahZero/solution-p3372)\n- [试图用珂朵莉树水过线段树](https://www.luogu.com.cn/blog/aaronlee/solution-p3372-1)\n- [指令集优化暴力](https://www.luogu.com.cn/blog/yurzhang/solution-p3372)\n\n![63770148](https://i.loli.net/2020/08/19/YKg7CRX2eQn648a.jpg)\n\n难得看到有人画兰朵露可","tags":["数据结构"]},{"title":"经验总结（更新中）","url":"/2020/08/19/Tips/","content":"\n\n在这里总结一些踩过的坑以及一些小技巧。\n\n\n\n<!--more-->\n\n-  容易犯错的地方（fst原因大全）\n   1. 数组大小有时候会是 $2\\times 10^5$ 甚至是 $5\\times 10^5$，不要想当然直接开 `maxn=1e5+9`，运气好的话在pretest中RE了还能查出来，要是运气不好过了pretest那就等着fst吧\n   2. 初始化的时候尽量写 `maxx=-inf,minn=inf` 这样的极端数据，无脑初始化为 `0` 是一个坏习惯\n   3. 不开 `long long` 见祖宗，被坑了无数次了\n   4. `double` 的精度并没有想象的那么高，用的时候要小心\n   5. 不要用 `std::fill` 初始化二维数组，还不如 `memset`，实在不行就循环赋值\n-  小优化\n   \n   1.  读01矩阵这样的东西用 `scanf(\"%c\",&x)` 比用 `scanf(\"%1d\",&x)` 稍微快一点\n-  一些经验\n   1.  指针和宏定义稍有不慎就会出奇怪的毛病且非常难以调试，用不好就不要用\n   2.  不要吃饱了撑着写一堆 `register` 变量或者位运算，有时候编译器自己会优化的，多用 `register` 并不一定使程序变快，甚至可能会负优化；多用位运算也不一定会变快，出错的概率倒是大大增加\n   3.  想不出做法的时候试试暴力，有奇效\n   4.  不只是序列可以分块做，图也是可以分块的\n   5.  单调栈非常有用（被这东西坑了两次了）\n   6.  如果觉得需要使用一些比较复杂的数据结构，最好再分析一遍题意，否则很可能把简单问题复杂化\n- 容易忘记的小知识点\n\n   1. 斐波那契数列通项公式 $\\large f_n=\\dfrac{(\\frac{1+\\sqrt 5}{2})^n-(\\frac{1-\\sqrt 5}{2})^n}{\\sqrt 5}$\n\n   2. 在只含加法和乘法的式子中，如果最后的运算结果需要对p取模，那么可以在运算过程中随便取模\n-  其他\n   1.  能不用Java就不用Java，标准输入输出慢的要死，即便用快读快写耗时依然是 `scanf` 的 $10$ 倍！并且Java的快读快写非常难写。\n\n\n\n","tags":["其它"]},{"title":"树链剖分","url":"/2020/08/18/path_decomposition/","content":"\n\n\n树链剖分，就是把一棵树分成一些链，然后就可以用数据结构来维护。\n\n\n\n<!--more-->\n\n# 重链剖分\n\n## DFS序\n\n在对一棵树进行DFS的时候每经过一个新的结点就记录它的编号，这样就可以得到一个排列，称为DFS序。\n\n由于是用DFS的方式遍历这棵树，我们可以得到这样的性质：\n\n- 每个点的子树对应DFS序上一段连续的区间\n  - 若进入点 $x$ 的时间是 $DFS_x$，离开点 $x$ 的时间是 $DFS_x+size_x-1$\n\n那么可以用线段树之类的东西来维护这个子树，可以做到 $O(\\log n)$ 复杂度完成：\n\n- 将一个点的子树所有点权加上一个值\n- 查询一个点的子树内点权最小值\n- 查询一个点的子树内的点权和\n\n如果没有DFS序为了完成上面的操作可能需要这样：每个结点维护点权、子树大小、子树点权和、子树点权最小值以及一个lazy-tag。似乎也是可以做的但是比较麻烦。\n\n## 轻重链\n\n如果我们在上面的基础上需要支持以下两个操作：\n\n- 修改单点点权\n- 查询两点路径上最小点权\n\n第二个操作用上面的原始做法是很难完成的，因为区间查询很难做到。\n\n所以需要把树上问题转化成序列问题。先引入**轻链**和**重链**的概念：\n\n对于**非叶结点** $x$，设其**最大的子树**对应的**子结点**为 $y$，则将边 $(x,y)$ 称为重边，其余的边为轻边。\n\n重边形成的链即为重链。\n\n那么可以得到以下几条性质：\n\n- 如果边 $(x,y)$ 是轻边，$size_x\\ge2size_y$ \n  - 显而易见，如果是轻边说明至少有两个子树，并且 $y$ 不是唯一最大的子树\n- 重链的起点是根结点或轻边的终点（轻儿子）\n- 一个点到根的路径上，轻边数量的级别是 $O(\\log n)$ \n- 重链的条数是 $O(\\log n)$ \n- 可以将树上的一条路径划分为 $O(\\log n)$ 条重链\n\n## 实现\n\n首先当然是存图，现在觉得链式前向星还是挺好用的\n\n```c++\nint head[maxn], to[maxn], nxt[maxn], tot = 0;\ninline void add(int u, int v)\n{\n    to[++tot] = v;\n    nxt[tot] = head[u];\n    head[u] = tot;\n}\n```\n\n先进行一次DFS，求出每个结点的子树大小和重儿子\n\n```c++\nint son[maxn], id[maxn], fa[maxn], cnt, dep[maxn], sz[maxn], top[maxn];\nint w[maxn], wt[maxn];\nvoid dfs1(int p, int f, int d)\n{\n    dep[p] = d;\n    fa[p] = f;\n    sz[p] = 1;\n    int maxson = -1;\n    for (int i = head[p]; i; i = nxt[i])\n    {\n        int y = to[i];\n        if (y == f)\n            continue;\n        dfs1(y, p, d + 1);\n        sz[p] += sz[y];\n        if (sz[y] > maxson)//son数组放重儿子\n            son[p] = y, maxson = sz[y];\n    }\n}\n```\n\n再进行一次DFS记录DFS序，到一个点时先访问重儿子再访问其余儿子\n\n```c++\nvoid dfs2(int p, int topf)\n{\n    id[p] = ++cnt;\n    wt[cnt] = w[p];\n    top[p] = topf;\n    if (son[p] == 0)\n        return;\n    dfs2(son[p], topf);\n    for (int i = head[p]; i; i = nxt[i])\n    {\n        int y = to[i];\n        if (y == fa[p] || y == son[p])\n            continue;\n        dfs2(y, y);\n    }\n}\n```\n\n\n\n   -  对于一条重链，链上的点在DFS 序中一定相邻\n   -  一条重链对应DFS 序中一段区间\n\n\n\n做好准备工作以后放进线段树。\n\n区间和查询：\n\n```c++\nint query(int l, int r)\n{\n    int ans = 0;\n    while (top[l] != top[r])\n    {\n        if (dep[top[l]] < dep[top[r]])\n            swap(l, r);\n        ans += tree.query(1, 1, n, id[top[l]], id[l]);\n        ans %= mod;\n        l = fa[top[l]];\n    }\n    if (dep[l] > dep[r])\n        swap(l, r);\n    ans += tree.query(1, 1, n, id[l], id[r]);\n    return ans % mod;\n}\n```\n\n区间修改：\n\n```c++\nvoid update(int l, int r, int k)\n{\n    k %= mod;\n    while (top[l] != top[r])\n    {\n        if (dep[top[l]] < dep[top[r]])\n            swap(l, r);\n        tree.update(1, 1, n, id[top[l]], id[l], k);\n        l = fa[top[l]];\n    }\n    if (dep[l] > dep[r])\n        swap(l, r);\n    tree.update(1, 1, n, id[l], id[r], k);\n}\n```\n\n子树和查询：\n\n```c++\ninline int qson(int p)\n{\n    return tree.query(1, 1, n, id[p], id[p] + sz[p] - 1);\n}\n```\n\n子树修改：\n\n```c++\ninline void upson(int p, int k)\n{\n    tree.update(1, 1, n, id[p], id[p] + sz[p] - 1, k);\n}\n```\n\n树链剖分代码写错极难调试，有时候出一点小错误甚至也能过数据不强的测试点，非常难受。\n\n操作细节部分日后再补，今天就先把这个能用的模板搞出来：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\n\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 2e5 + 9;\n\nint n, m, root, mod;\nint head[maxn], to[maxn], nxt[maxn], tot = 0;\ninline void add(int u, int v)\n{\n    to[++tot] = v;\n    nxt[tot] = head[u];\n    head[u] = tot;\n}\n\nint son[maxn], id[maxn], fa[maxn], cnt, dep[maxn], sz[maxn], top[maxn];\nint w[maxn], wt[maxn];\n\nstruct segtree\n{\n    int tree[maxn << 2], tag[maxn << 2];\n    void push_up(int p)\n    {\n        tree[p] = (tree[p << 1] + tree[p << 1 | 1]) % mod;\n    }\n    void build(int p, int l, int r)\n    {\n        tag[p] = 0;\n        if (l == r)\n        {\n            tree[p] = wt[l] % mod;\n            return;\n        }\n        int mid = (l + r) >> 1;\n        build(p << 1, l, mid);\n        build(p << 1 | 1, mid + 1, r);\n        push_up(p);\n    }\n    void flag(int p, int l, int r, int k)\n    {\n        tag[p] = (tag[p] + k) % mod;\n        tree[p] += k * (r - l + 1);\n        tree[p] %= mod;\n    }\n    void push_down(int p, int l, int r)\n    {\n        int mid = (l + r) >> 1;\n        flag(p << 1, l, mid, tag[p]);\n        flag(p << 1 | 1, mid + 1, r, tag[p]);\n        tag[p] = 0;\n    }\n    void update(int p, int l, int r, int ul, int ur, int k)\n    {\n        if (ul <= l && ur >= r)\n        {\n            tree[p] += k * (r - l + 1);\n            tag[p] += k;\n            tree[p] %= mod;\n            tag[p] %= mod;\n            return;\n        }\n        push_down(p, l, r);\n        int mid = (l + r) >> 1;\n        if (ul <= mid)\n            update(p << 1, l, mid, ul, ur, k);\n        if (ur > mid)\n            update(p << 1 | 1, mid + 1, r, ul, ur, k);\n        push_up(p);\n    }\n    int query(int p, int l, int r, int qx, int qy)\n    {\n        if (qx <= l && qy >= r)\n            return tree[p];\n        int ans = 0, mid = (l + r) >> 1;\n        push_down(p, l, r);\n        if (qx <= mid)\n            ans += query(p << 1, l, mid, qx, qy), ans %= mod;\n        if (qy > mid)\n            ans += query(p << 1 | 1, mid + 1, r, qx, qy), ans %= mod;\n        return ans;\n    }\n};\nsegtree tree;\n\nvoid dfs1(int p, int f, int d)\n{\n    dep[p] = d;\n    fa[p] = f;\n    sz[p] = 1;\n    int maxson = -1;\n    for (int i = head[p]; i; i = nxt[i])\n    {\n        int y = to[i];\n        if (y == f)\n            continue;\n        dfs1(y, p, d + 1);\n        sz[p] += sz[y];\n        if (sz[y] > maxson)\n            son[p] = y, maxson = sz[y];\n    }\n}\n\nvoid dfs2(int p, int topf)\n{\n    id[p] = ++cnt;\n    wt[cnt] = w[p];\n    top[p] = topf;\n    if (son[p] == 0)\n        return;\n    dfs2(son[p], topf);\n    for (int i = head[p]; i; i = nxt[i])\n    {\n        int y = to[i];\n        if (y == fa[p] || y == son[p])\n            continue;\n        dfs2(y, y);\n    }\n}\n\nint query(int l, int r)\n{\n    int ans = 0;\n    while (top[l] != top[r])\n    {\n        if (dep[top[l]] < dep[top[r]])\n            swap(l, r);\n        ans += tree.query(1, 1, n, id[top[l]], id[l]);\n        ans %= mod;\n        l = fa[top[l]];\n    }\n    if (dep[l] > dep[r])\n        swap(l, r);\n    ans += tree.query(1, 1, n, id[l], id[r]);\n    return ans % mod;\n}\n\nvoid update(int l, int r, int k)\n{\n    k %= mod;\n    while (top[l] != top[r])\n    {\n        if (dep[top[l]] < dep[top[r]])\n            swap(l, r);\n        tree.update(1, 1, n, id[top[l]], id[l], k);\n        l = fa[top[l]];\n    }\n    if (dep[l] > dep[r])\n        swap(l, r);\n    tree.update(1, 1, n, id[l], id[r], k);\n}\n\ninline int qson(int p)\n{\n    return tree.query(1, 1, n, id[p], id[p] + sz[p] - 1);\n}\n\ninline void upson(int p, int k)\n{\n    tree.update(1, 1, n, id[p], id[p] + sz[p] - 1, k);\n}\n\nsigned main()\n{\n    read(n), read(m), read(root), read(mod);\n    int op, u, v, k;\n    for (int i = 1; i <= n; ++i)\n        read(w[i]);\n    for (int i = 1; i < n; ++i)\n    {\n        read(u), read(v);\n        add(u, v), add(v, u);\n    }\n    dfs1(root, 0, 1);\n    dfs2(root, root);\n    tree.build(1, 1, n);\n    while (m--)\n    {\n        read(op);\n        if (op == 1)\n        {\n            read(u), read(v), read(k);\n            update(u, v, k);\n        }\n        else if (op == 2)\n        {\n            read(u), read(v);\n            cout << query(u, v) << '\\n';\n        }\n        else if (op == 3)\n        {\n            read(u), read(k);\n            upson(u, k);\n        }\n        else\n        {\n            read(u);\n            cout << qson(u) << '\\n';\n        }\n    }\n    return 0;\n}\n```\n\n其实树链剖分的函数也可以封装进结构体，但是代码耗时增加了将近30%，感觉有点亏。\n\n# 长链剖分\n\n重链剖分选择的是子树大小最大的儿子，长链剖分选择的是子树高度最大的儿子。一些情况下这两种是一样的。长链剖分的复杂度在很多时候并没有重链剖分优秀，因此比较少见，具体内容可以在[HaHaTa的这篇博客](http://hahata.org/193/)中了解。\n\n![83686942](https://i.loli.net/2020/08/19/VCHMpkNei5nmBI4.jpg)\n\n雪花ラミィ\n\n","tags":["图论"]},{"title":"左偏树","url":"/2020/08/16/Leftist_Tree/","content":"\n\n\n普通二叉堆支持 $O(\\log n)$ 插入，$O(\\log n)$ 删除堆顶，$O(1)$ 查询堆顶，但美中不足的是不支持合并。左偏树是一种可并堆，除了满足上面的操作外还可以做到 $O(\\log n)$ 合并。\n\n<!--more-->\n\n## 性质\n\n一棵左偏树满足以下几条性质：（以小根堆为例）\n\n- 是一棵二叉树\n- 每个结点维护两个值，分别是数据大小 $val$ 和到子树中最近叶子结点的距离 $dis$\n  - 所以叶子结点的 $dis$ 必定为 $0$\n- 父亲结点的 $val$ 必然小于其左右儿子的 $val$（堆性质）\n- 左儿子的 $dis$ 不小于右儿子的 $dis$（左偏性质）\n  - 父亲结点的 $dis$ 必定比右儿子的 $dis$ 大 $1$\n  - 如果一个结点没有左儿子，那它一定是叶子结点\n\n根据上面的性质可以得到一个推论：结点数为 $n$ 的左偏树中最大的 $dis$ 不超过 $\\log(n+1)-1$，极端情况是左偏树成为一棵满二叉树。这个推论的逆命题也是成立的，如果最大 $dis$ 为 $k$，那么至少有 $2^{k+1}-1$ 个结点。\n\n## 合并\n\n先看左偏树最核心的 `merge` 操作：（以小根堆为例）\n\n首先，如果有一个待合并的左偏树是空的，那么返回另一个就好了。\n\n然后考虑一般情况，假设两棵左偏树分别是A与B，默认A的根结点键值小于B的（如果不是就swap一下）。那么我们取A的根为新树的根，然后合并A的右子树和B。\n\n合并了A的右子树和B后如果左偏性质被破坏了，那么就swap左右子树，并更新父亲的 $dis$。\n\n一直这样下去，就可以把两棵树合并了，根据上面的推论可以得出最坏情况的复杂度是 $O(\\log n_A +\\log n_B)$，非常优秀。\n\n## 其他操作\n\n太晚了明天再写\n\n## 实现\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\n\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 1e5 + 9;\n\nstruct Tree\n{\n    int dis, val, root, ls, rs;\n};\n\nstruct Leftist_Tree\n{\n    Tree lt[maxn];\n    int merge(int x, int y)\n    {\n        if (!x || !y)\n            return x + y;\n        if (lt[x].val > lt[y].val || (lt[x].val == lt[y].val && x > y))\n            swap(x, y);\n        lt[x].rs = merge(lt[x].rs, y);\n        if (lt[lt[x].ls].dis < lt[lt[x].rs].dis)\n            swap(lt[x].ls, lt[x].rs);\n        lt[lt[x].ls].root = x;\n        lt[lt[x].rs].root = x;\n        lt[x].root = x;\n        lt[x].dis = lt[lt[x].rs].dis + 1;\n        return x; //root\n    }\n    int find(int x)\n    {\n        return lt[x].root == x ? x : lt[x].root = find(lt[x].root);\n    }\n    int top(int x)\n    {\n        return lt[x].val;\n    }\n    void pop(int x)\n    {\n        lt[x].val = -1;\n        lt[lt[x].ls].root = lt[x].ls;\n        lt[lt[x].rs].root = lt[x].rs;\n        lt[x].root = merge(lt[x].ls, lt[x].rs);\n    }\n};\nLeftist_Tree t;\n\nsigned main()\n{\n    int n, m;\n    read(n), read(m);\n    t.lt[0].dis = -1;\n    for (int i = 1; i <= n; ++i)\n    {\n        t.lt[i].root = i;\n        read(t.lt[i].val);\n    }\n    while (m--)\n    {\n        int op, x, y;\n        read(op);\n        if (op == 1)\n        {\n            read(x), read(y);\n            if (t.lt[x].val == -1 || t.lt[y].val == -1)\n                continue;\n            int fx = t.find(x), fy = t.find(y);\n            if (fx != fy)\n            {\n                int p = t.merge(fx, fy);\n                t.lt[fx].root = p;\n                t.lt[fy].root = p;\n            }\n        }\n        else\n        {\n            read(x);\n            if (t.lt[x].val == -1)\n                puts(\"-1\");\n            else\n            {\n                cout << t.top(t.find(x)) << '\\n';\n                t.pop(t.find(x));\n            }\n        }\n    }\n    return 0;\n}\n```\n\n","tags":["数据结构"]},{"title":"LCA","url":"/2020/08/14/LCA/","content":"\n\n\n在有根树中，最近公共祖先（**L**east **C**ommon **A**ncestors）是两个结点最近的的公共祖先，也是最深的一个。\n\n\n\n<!--more-->\n\n\n\n随便找一棵有根树，在里面随便找两个不同结点A、B，求它们的最近公共祖先C，有以下几种方法：\n\n## 1. 暴力\n\n- 先从A、B中深度大的一个向上走，直到两个深度一样。\n- 如果这时候遇到了另一个，那么直接找到了；如果没有相遇，两个同时往上走，直到遇见为止。\n- 正确性显然，复杂度 $O(nq)$\n\n当然了，这样必然会T。\n\n## 2. 倍增\n\n暴力的问题在于每次往上走的步长都是1，效率低下，所以可以先走一大步，如果过头了就回来缩小步长，否则继续向前走。\n\n复杂度 $O((n+q)\\log n)$，比较优秀，也是很常用的做法。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\n\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 5e5 + 9;\n\nstruct node\n{\n    int to, nxt;\n};\nnode e[maxn << 1];\nint head[maxn], num;\nvoid add(int u, int v)\n{\n    e[++num].to = v;\n    e[num].nxt = head[u];\n    head[u] = num;\n}\nint depth[maxn], fa[maxn][22], lg[maxn];\nvoid dfs(int pos, int f)\n{\n    fa[pos][0] = f;\n    depth[pos] = depth[f] + 1;\n    for (int i = 1; i <= lg[depth[pos]]; ++i)\n        fa[pos][i] = fa[fa[pos][i - 1]][i - 1];\n    for (int i = head[pos]; i; i = e[i].nxt)\n        if (e[i].to != f)\n            dfs(e[i].to, pos);\n}\nint lca(int x, int y)\n{\n    if (depth[x] < depth[y])\n        swap(x, y);\n    while (depth[x] > depth[y])\n    {\n        x = fa[x][lg[depth[x] - depth[y]] - 1];\n    }\n    if (x == y)\n        return x;\n    for (int k = lg[depth[x]] - 1; k >= 0; --k)\n        if (fa[x][k] != fa[y][k])\n            x = fa[x][k], y = fa[y][k];\n    return fa[x][0];\n}\n\nsigned main()\n{\n    int n, m, s;\n    read(n), read(m), read(s);\n    for (int i = 1; i < n; ++i)\n    {\n        int x, y;\n        read(x), read(y);\n        add(x, y), add(y, x);\n    }\n    for (int i = 1; i <= n; ++i)\n        lg[i] = lg[i - 1] + (1 << lg[i - 1] == i);\n    dfs(s, 0);\n    for (int i = 1; i <= m; ++i)\n    {\n        int x, y;\n        read(x), read(y);\n        cout << lca(x, y) << '\\n';\n    }\n    return 0;\n}\n```\n\n## 3. ST表\n\n同样对树进行一次 dfs，求出结点顺序和深度然后用ST表维护区间中深度最小结点的位次。\n\n复杂度 $O(n\\log n+q)$，动态点分治在线求LCA比较有用。\n\n详细内容以后再补。\n\n## 4. 树链剖分\n\n不会树剖，大概是这样做的：\n\n对树进行轻重链剖分，每次沿重链向上跳，直到两个节点的 top 相同，此时 dep 较小的就是LCA。\n\n复杂度 $O(n+q\\log n)$，这种做法的另一个好处在于可以结合别的线性数据结构把树上的信息转化为链上的信息。\n\n详细内容以后再补。\n\n## 5. Tarjan算法\n\n把询问分别挂在两节点上，然后对整棵树做一次 dfs ，用并查集维护每个节点当前深度最小的祖先。\n\n复杂度 $O(n+q)$，唯一一个线性复杂度的，但是似乎很少用。\n\n详细内容以后再补。\n\n![83613096](https://i.loli.net/2020/08/15/QvCZyBsRS8PKoeL.jpg)\n\n没看过Fate，但是这个阿尔托莉雅真可爱\n\n","tags":["图论"]},{"title":"分块","url":"/2020/08/13/block/","content":"\n\n\n分块是一种很暴力的思想，总是可以莫名其妙的乱搞掉一些题目。莫队算法就是建立在分块的基础上，所以还是有必要学一下分块。\n\n\n\n\n<!--more-->\n\n简单的说**分块**就是把整个序列分成若干个连续的块，每个块包含一段比较短的区间。可以用分块做很多事情，比如像线段树一样对区间进行修改查询。\n\n由均值不等式可以得出，一般块的长度分为 $\\sqrt {len}$ 比较合适。\n\n所以如果要用树形的结构表示，大概是这样的：\n\n![分块](https://i.loli.net/2020/08/13/ZMYCoQ8ylg4jrk5.png)\n\n可见无论原来的序列有多长，这个树形结构的高度永远都是3，因此它的复杂度远远不如线段树的 $O(n\\log n)$，而是 $O(n\\sqrt n)$。所幸在大部分情况下这个根号复杂度也是可以接受的。\n\n由于这个思想非常暴力，代码实现也比较容易理解：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\n\nconst int maxn = 1e5 + 9;\n\nint ans[maxn], fa[maxn], a[maxn];\nint st[maxn], ed[maxn], sz[maxn], tag[maxn];\nint n, m, sq;\n\nvoid change(int x, int y)\n{\n    int l = fa[x], r = fa[y];\n    for (int i = x; i <= min(y, ed[l]); ++i)\n    {\n\n    }\n    if (l != r)\n    {\n        for (int i = st[r]; i <= y; ++i)\n        {\n\n        }\n    }\n    for (int i = l + 1; i < r; ++i)\n    {\n\n    }\n}\n\nint query(int x, int y)\n{\n    int res = 0, l = fa[x], r = fa[y];\n    for (int i = x; i <= min(y, ed[l]); ++i)\n    {\n        \n    }\n    if (l != r)\n    {\n        for (int i = st[r]; i <= y; ++i)\n\n    }\n    for (int i = l + 1; i < r; ++i)\n    {\n\n    }\n    return res;\n}\n\nsigned main()\n{\n\n    read(n), read(m);\n    sq = sqrt(n);\n    for (int i = 1; i < +n; ++i)\n        read(s[i]);\n    for (int i = 1; i <= sq; ++i)\n    {\n        st[i] = n / sq * (i - 1) + 1;\n        ed[i] = n / sq * i;\n    }\n    ed[sq] = n;\n    for (int i = 1; i <= sq; ++i)\n        for (int j = st[i]; j <= ed[i]; ++j)\n            fa[j] = i;\n    for (int i = 1; i <= sq; ++i)\n        sz[i] = ed[i] - st[i] + 1;\n    \n\n    return 0;\n}\n```\n\n大概可以搞出这样的一个模板。\n\n但是可能会出现一些很玄学的问题。\n\n比如 [P3870 [TJOI2009]开关](https://www.luogu.com.cn/problem/P3870) 这样写总有两个点过不去，怎么都调不对，不知道为什么，但是稍微改变一下写法就能过了：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 1e5 + 9;\n\nint n, m;\nint sq;\nint q[maxn];\nbool tag[maxn];\nbool k[maxn];\nint sum[maxn];\n\nvoid opt1(int l, int r)\n{\n    for (int i = l; i <= min(r, q[l] * sq); i++)\n    {\n        sum[q[i]] -= (k[i] ^ tag[q[i]]);\n        k[i] ^= 1;\n        sum[q[i]] += (k[i] ^ tag[q[i]]);\n    }\n    if (q[l] != q[r])\n    {\n        for (int i = (q[r] - 1) * sq + 1; i <= r; i++)\n        {\n            sum[q[i]] -= (k[i] ^ tag[q[i]]);\n            k[i] ^= 1;\n            sum[q[i]] += (k[i] ^ tag[q[i]]);\n        }\n    }\n    for (int i = q[l] + 1; i < q[r]; i++)\n    {\n        tag[i] ^= 1;\n        sum[i] = sq - sum[i];\n    }\n}\nint opt2(int l, int r)\n{\n    int s = 0;\n    for (int i = l; i <= min(r, q[l] * sq); i++)\n    {\n        s += (k[i] ^ tag[q[i]]);\n    }\n    if (q[l] != q[r])\n    {\n        for (int i = (q[r] - 1) * sq + 1; i <= r; i++)\n        {\n            s += (k[i] ^ tag[q[i]]);\n        }\n    }\n    for (int i = q[l] + 1; i < q[r]; i++)\n    {\n        s += sum[i];\n    }\n    return s;\n}\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    sq = sqrt(n);\n    for (int i = 1; i <= n; i++)\n    {\n        q[i] = (i - 1) / sq + 1;\n    }\n    while (m--)\n    {\n        int opt, l, r;\n        scanf(\"%d%d%d\", &opt, &l, &r);\n        if (opt == 0)\n        {\n            opt1(l, r);\n        }\n        else\n        {\n            printf(\"%d\\n\", opt2(l, r));\n        }\n    }\n    return 0;\n}\n```\n\n这就非常令人难以理解。\n\n线段树就比这个靠谱得多。我还是更喜欢线段树。\n\n虽然分块这种做法看起来很丑陋，但是有时候还是挺有用的，所以先了解一下。\n\n\n\n\n\n最近比赛的状态依然不好。\n\n![83510923](https://i.loli.net/2020/08/14/rLgvUPjmKEsSThI.jpg)","tags":["数据结构"]},{"title":"模板（更新中）","url":"/2020/08/12/Template/","content":"\n\n\n# 模板\n\n<!--more-->\n\n\n## 字符串\n\n### KMP\n\n```c++\n/*a:模式串 s:待匹配串*/\nchar s[maxn], a[maxn];\nint nxt[maxn], lena, lens;\nvoid getnext(){\n    nxt[0] = -1, nxt[1] = 0;\n    for (int i = 2, k; i <= lena; ++i){\n        k = nxt[i - 1];\n        while (k != -1 && a[k + 1] != a[i])\n            k = nxt[k];\n        nxt[i] = k + 1;\n    }\n}\nvoid kmp(){\n    for (int i = 1, k = 0; i <= lens; ++i){\n        while (k != -1 && s[i] != a[k + 1])\n            k = nxt[k];\n        k++;\n        if (k == lena)//匹配成功\n            k = nxt[k];\n    }\n}\nint main(){\n    scanf(\"%s\", s + 1);\n    scanf(\"%s\", a + 1);\n    a[0] = s[0] = '$';//否则strlen函数失效\n    lena = strlen(a) - 1, lens = strlen(s) - 1;\n    getnext();\n    kmp();\n}\n```\n\n### AC自动机\n\n已更新\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 6;\nint n;\n\nint tr[N][26], tot;\nint e[N], fail[N];\nvoid insert(char *s)\n{\n    int u = 0;\n    for (int i = 1; s[i]; i++)\n    {\n        if (!tr[u][s[i] - 'a'])\n            tr[u][s[i] - 'a'] = ++tot;\n        u = tr[u][s[i] - 'a'];\n    }\n    e[u]++;\n}\nqueue<int> q;\nvoid build()\n{\n    for (int i = 0; i < 26; i++)\n        if (tr[0][i])\n            q.push(tr[0][i]);\n    while (q.size())\n    {\n        int u = q.front();\n        q.pop();\n        for (int i = 0; i < 26; i++)\n        {\n            if (tr[u][i])\n                fail[tr[u][i]] = tr[fail[u]][i], q.push(tr[u][i]);\n            else\n                tr[u][i] = tr[fail[u]][i];\n        }\n    }\n}\nint query(char *t)\n{\n    int u = 0, res = 0;\n    for (int i = 1; t[i]; i++)\n    {\n        u = tr[u][t[i] - 'a']; // 转移\n        for (int j = u; j && e[j] != -1; j = fail[j])\n        {\n            res += e[j], e[j] = -1;\n        }\n    }\n    return res;\n}\n\nchar s[N];\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++)\n        scanf(\"%s\", s + 1), insert(s);\n    scanf(\"%s\", s + 1);\n    build();\n    printf(\"%d\", query(s));\n    return 0;\n}\n```\n\n### Manacher\n\n待修改\n\n```c++\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nchar str[11000005],str_new[11000005];\nint p[22000020],len;\nvoid init()\n{\n    int t=2;\n    len=strlen(str);\n    str_new[0]='@';\n    str_new[1]='#';\n    for(int i=0; i<len; i++)\n    {\n        str_new[t++]=str[i];\n        str_new[t++]='#';\n    }\n    str_new[t]='$';\n}\nvoid Manacher()\n{\n    memset(p,0,sizeof(p));\n    int mid,ans=0,r=0;\n    for(int i=1;i<len*2+2;i++)\n    {\n        if(i<r)\n            p[i]=p[2*mid-i]<(r-i)?p[2*mid-i]:r-i;\n        else\n            p[i]=1;\n        for(;str_new[i-p[i]]==str_new[i+p[i]];p[i]++);\n        if(i+p[i]>r)\n            mid=i,r=i+p[i];\n        if(p[i]>ans)\n            ans=p[i];\n    }\n    printf(\"%d\\n\",--ans);\n}\nint main()\n{\n    scanf(\"%s\",str);\n    init();\n    Manacher();\n    return 0;\n}\n```\n\n## 图论\n\n### MST-Kruskal\n\n```c++\nstruct edge{\n    int x, y, w;\n    bool operator<(const edge &b) const{\n        return w < b.w;\n    }\n};\nint n, m, fa[maxn], k;\nint find(int x)\n{\n    return fa[x] == x ? x : fa[x] = find(fa[x]);\n}\nvoid join(int x, int y){\n    int tx = find(x), ty = find(y);\n    if (tx != ty)\n        fa[tx] = ty;\n}\nedge e[maxn];\nvoid kruskal(){\n    for (int i = 1; i <= n; ++i)\n        fa[i] = i;\n    sort(e + 1, e + m + 1);\n    for (int i = 1; i <= m; ++i){\n        edge t = e[i];\n        if (find(t.x) == find(t.y))\n            continue;\n        join(t.x, t.y);\n    }\n}\n```\n\n### 树链剖分\n\n```c++\nint n, m, root, mod;\nint head[maxn], to[maxn], nxt[maxn], tot = 0;\ninline void add(int u, int v)\n{\n    to[++tot] = v;\n    nxt[tot] = head[u];\n    head[u] = tot;\n}\n\nint son[maxn], id[maxn], fa[maxn], cnt, dep[maxn], sz[maxn], top[maxn];\nint w[maxn], wt[maxn];\n\nstruct segtree\n{\n    int tree[maxn << 2], tag[maxn << 2];\n    void push_up(int p)\n    {\n        tree[p] = (tree[p << 1] + tree[p << 1 | 1]) % mod;\n    }\n    void build(int p, int l, int r)\n    {\n        tag[p] = 0;\n        if (l == r)\n        {\n            tree[p] = wt[l] % mod;\n            return;\n        }\n        int mid = (l + r) >> 1;\n        build(p << 1, l, mid);\n        build(p << 1 | 1, mid + 1, r);\n        push_up(p);\n    }\n    void flag(int p, int l, int r, int k)\n    {\n        tag[p] = (tag[p] + k) % mod;\n        tree[p] += k * (r - l + 1);\n        tree[p] %= mod;\n    }\n    void push_down(int p, int l, int r)\n    {\n        int mid = (l + r) >> 1;\n        flag(p << 1, l, mid, tag[p]);\n        flag(p << 1 | 1, mid + 1, r, tag[p]);\n        tag[p] = 0;\n    }\n    void update(int p, int l, int r, int ul, int ur, int k)\n    {\n        if (ul <= l && ur >= r)\n        {\n            tree[p] += k * (r - l + 1);\n            tag[p] += k;\n            tree[p] %= mod;\n            tag[p] %= mod;\n            return;\n        }\n        push_down(p, l, r);\n        int mid = (l + r) >> 1;\n        if (ul <= mid)\n            update(p << 1, l, mid, ul, ur, k);\n        if (ur > mid)\n            update(p << 1 | 1, mid + 1, r, ul, ur, k);\n        push_up(p);\n    }\n    int query(int p, int l, int r, int qx, int qy)\n    {\n        if (qx <= l && qy >= r)\n            return tree[p];\n        int ans = 0, mid = (l + r) >> 1;\n        push_down(p, l, r);\n        if (qx <= mid)\n            ans += query(p << 1, l, mid, qx, qy), ans %= mod;\n        if (qy > mid)\n            ans += query(p << 1 | 1, mid + 1, r, qx, qy), ans %= mod;\n        return ans;\n    }\n};\nsegtree tree;\n\nvoid dfs1(int p, int f, int d)\n{\n    dep[p] = d;\n    fa[p] = f;\n    sz[p] = 1;\n    int maxson = -1;\n    for (int i = head[p]; i; i = nxt[i])\n    {\n        int y = to[i];\n        if (y == f)\n            continue;\n        dfs1(y, p, d + 1);\n        sz[p] += sz[y];\n        if (sz[y] > maxson)\n            son[p] = y, maxson = sz[y];\n    }\n}\n\nvoid dfs2(int p, int topf)\n{\n    id[p] = ++cnt;\n    wt[cnt] = w[p];\n    top[p] = topf;\n    if (son[p] == 0)\n        return;\n    dfs2(son[p], topf);\n    for (int i = head[p]; i; i = nxt[i])\n    {\n        int y = to[i];\n        if (y == fa[p] || y == son[p])\n            continue;\n        dfs2(y, y);\n    }\n}\n\nint query(int l, int r)\n{\n    int ans = 0;\n    while (top[l] != top[r])\n    {\n        if (dep[top[l]] < dep[top[r]])\n            swap(l, r);\n        ans += tree.query(1, 1, n, id[top[l]], id[l]);\n        ans %= mod;\n        l = fa[top[l]];\n    }\n    if (dep[l] > dep[r])\n        swap(l, r);\n    ans += tree.query(1, 1, n, id[l], id[r]);\n    return ans % mod;\n}\n\nvoid update(int l, int r, int k)\n{\n    k %= mod;\n    while (top[l] != top[r])\n    {\n        if (dep[top[l]] < dep[top[r]])\n            swap(l, r);\n        tree.update(1, 1, n, id[top[l]], id[l], k);\n        l = fa[top[l]];\n    }\n    if (dep[l] > dep[r])\n        swap(l, r);\n    tree.update(1, 1, n, id[l], id[r], k);\n}\n\ninline int qson(int p)\n{\n    return tree.query(1, 1, n, id[p], id[p] + sz[p] - 1);\n}\n\ninline void upson(int p, int k)\n{\n    tree.update(1, 1, n, id[p], id[p] + sz[p] - 1, k);\n}\n\nsigned main()\n{\n    read(n), read(m), read(root), read(mod);\n    int op, u, v, k;\n    for (int i = 1; i <= n; ++i)\n        read(w[i]);\n    for (int i = 1; i < n; ++i)\n    {\n        read(u), read(v);\n        add(u, v), add(v, u);\n    }\n    dfs1(root, 0, 1);\n    dfs2(root, root);\n    tree.build(1, 1, n);\n    while (m--)\n    {\n        read(op);\n        if (op == 1)\n        {\n            read(u), read(v), read(k);\n            update(u, v, k);\n        }\n        else if (op == 2)\n        {\n            read(u), read(v);\n            cout << query(u, v) << '\\n';\n        }\n        else if (op == 3)\n        {\n            read(u), read(k);\n            upson(u, k);\n        }\n        else\n        {\n            read(u);\n            cout << qson(u) << '\\n';\n        }\n    }\n    return 0;\n}\n```\n\n\n\n## 计算几何\n\n`const double eps = 1e-8;`\n\n### 点\n\n```c++\nint sgn(double x){\n    if (fabs(x) < eps) return 0;\n    if (x < 0) return -1;\n    return 1;\n}\nstruct point{\n    double x, y;\n    point() {}\n    point(double x, double y) : x(x), y(y) {}\n    point operator+(const point &p) const {\n        point new_p(x + p.x, y + p.y);\n        return new_p;\n    }\n    point operator-(const point &p) const {\n        point new_p(x - p.x, y - p.y);\n        return new_p;\n    }\n    point operator|(const double &p) const {\n        point new_p(x * p, y * p);\n        return new_p;\n    }\n    point operator/(const double &p) const {\n        point new_p(x / p, y / p);\n        return new_p;\n    }\n    bool operator==(const point &p) const {\n        return sgn(x - p.x) == 0 && sgn(y - p.y) == 0;\n    }\n    double operator*(const point &p) const {\n        return x * p.x + y * p.y;\n    }\n    double operator^(const point &p) const {\n        return x * p.y - y * p.x;\n    }\n    double len() {\n        return sqrt(x * x + y * y);\n    }\n    void print() {\n        cout << x << ' ' << y << '\\n';\n    }\n};\ndouble dist(const point &a, const point &b){\n    return sqrt((a - b) * (a - b));\n}\ntypedef point vec;\n```\n\n### 二维凸包\n\n#### Graham算法\n\n```c++\nconst int maxn = 1e5 + 10;\npoint pt[maxn];\nint Stack[maxn], top;\nbool _cmp(point p1, point p2){\n    double tmp = (p1 - pt[0]) ^ (p2 - pt[0]);\n    if (sgn(tmp) > 0)\n        return true;\n    else if (sgn(tmp) == 0 && sgn(dist(p1, pt[0]) - dist(p2, pt[0])) <= 0)\n        return true;\n    else\n        return false;\n}\nvoid Graham(int n)\n{\n    point p0;\n    int k = 0;\n    p0 = pt[0];\n    for (int i = 1; i < n; i++){\n        if ((p0.y > pt[i].y) || (p0.y == pt[i].y && p0.x > pt[i].x)){\n            p0 = pt[i];\n            k = i;\n        }\n    }\n    swap(pt[k], pt[0]);\n    sort(pt + 1, pt + n, _cmp);\n    if (n == 1){\n        top = 1;\n        Stack[0] = 0;\n        return;\n    }\n    if (n == 2){\n        top = 2;\n        Stack[0] = 0;\n        Stack[1] = 1;\n        return;\n    }\n    Stack[0] = 0;\n    Stack[1] = 1;\n    top = 2;\n    for (int i = 2; i < n; i++){\n        while (top > 1 && \n               sgn((pt[Stack[top - 1]] - pt[Stack[top - 2]]) ^ (pt[i] - pt[Stack[top - 2]])) <= 0)\n            top--;\n        Stack[top++] = i;\n    }\n}\n```\n\n## 数据结构\n\n### 线段树\n\n```c++\nint a[maxn];\n\nstruct segtree\n{\n    int tree[maxn << 2], tag[maxn << 2];\n    void push_up(int p)\n    {\n        tree[p] = tree[p << 1] + tree[p << 1 | 1];\n    }\n    void build(int p, int l, int r)\n    {\n        tag[p] = 0;\n        if (l == r)\n        {\n            tree[p] = a[l];\n            return;\n        }\n        int mid = (l + r) >> 1;\n        build(p << 1, l, mid);\n        build(p << 1 | 1, mid + 1, r);\n        push_up(p);\n    }\n    void flag(int p, int l, int r, int k)\n    {\n        tag[p] += k;\n        tree[p] += k * (r - l + 1);\n    }\n    void push_down(int p, int l, int r)\n    {\n        int mid = (l + r) >> 1;\n        flag(p << 1, l, mid, tag[p]);\n        flag(p << 1 | 1, mid + 1, r, tag[p]);\n        tag[p] = 0;\n    }\n    void update(int p, int l, int r, int ul, int ur, int k)\n    {\n        if (ul <= l && ur >= r)\n        {\n            tree[p] += k * (r - l + 1);\n            tag[p] += k;\n            return;\n        }\n        push_down(p, l, r);\n        int mid = (l + r) >> 1;\n        if (ul <= mid)\n            update(p << 1, l, mid, ul, ur, k);\n        if (ur > mid)\n            update(p << 1 | 1, mid + 1, r, ul, ur, k);\n        push_up(p);\n    }\n    int query(int p, int l, int r, int qx, int qy)\n    {\n        if (qx <= l && qy >= r)\n            return tree[p];\n        int ans = 0, mid = (l + r) >> 1;\n        push_down(p, l, r);\n        if (qx <= mid)\n            ans += query(p << 1, l, mid, qx, qy);\n        if (qy > mid)\n            ans += query(p << 1 | 1, mid + 1, r, qx, qy);\n        return ans;\n    }\n};\n```\n\n### 划分树\n\n静态区间第 $k$ 小\n\n```c++\nconst int maxn = 2e5 + 9;\n\nint tree[30][maxn];\nint sorted[maxn];\nint toleft[30][maxn];\n\nvoid build(int l, int r, int dep)\n{\n    if (l == r)\n        return;\n    int mid = (l + r) >> 1;\n    int same = mid - l + 1;\n    for (int i = l; i <= r; ++i)\n        if (tree[dep][i] < sorted[mid])\n            same--;\n    int lpos = l, rpos = mid + 1;\n    for (int i = l; i <= r; ++i)\n    {\n        if (tree[dep][i] < sorted[mid])\n            tree[dep + 1][lpos++] = tree[dep][i];\n        else if (tree[dep][i] == sorted[mid] && same > 0)\n        {\n            tree[dep + 1][lpos++] = tree[dep][i];\n            same--;\n        }\n        else\n            tree[dep + 1][rpos++] = tree[dep][i];\n        toleft[dep][i] = toleft[dep][l - 1] + lpos - l;\n    }\n    build(l, mid, dep + 1);\n    build(mid + 1, r, dep + 1);\n}\nint query(int l, int r, int x, int y, int dep, int k)\n{\n    if (x == y)\n        return tree[dep][x];\n    int mid = (l + r) >> 1;\n    int cnt = toleft[dep][y] - toleft[dep][x - 1];\n    if (cnt >= k)\n    {\n        int newx = l + toleft[dep][x - 1] - toleft[dep][l - 1];\n        int newy = newx + cnt - 1;\n        return query(l, mid, newx, newy, dep + 1, k);\n    }\n    else\n    {\n        int newy = y + toleft[dep][r] - toleft[dep][y];\n        int newx = newy - (y - x - cnt);\n        return query(mid + 1, r, newx, newy, dep + 1, k - cnt);\n    }\n}\nsigned main()\n{\n    int n, m;\n    read(n), read(m);\n    //memset(tree, 0, sizeof(tree));\n    for (int i = 1; i <= n; ++i)\n    {\n        read(tree[0][i]);\n        sorted[i] = tree[0][i];\n    }\n    sort(sorted + 1, sorted + n + 1);\n    build(1, n, 0);\n    while (m--)\n    {\n        int l, r, k;\n        read(l), read(r), read(k);\n        cout << query(1, n, l, r, 0, k) << '\\n';\n    }\n    return 0;\n}\n```\n\n### 左偏树\n\n可并堆\n\n```c++\nconst int maxn = 1e5 + 9;\n\nstruct Tree\n{\n    int dis, val, root, ls, rs;\n};\n\nstruct Leftist_Tree\n{\n    Tree lt[maxn];\n    int merge(int x, int y)\n    {\n        if (!x || !y)\n            return x + y;\n        if (lt[x].val > lt[y].val || (lt[x].val == lt[y].val && x > y))\n            swap(x, y);\n        lt[x].rs = merge(lt[x].rs, y);\n        if (lt[lt[x].ls].dis < lt[lt[x].rs].dis)\n            swap(lt[x].ls, lt[x].rs);\n        lt[lt[x].ls].root = x;\n        lt[lt[x].rs].root = x;\n        lt[x].root = x;\n        lt[x].dis = lt[lt[x].rs].dis + 1;\n        return x; //root\n    }\n    int find(int x)\n    {\n        return lt[x].root == x ? x : lt[x].root = find(lt[x].root);\n    }\n    int top(int x)\n    {\n        return lt[x].val;\n    }\n    void pop(int x)\n    {\n        lt[x].val = -1;\n        lt[lt[x].ls].root = lt[x].ls;\n        lt[lt[x].rs].root = lt[x].rs;\n        lt[x].root = merge(lt[x].ls, lt[x].rs);\n    }\n};\nLeftist_Tree t;\n\nsigned main()\n{\n    int n, m;\n    read(n), read(m);\n    t.lt[0].dis = -1;\n    for (int i = 1; i <= n; ++i)\n    {\n        t.lt[i].root = i;\n        read(t.lt[i].val);\n    }\n    while (m--)\n    {\n        int op, x, y;\n        read(op);\n        if (op == 1)\n        {\n            read(x), read(y);\n            if (t.lt[x].val == -1 || t.lt[y].val == -1)\n                continue;\n            int fx = t.find(x), fy = t.find(y);\n            if (fx != fy)\n            {\n                int p = t.merge(fx, fy);\n                t.lt[fx].root = p;\n                t.lt[fy].root = p;\n            }\n        }\n        else\n        {\n            read(x);\n            if (t.lt[x].val == -1)\n                puts(\"-1\");\n            else\n            {\n                cout << t.top(t.find(x)) << '\\n';\n                t.pop(t.find(x));\n            }\n        }\n    }\n    return 0;\n}\n```\n\n\n\n## 优化\n\n### 普通快读\n\n```c++\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\n```\n\n### 究极版\n\n```c++\nchar nc()\n{\n    static char buf[100000], *p1, *p2;\n    return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++;\n}\ninline int read()\n{\n    register int x = 0;\n    register char a = nc();\n    while (a < '0' || a > '9')\n        a = nc();\n    while (a >= '0' && a <= '9')\n        x = x * 10 + a - '0', a = nc();\n    return x;\n}\nchar pbuf[10000000], *pp = pbuf;\ninline void write(int x)\n{\n    static int sta[35];\n    register int top = 0;\n    if (!x)\n        sta[++top] = 0;\n    while (x)\n        sta[++top] = x % 10, x /= 10;\n    while (top)\n        *pp++ = sta[top--] ^ '0';\n}\n```\n\n输入用法：`int n=read()`\n\n输出用法：\n\n```c++\nfor(int i=1;i<=n;++i)\n\twrite(ans[i]), *pp++ = '\\n';//答案后面换行或者空格\nfwrite(pbuf, 1, pp - pbuf, stdout);//最后用这个\n```\n\n","tags":["模板"]},{"title":"CF#663div2总结","url":"/2020/08/10/CF663div2/","content":"\n帽子戏法！\n\n<!--more-->\n\n## A\n\n本来是一眼题，结果因为前一天做了一道求异或和的题，把这里的 `or` 也都看成 `xor` 了，浪费 $5$ 分钟。**首杀**。\n\n## B\n\n也是水题，结果看成只需要满足一条从左上角到右下角的路线，先打了个DFS+剪枝，发现第三个样例输出是3，代码看起来也没什么问题，就又写了个 $O(mn)$ 的DP，发现第三个样例输出还是3。。。然后才发现是题目读错了。浪费 $50$ 分钟。**梅开二度**。\n\n## C\n\n很简单的组合数学题，推到4就已经很清楚了，$S_n=n\\cdot S_{n-1}+(n-2)[(n-1)!-S_{n-1}]$，整理一下可以得到 $S_n=(n-2)(n-1)!+2S_{n-1}$，甚至可以得到通项公式 $S_n=n!-2^{n-1}$。但是把模数看成了数据范围，$O(n)$ 的递推式列出来以后还想了半天怎么优化复杂度，浪费 $5$ 分钟。**帽子戏法**。\n\n## D\n\n前三道题已经浪费了一个小时了，留给D的时间已经不多了，虽然D的性质也很显然，排除 $\\min(m,n)\\ge 4$ 的和 $\\min(m,n)=1$ 的情况以后随便什么状压DP之类的都可以做的，但是最后还是来不及调了，遗憾。\n\n## E\n\n根本来不及看，虽然看了估计也做不出来，好像是树剖之类的题。\n\n\n\n一共两个小时的比赛，理解错题意导致浪费一个小时，那还比个P。最近几场CF会做的题总是不能全过，经常因为各种奇怪的原因做不完或者做错。这也不是要提高算法之类的的能力了，或许要多做做各种题目提升一下审题能力和代码能力，尤其是手速和debug速度。如果能稳定发挥的话上个蓝名应该已经不是问题了。\n\n\n\n状态什么时候能好呢。。。\n\n![83493912](https://i.loli.net/2020/08/10/r3efvqXE7OjP5wL.jpg)\n\n","tags":["CodeForces"]},{"title":"2020暑假训练整合（已完结）","url":"/2020/08/09/2020Summer/","content":"\n7月20日开始暑假训练\n\n<!--more-->\n\n**由于CSDN比较稳定，每天的题解笔记之类放在CSDN上**\n\n- 7月20日 STL、分治、贪心等\n  - [2020暑期训练1](https://blog.csdn.net/Pastafarian/article/details/107474375)\n- 7月21日 基础DP\n  - [2020暑期训练2](https://blog.csdn.net/Pastafarian/article/details/107512800)\n- 7月22日 基础数据结构\n  - [2020暑期训练3](https://blog.csdn.net/Pastafarian/article/details/107543109)\n- 7月23日 数论\n  - [2020暑期训练4](https://blog.csdn.net/Pastafarian/article/details/107593890)\n- 7月26日 DP优化\n  - [2020暑期训练5](https://blog.csdn.net/Pastafarian/article/details/107620694)\n- 7月27日 图论\n  - [2020暑期训练6](https://blog.csdn.net/Pastafarian/article/details/107645822)\n- 7月28日 字符串\n  - [2020暑期训练7](https://blog.csdn.net/Pastafarian/article/details/107694716)\n- 7月29日 计算几何基础\n  -   [2020暑期训练8](https://blog.csdn.net/Pastafarian/article/details/107764056)\n- 7月31日 组合数学\n  - [2020暑期训练9](https://blog.csdn.net/Pastafarian/article/details/107788906)\n- 8月2日 概率\n  - [2020暑期训练10](https://blog.csdn.net/Pastafarian/article/details/107885231)\n\n[以及慢慢更新的模板整理](https://phlzy.github.io/2020/08/12/Template/)\n\n![200723.jpg](https://i.loli.net/2020/07/23/Cx7nHkT4QsElFOj.jpg)\n\n","tags":["其它"]},{"title":"洛谷8月月赛Idiv2","url":"/2020/08/08/LGR-074div2/","content":"\n和上次一样先口胡一些思路，等题解出了以后再做完善。\n\n<!--more-->\n\n## A&B\n\nA没啥好说的，直接上代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint num[600];\nsigned main()\n{\n    int k;\n    ll x;\n    cin >> k >> x;\n    num[k + 1] = 1;\n    int cnt = 0;\n    while (x)\n    {\n        num[++cnt] += x % 10;\n        x /= 10;\n        if (num[cnt] > 9)\n        {\n            num[cnt + 1] += num[cnt] / 10;\n            num[cnt] %= 10;\n        }\n    }\n    if (num[cnt + 1] > 0)\n        cnt++;\n    for (int i = max(k + 1, cnt); i > 0; --i)\n        cout << num[i];\n    return 0;\n}\n```\n\nB找一下规律：\n\n- 全 `0` 的时候直接结束；\n- 其中一个为 `0` 的时候用 `0` 去乘大数，另一个数字除完向下取整；\n- 两个相等的时候：\n  - 一起减一下就好了\n  - 或者先把一个除成 `0`，再处理另一个\n- 其他情况：\n  - 乘除一次把两个变成一样的\n  - 或者像上面一样先把一个除成 `0`，再处理另一个\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nsigned main()\n{\n    ll a, b, c, d;\n    cin >> a >> b >> c >> d;\n    if (a * b == 0)\n    {\n        if (a == b)\n            cout << 0;\n        else\n            cout << d;\n        return 0;\n    }\n    if (a == b)\n        cout << min(c, d + d);\n    else\n        cout << min(c + d, d + d);\n    return 0;\n}\n```\n\n这次的AB非常简单。\n\n## C\n\n很明显是按位处理，但是被我写挂了：\n\n- $m$ 的最大范围达到了 $2^{30}\\times 10^6$，很明显用 `long long`，结果脑子一抽写了 `__int128_t`，又顺便写了个输出函数，将问题大大复杂化；\n- 解法是统计每一位的 `1` 的个数，顺便算出最小需要的 $m$ 大小，如果大于询问的 $m$ 直接输出 `-1`，否则从高位到低位进行dfs，搜到的第一个答案就是最大的 $k$；\n- 然后我好像又双叒叕死在搜索上了。\n\n附上怎么都调不对的代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\nint tmp[100];\ntemplate <typename T>\ninline void write(T x)\n{\n    int cnt = 0;\n    if (x < 0)\n    {\n        x = -x;\n        putchar('-');\n    }\n    do\n    {\n        tmp[++cnt] = x % 10;\n    } while (x /= 10);\n    while (cnt)\n        putchar('0' + tmp[cnt--]);\n    putchar('\\n');\n}\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nconst int maxn = 1e5 + 9;\nint tot[35], tot1[35];\n__int128_t ret, m, num[35][2], mintot;\nbool vis[35];\nvoid dfs(int d, __int128_t sum)\n{\n    if (d < 0)\n    {\n        for (int i = 0; i <= 30; ++i)\n            if (vis[i])\n                ret += ((__int128_t)1 << i);\n        return;\n    }\n    if (sum > m || ret != 0)\n    {\n        //write(ret);\n        return;\n    }\n    //write(sum);\n    vis[d] = true;\n    dfs(d - 1, sum + num[d - 1][1]);\n    vis[d] = false;\n    dfs(d - 1, sum + num[d - 1][0]);\n    return;\n}\nsigned main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"data.txt\",\"w\",stdout);\n    //std::ios::sync_with_stdio(false);\n    //std::cin.tie(0);\n    //std::cout.tie(0);\n    ull n, q, a;\n    read(n);\n    for (int i = 1; i <= n; ++i)\n    {\n        read(a);\n        for (int j = 0; j <= 30; ++j)\n            if (a >> j & 1)\n                tot[j]++;\n    }\n    mintot = 0;\n    for (int j = 0; j <= 30; ++j)\n    {\n        num[j][1] = (__int128_t)(1 << j) * (__int128_t)(n - tot[j]);\n        num[j][0] = (__int128_t)(1 << j) * (__int128_t)tot[j];\n        mintot += min((__int128_t)(1 << j) * (__int128_t)tot[j], (__int128_t)(1 << j) * (__int128_t)(n - tot[j]));\n    }\n    //write(mintot);\n    read(q);\n    while (q--)\n    {\n        read(m);\n        if (m < mintot)\n        {\n            puts(\"-1\");\n            continue;\n        }\n        for (int i = 0; i <= 30; ++i)\n            vis[i] = false;\n        ret = 0;\n        dfs(31, 0);\n        ret = ((m >> 31) << 31) + ret;\n        write(ret);\n    }\n    //fclose(stdin);\n    //fclose(stdout);\n    return 0;\n}\n```\n\n\n\n## D\n\n第一眼看到的想法：既然是树，就可以从叶子结点开始一层一层处理，先把所有连接叶子结点的边权求出来，然后把叶子结点全部摘掉并重复上一步过程。\n\n当然这样做肯定是不对的：\n\n![200808.png](https://i.loli.net/2020/08/08/Y6kJL4IsQofepHz.png)\n\n比方说这个图按照这个做法就是不可行的。\n\n所以应该还是要根据父亲结点的值做一些调整。\n\n具体解法等官方题解出来再说，这题我也没写代码。\n\n要多练练搜索了，DP和简单的图论也要做一做。\n\n![83492606.jpg](https://i.loli.net/2020/08/08/hWmVtilwrdPRgox.jpg)","tags":["洛谷"]},{"title":"CF1399D题解","url":"/2020/08/07/CF1399D-Solution/","content":"\n构造，模拟？[链接](https://codeforces.com/problemset/problem/1399/D) [或者在洛谷看](https://www.luogu.com.cn/problem/CF1399D)\n\n<!--more-->\n\n比赛的时候做出来了，后来看了很多题解发现我的理解似乎比较独特，就记录一下（做法本质上是一样的）。\n\n我们可以让一个点根据原序列的内容进行移动，将这个问题转化为下面的形式：\n\n假设在平面直角坐标系中有一个点坐标为 $(x,y)$，当走到序列的下一个元素时，如果是 `0` 该点就移动到 $(x+1,y-1)$ 处，如果是 `1` 该点就移动到 $(x+1,y+1)$ 处。为了便于模拟，我们让这个点的初始状态位于原点。\n\n显然，这个点的运动轨迹是一条折线，而且终点在 $(n,num_1-num_0)$。$k$ 的最小值就是折线最高点和最低点之间的距离。这 $k$ 个子序列也可以用它们的纵坐标来表示，画个图稍作推导即可得出。\n\n代码如下：\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 9;\nint ans[maxn];\nunordered_map<int, int> mp;\nint main()\n{\n    int T;\n    scanf(\"%d\", &T);\n    while (T--)\n    {\n        int n, x;\n        scanf(\"%d\", &n);\n        mp.clear();\n        int h = 0, maxx = 0, minn = 0, cnt = 0;\n        for (int i = 1; i <= n; ++i)\n        {\n            scanf(\"%1d\", &x);\n            if (x == 1)\n                h++;\n            else\n                h--;\n            if (h > 0)\n            {\n                if (h > maxx)\n                    mp[h] = ++cnt, maxx = h;//更新最高点高度\n                ans[i] = h;\n                if (x == 0)\n                    ans[i]++;\n            }\n            else if (h < 0)\n            {\n                if (h < minn)\n                    mp[h] = ++cnt, minn = h;//更新最低点高度\n                ans[i] = h;\n                if (x == 1)\n                    ans[i]--;\n            }\n            else\n            {\n                if (x == 1)\n                    ans[i] = -1;\n                else\n                    ans[i] = 1;\n            }\n        }\n        printf(\"%d\\n\", cnt);\n        for (int i = 1; i <= n; ++i)\n            printf(\"%d \", mp[ans[i]]);\n        printf(\"\\n\");\n    }\n    return 0;\n}\n```\n","tags":["CodeForces"]},{"title":"单调队列优化DP等","url":"/2020/08/02/P2034P2627/","content":"\n\n\n### 算法简介\n\n以[P2034 选择数字](https://www.luogu.com.cn/problem/P2034)和[P2627 [USACO11OPEN]Mowing the Lawn G](https://www.luogu.com.cn/problem/P2627)为例（双倍经验）总结一下单调队列优化DP和一些其它的东西。\n\n<!--more-->\n\n## 单调队列优化\n\n给出 $n$ 个非负整数，选若干个数，其中不能有超过 $k$ 个连续的数被选，需要使选出的数字和最大。也就是说，连续的 $k+1$ 个数中必然会被丢掉至少一个。\n\n显然我们只要让被丢掉的数的和最小，用总和减去这个最小值就能求出答案了。因此最初的状态转移方程是这样的：\n\n$$dp[i]=num[i]+\\min(dp[i-1],dp[i-2],\\cdots,dp[i-k])$$\n\n其中 $dp[i]$ 就表示如果丢掉第 $i$ 个数，前 $i$ 个数中被丢掉的总和。\n\n这样做的时间复杂度是 $O(nk)$，在这题的数据范围下几乎不可能通过。\n\n因此我需要对这个过程进行优化，上面做法浪费时间的原因在于求区间最小值的时候重复了很多次，可以用单调队列把这些多余的过程优化掉。\n\n构造一个从队首到队尾单调递增的单调队列，每次将新元素入队前把比它大的元素全部从队尾弹出，放入新元素，再把与当前位置距离超过 $k$ 的从队首弹出。这样每次计算 $dp[i]$ 的时候只需要从队首拿出元素加上去就可以了。\n\n代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst int INF = 0x3f3f3f3f;\nconst int maxn = 1e5 + 9;\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\nstruct node\n{\n    ull sum;\n    int n;\n    node() { sum = 0, n = 0; }\n    node(ull a, int b) : sum(a), n(b) {}\n};\ndeque<node> dq;\null dp[maxn];\nint main()\n{\n    int n, k;\n    read(n), read(k);\n    ull sum = 0, ans = 0;\n    dq.push_back(node(0, 0));\n    for (int i = 1; i <= n; ++i)\n    {\n        read(dp[i]);\n        sum += dp[i];\n        if (!dq.empty())\n            dp[i] += dq.front().sum;\n        while (!dq.empty() && dq.back().sum >= dp[i])\n            dq.pop_back();\n        dq.push_back(node(dp[i], i));\n        while (!dq.empty() && dq.front().n < i - k)\n            dq.pop_front();\n    }\n    for (int i = n - k; i <= n; ++i)\n        ans = max(ans, sum - dp[i]);\n    cout << ans << '\\n';\n    return 0;\n}\n```\n\n其中 `dq.push_back(node(0, 0));` 是必要的，否则dp数列从一开始就会错掉。\n\n\n\n当然，在 $k$ 非常小的时候，就不需要用单调队列，直接用上面的状态转移方程就好了。\n\n## 线段树优化\n\n因为要查询区间最小值，所以直接用线段树来维护，代替单调队列，代码更长更难写，复杂度由 $O(n)$ 退化到 $O(n\\log k)$，虽然完全可以解决这个问题，但是显然被单调队列全方位吊打。\n\n## 最短路\n\n这个做法是在题解里看到的，非常有意思：\n\n由于数据范围是 $0\\lt k \\le n \\le 1\\times 10^5$，$O(n\\log^2 k)$ 也可以过。我们事先设置一个超级起点和一个超级终点，从超级起点开始走向 $1\\cdots k$ 的点，每走到点 $i$ 就走向 $i+1\\cdots 1+k+1$ 的点，直到走进超级终点为止。由于连边的操作是一个点向一个区间连边，所以依然可以使用线段树来优化，再用Dijkstra算法求最短路即可。\n\n显然这个做法比线段树优化更为复杂，速度也更慢，但是这个转化问题的思路还是比较有意义的。\n\n![200802.jpg](https://i.loli.net/2020/08/02/theHfoBYdK1JyDF.jpg)\n\n这个好像是儿子的壁纸？","tags":["洛谷"]},{"title":"Educational Round 92总结","url":"/2020/07/31/CFedu92/","content":"\n每次打比赛总是会理解错题意。\n\n[题解部分在CSDN上也发了](https://blog.csdn.net/Pastafarian/article/details/107686440)\n\n<!--more-->\n\n# A. LCM Problem\n水题，显然 $2\\times a\\le \\mathrm{lcm}(a,b) \\; , \\;b\\le \\mathrm{lcm}(a,b)$，那么就做完了。\n# B. Array Walk\n很明显是个DP，但是我调了好久才对，还是太菜了。\n推导过程如下：\n首先对于 $z=0$ 的情况，显然最终结果是 $dp_0=max_0=\\sum_{i=1}^{k+1}a_i$\n所以可以建一个前缀和数组。\n\n$z=1$的时候除了不仅可以像上面那样走，还可以选择在路程中间后退一次或者在末端后退一次。在中间后退使得路径长度减少2，中间有连续的两个块会被经过两次；在末端后退会路径长度减少1，路径的倒数第二个块经过两次。于是可以再开一个数组记录到当前位置为止的最大相邻块值的和，即$m[i] = \\max(m[i - 1], a[i - 1] + a[i])$\n那么 $max_1=\\max(pre[k-1] + m[k-1], pre[k]  + a[k-1])$\n显然，$dp_1=\\max(dp_0,max_1)$\n\n$z\\ge2$ 的时候以此类推，可以得到 $dp_i=\\max(dp_{i-1},max_i)$ 以及\n$max_i=\\max(pre[k + 1 - 2 \\times i] + i \\times m[k + 1 - 2 \\times i], pre[k + 2 - 2 \\times i] + (i - 1) \\times m[k + 2 - 2 \\times i] + a[k + 1 - 2 \\times i])$\n\n于是这题就做完了，复杂度 $O(k)$。\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst int INF = 0x3f3f3f3f;\nconst int maxn = 1e5 + 9;\ninline int read()\n{\n    int data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    return f * data;\n}\nint arr[maxn], pre[maxn], m[maxn];\n\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"data.txt\",\"w\",stdout);\n    //std::ios::sync_with_stdio(false);\n    //std::cin.tie(0);\n    int T;\n    T = read();\n    while (T--)\n    {\n        memset(m, 0, sizeof(m));\n        int n = read(), k = read(), z = read();\n        for (int i = 1; i <= n; ++i)\n        {\n            arr[i] = read();\n            pre[i] = pre[i - 1] + arr[i];\n            m[i] = max(m[i - 1], arr[i - 1] + arr[i]);\n        }\n        int ans = pre[k + 1], tmp;\n        for (int i = 1; i <= z; ++i)\n        {\n            if (k < 2 * i - 1)\n                break;\n            tmp = max(pre[k + 1 - 2 * i] + i * m[k + 1 - 2 * i], pre[k + 2 - 2 * i] + (i - 1) * m[k + 2 - 2 * i] + arr[k + 1 - 2 * i]);\n            ans = max(ans, tmp);\n        }\n        cout << ans << '\\n';\n    }\n    //fclose(stdin);\n    //fclose(stdout);\n    return 0;\n}\n```\n# C. Good String\n比赛的时候理解错了题意，试了二分和尺取法结果都过不了样例。第二天再看发现题目读错了。。。。。\n显然，满足题目要求的左移和右移后相同的序列只可能是两种：\n\n1. 所有的元素全部相同\n2. 两个不同元素交替循环，如 `0101010101`\n\n可以发现，如果序列长度是奇数那么必须是第一种\n由于所有字符都是数字，可以把所有组合都枚举一遍计算好串长度最大值，再用总长度减一下就行了\n这题到这里也就做完了\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst int INF = 0x3f3f3f3f;\nconst int maxn = 1e5 + 9;\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\nstring s;\nint calc(int x, int y)\n{\n    int ans = 0;\n    for (int i = 0; i < s.length(); ++i)\n        if (s[i] - '0' == x)\n        {\n            ans++;\n            swap(x, y);\n        }\n    if (x != y && ans & 1)\n        ans--;\n    return ans;\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"data.txt\",\"w\",stdout);\n    //std::ios::sync_with_stdio(false);\n    //std::cin.tie(0);\n    int T;\n    read(T);\n    while (T--)\n    {\n        cin >> s;\n        int ans = 0;\n        for (int i = 0; i <= 9; ++i)\n            for (int j = 0; j <= 9; ++j)\n                ans = max(ans, calc(i, j));\n        cout << s.length() - ans << '\\n';\n    }\n    //fclose(stdin);\n    //fclose(stdout);\n    return 0;\n}\n\n```\n# D. Segment Intersections\n又是一个题面令人费解的题，并且比C难多了。\n分类讨论很复杂，尤其两条线段不相交的情况。\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\nll n, k, l1, l2, r1, r2;\nint main()\n{\n    int t;\n    read(t);\n    while (t--)\n    {\n        read(n), read(k), read(l1), read(r1), read(l2), read(r2);\n        ll ans = 1e18;\n        if (max(l1, l2) <= min(r1, r2))\n        {\n            ll rem = max((ll)0, k - n * (min(r1, r2) - max(l1, l2)));\n            ll mp = n * (abs(l1 - l2) + abs(r1 - r2));\n            ans = min(rem, mp) + max((ll)0, rem - mp) * 2;\n        }\n        else//不相交\n        {\n            ll inv = max(l1, l2) - min(r1, r2);//间隔\n            for (int i = 1; i <= n; ++i)\n            {\n                ll tmp = i * inv;//补上间隔\n                ll mp = (max(r1, r2) - min(l1, l2)) * i;//最大长度\n                tmp += min(k, mp) + max((ll)0, k - mp) * 2;//调整\n                ans = min(ans, tmp);\n            }\n        }\n        cout << ans << '\\n';\n    }\n}\n```\n照着题解的kotlin代码写了一份c++的\n# E. Calendar Ambiguity\n由题，$x\\times d+y\\equiv y\\times d+x \\pmod w$，变形可得：\n$(x-y)\\times(d-1)\\equiv 0\\pmod w$\n那么就很明显了，既然 $d$ 和 $w$ 都已知了，$x-y$ 一定是 $\\frac{w}{\\gcd(w,d-1)}$ 的整数倍。接下来等差数列求和就可以解决了。\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate <typename T>\ninline void read(T &x)\n{\n    T data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    x = f * data;\n}\nll m, d, w;\nint main()\n{\n    int t;\n    read(t);\n    while (t--)\n    {\n        read(m), read(d), read(w);\n        ll w2 = w / __gcd(d - 1, w);\n        ll md = min(m, d);\n        ll cnt = md / w2;\n        ll ans = (2 * md - w2 * (cnt + 1)) * cnt / 2;\n        cout << ans << '\\n';\n    }\n}\n```\n\n# 总结\n\n以我目前的水平，前五题应该是可以做出来的，即便像D这样的题比赛的时候调不出来，做对四题也是应该的。这一场做出四题基本能进1000，五题就能进500，可以涨一大波分。但是最终的结果不尽人意，主要还是因为这种题目做的还不够多。CF这种类型的题目一般不需要任何算法，仅仅是对暴力模拟的一点优化而已，因此还是要做一些div2的BCD题来熟练一下。\n\n![200731.jpg](https://i.loli.net/2020/07/31/WTIi26RS54fwm8n.jpg)\n\n","tags":["CodeForces"]},{"title":"洛谷7月月赛div2","url":"/2020/07/25/LGR-073div2/","content":"\n在出题解之前口胡了一些思路，现在把之前想错的和没写的补上。\n\n<!--more-->\n\n## A&B\n\nA二分答案，不卡精度，很简单；\n\nB算一下前缀和，后面计算取模的时候注意一下顺序，也没什么问题。\n\n*没什么问题*\n\n## C\n\n应该是一个DP，容易发现每一列在旋转的时候是不会变的，而上下是否颠倒与其旋转次数奇偶有关，所以可以判断能否做出目标形状，最少次数应该是从某个边缘开始逐渐还原的顺序需要的次数。没写代码不知道这个思路对不对。\n\n*观察到的性质没有问题，确实需要利用这个性质来解题，但是需要转化后通过计算逆序对的方法求解。*\n\n## D\n\n写这篇文章就是为了记下看到D题以后我的胡思乱想。\n\n看到单点修改先想到树状数组，但是显然没法完成区间排序判断。区间排序会打乱元素顺序，那么差分就没有用，每次排序用时 $(r-l)\\log(r-l)$，太长，考虑用一个map之类的东西存放，这样如果重复元素多的话会好一点。但是这样做显然是不行的，首先不可能每次把区间的一堆东西丢进map，这样比直接排序还慢，而如果用类似前缀和的思想，开 $n$ 个map，那不仅空间会爆炸，map的复制也是个问题。因为要有序，所以不能用hash。\n\n第二个想法是用珂朵莉树，每次查询区间的时候把没有的区间放进set，有的区间split掉得到要求的区间，但是这样同样需要很多的map，并且复杂度不见得优秀到哪里去，估计也是不行的。\n\n然后想如果搞一棵树去存序列的点的话也是修改比较方便，判断操作是很麻烦的，还是需要维护序列的数据结构，或许可以把线段树的结构修改一下，下面的叶子存储数据，在上面建一个类似于平衡树的结构？不知道有什么神奇的结构可以搞这样的序列。\n\n*本题的正解是线段树与哈希，需要将一个区间哈希成一个值，非常巧妙。从来没有想过还可以有这样的做法。*\n\n8月月赛快来了，7月236pts，下次希望能超过250pts。\n\n![200725.jpg](https://i.loli.net/2020/07/25/NGbP53ZU69HFqOa.jpg)","tags":["洛谷"]},{"title":"CF#658div2总结","url":"/2020/07/24/CF658div2/","content":"\n这场除了E比较难，其他题都比较简单，可惜比赛的时候思路并没有很清晰。\n\n<!--more-->\n\n## A&B\n\nA水题。B稍微想一下，第一个遇到多于一个的堆的人可以掌控之后的局势，必然获胜，也很容易。\n\n## C\n\nC给的积分居然比B还低，就离谱。\n\n不过C也确实很简单，应该先看Hard Version，就比较容易想出先全部推平再转化的做法，先看Easy Version反而有一种被误导的感觉。\n\n比赛的时候看到序列翻转就像中了邪一样去想Splay，这种比赛平时连线段树都不会考，会考Splay？\n\n题解写在CSDN上：[CF1382C（1381A）Prefix Flip](https://blog.csdn.net/Pastafarian/article/details/107562596)\n\n## D\n\nD的转化倒是非常巧妙，归并的性质似乎没有那么容易看出来，虽然看出来以后正确性是非常容易证明的。转化成DP以后就没有难度了，最简单的01背包。\n\n题解写在CSDN上：[CF1382D（1381B）Unmerge](https://blog.csdn.net/Pastafarian/article/details/107568308)\n\n## E\n\n只有E题的构造比较难，毕竟也是div1的C，\\*2500的题了，改天有空的时候好好学一下。\n\n\n\n过了C大概能进1000，再过D能进500，思路并不复杂，也都是我会的算法，为什么比赛的时候就做不出来？以后需要每天做一两道div1的AB题开拓一下思维了。\n\n\n\n今天的比赛不能再掉分了\n\n![200724.jpg](https://i.loli.net/2020/07/24/UPnsZ3ykSA1RIDl.jpg)","tags":["CodeForces"]},{"title":"单调栈","url":"/2020/07/20/Monotone_Stack/","content":"\n## 简介：\n\n顾名思义，单调栈中的元素是单调的，规定其单调性由**出栈顺序**决定，即栈顶元素最小的单调栈是单调递增栈，反之则是单调递减栈。\n\n<!--more-->\n\n## 单调栈原理\n\n例如有一个单调递增栈，要把4，2，3，6，1，5这6个数放进去，其运行过程如图所示：\n\n![200720MS.png](https://i.loli.net/2020/07/20/VQN1ESyAT2Wpagj.png)\n\n可见，每当新元素加入时都会把比它小的元素一个个弹出，直到栈顶元素比它大或栈空为止。这个维护单调性的操作和单调队列有些相似。\n\n单调栈这个数据结构虽然看起来很蠢，但是却能优化一些算法，例如在一个数列中找到每个数后面第一个比它大的数据的位置，暴力算法的复杂度是 $O(n^2)$，对于随机数据可能会表现比较好，但是如果某一个测试数据是单调递减的序列，暴力算法一定会被卡掉，而使用单调栈是稳定的 $O(n)$，这是一个非常大的进步。\n\n\n## 具体实现（模板题[P5788](https://www.luogu.com.cn/problem/P5788)）\n\nSTL的栈就很好用，没必要手写。用递增的单调栈从后往前过一遍就可以了。\n\n### AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 3e6 + 9;\nint n, a[maxn], ans[maxn];\nstack<int> s;\ninline int read()//数据有点多，cin会TLE\n{\n    int data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    return f * data;\n}\nint main()\n{\n    n = read();\n    for (int i = 1; i <= n; ++i)\n        a[i] = read();\n    for (int i = n; i > 0; --i)\n    {\n        while (!s.empty() && a[s.top()] <= a[i])\n            s.pop();\n        if (!s.empty())\n            ans[i] = s.top();\n        s.push(i);\n    }\n    for (int i = 1; i <= n; ++i)\n        cout << ans[i] << ' ';\n    return 0;\n}\n```\n\n![200720ms.jpg](https://i.loli.net/2020/07/20/yRQ6YscEXWt7JOa.jpg)\n\n这个瓶子也算是个栈？","tags":["数据结构"]},{"title":"洛谷P2671题解","url":"/2020/07/19/P2671-Solution/","content":"\n\n\n[P2671求和](https://www.luogu.com.cn/problem/P2671) 前缀和，数学推导\n\n<!--more-->\n\n这题比较复杂，以下是部分思路：\n\n1. 数据范围很大，要用 `long long` 存储，算一次取模一次，并且算法的时间复杂度不能超过 $O(n\\log n)$；\n   -  最简单的想法是 $O(n^3)$ 的暴力，稍作分析可以优化为 $O(n^2)$，但是显然这两种方法在这里都不管用\n   -  但是以上分析的过程可以得到一个**非常重要的结论**：$y$ 的值并不需要我们知道\n   -  在两个大小不同而奇偶性相同的数之间必然存在一个偶数是这两个数的平均数\n2. 由上一条可以发现，数字对应的编号的意义在于计算 $(x+z)\\times (number\\_x+number\\_z)$ 以及根据奇偶性分组，而颜色也需要另行分组，因此可以分为不多于 $2\\times m$ 种\n3. 在每组中求这些乘积的和，使用分配率以后可以发现，$x\\times number\\_x$ 与 $z\\times number\\_z$ 可以在读入的时候直接算出，因此只需要算 $\\sum (x\\times number\\_z+z\\times number\\_x)$，这个求和可以化成 $\\sum _{i=1}^n x_i\\times (\\sum _{j=1}^n number\\_z_j)-x_i\\times number\\_x_i$ 之类的东西，从而在 $O(n)$ 时间内求出\n\n\n\n大致的思路就是这样，以下是代码的一种写法\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e5 + 9;\nconst int mod = 10007;\n\ninline ll read()\n{\n    ll data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))\n    {\n        data = (data << 3) + (data << 1) + ch - '0';\n        ch = getchar();\n    }\n    return f * data;\n}\n\nint num[maxn], col[maxn];\nll ans, f[maxn][2][4];\n//f[][0][]:颜色  f[][1][]:奇偶\nint main()\n{\n    int n = read(), m = read();\n    for (int i = 1; i <= n; i++)\n        num[i] = read() % mod;\n    for (int i = 1; i <= n; i++)\n        col[i] = read() % mod;\n    for (int i = 1; i <= n; i++)\n    {\n        (ans += (f[col[i]][i % 2][0] * (i % mod) * (num[i] % mod)) % mod) %= mod;\n        (ans += f[col[i]][i % 2][1]) %= mod;\n        (ans += ((i % mod) * f[col[i]][i % 2][2]) % mod) %= mod;\n        (ans += ((num[i] % mod) * f[col[i]][i % 2][3]) % mod) %= mod;\n        (f[col[i]][i % 2][0] += 1) %= mod;\n        //满足条件个数\n        (f[col[i]][i % 2][1] += (i % mod) * (num[i] % mod)) %= mod;\n        //sum z*number_z\n        (f[col[i]][i % 2][2] += num[i] % mod) %= mod;\n        //sum z\n        (f[col[i]][i % 2][3] += i % mod) %= mod;\n        //sum number_z\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n\n```\n\n这题真是让人头大。。。\n\n![200719P2671.jpg](https://i.loli.net/2020/07/19/bloA8djRuJw2GgX.jpg)","tags":["题解"]},{"title":"Treap（树堆）","url":"/2020/07/19/Treap/","content":"\n# 简介：\n\n“如果将一个含n个元素的集合插入到一棵二叉搜索树中，所得到的的树可能会相当不平衡，从而导致查找时间很长……随机构造二叉搜索树是趋向于平衡的……可以采用一种策略是先随机排列这些元素，然后按照排列的顺序将它们插入到树中……一棵Treap树就是一棵更改了结点排序方式的二叉搜索树”——《算法导论》\n\n<!--more-->\n\n# 基本性质：\n\n顾名思义，Treap是Tree与Heap的结合体，二叉搜索树功能强大但是容易退化，而堆则具有完全二叉树的性质，Treap兼具二者优点，从而保持平衡。\n\n显然，为了保持搜索树的性质，Treap中的元素不能像堆一样放，依然需要遵循BST的规则，因此对于每个元素需要引入一个随机数作为维持堆的性质的依据。对于每个节点，满足以下三个性质：\n\n1. 如果ls是root的左孩子，val[ls]<val[root]；\n2. 如果rs是root的右孩子，val[rs]>val[root]；\n3. 如果s是root的后代，rnd[u]>rnd[root]（小根堆）\n\n\n\n# 具体实现：\n\n## 1、准备工作\n\n### 存储结构\n\n```c++\nstruct node{\n    int ls, rs, val, size, rnd, freq;\n} treap[maxn];\n```\n\n数组存Treap，没什么好说的，和AVL树相比多了一个值rnd\n\n### 随机数生成\n\n可以用自带的 `rand()` 函数，但是据说容易被卡，所以也可以自己写。\n\nupdate:\n\n```c++\nmt19937 rng(time(0));\n```\n\n然后用 `rng()` 代替 `rand()` 就好了。\n\n## 2、重要功能\n\n### 更新信息\n\n```c++\ninline void update(int k) \n{\n    treap[k].size = treap[treap[k].ls].size + treap[treap[k].rs].size + treap[k].freq;\n}\n```\n\n### 旋转\n\n对于一棵BST，可以发现以下两种旋转结点的方式可以不改变结点排列规则而改变树的结构，所以Treap可以通过这两种方式使结点满足堆的性质。\n\n![200719rotate.png](https://i.loli.net/2020/07/19/KX6iGy8ZTHAD4pY.png)\n\n- 左旋：\n\n\t1. 取出根的右子树，即图中提取出C的过程\n\t2. 用根的右子树的左子树替换根的右子树，即图中F—>A的过程\n\t3. 用根替换被取出的右子树的左子树，即图中下移A点使其变成C的左子树的过程\n\t4. 更新数据\n\n\n```c++\ninline void rotate_l(int &k)\n{\n    int t = treap[k].rs;\n    treap[k].rs = treap[t].ls;\n    treap[t].ls = k;\n    treap[t].size = treap[k].size;\n    update(k);\n    k = t;\n}\n```\n\n- 右旋：\n\n  1.  取出根的左子树，即图中提取出B的过程\n  2. 用根的左子树的右子树替换根的左子树，即图中E—>A的过程\n  3. 用根替换被取出的左子树的右子树，即图中下移A点使其变成B的右子树的过程\n  4. 更新数据\n\n```c++\ninline void rotate_r(int &k)\n{\n    int t = treap[k].ls;\n    treap[k].ls = treap[t].rs;\n    treap[t].rs = k;\n    treap[t].size = treap[k].size;\n    update(k);\n    k = t;\n}\n```\n\n可见左旋和右旋正好是完全相反的过程，它们与在堆中插入元素时不断向上对比交换效果类似，从堆的角度来看，左旋相当于交换右孩子与父亲的值，右旋反之。\n\n\n\n### 插入\n\nBST的递归插入方式，顺便维护堆的性质。\n\n```c++\nvoid insert(int &k, int x)\n{\n    if (k == 0)\n    {\n        cnt++;\n        k = cnt;\n        treap[k].size = treap[k].freq = 1;\n        treap[k].val = x;\n        treap[k].rnd = rand();\n        return;\n    }\n    treap[k].size++;\n    if (treap[k].val == x)\n        treap[k].freq++; \n    else if (x > treap[k].val)\n    {\n        insert(treap[k].rs, x);\n        if (treap[treap[k].rs].rnd < treap[k].rnd)\n            rotate_l(k); \n    }\n    else\n    {\n        insert(treap[k].ls, x);\n        if (treap[treap[k].ls].rnd < treap[k].rnd)\n            rotate_r(k);\n    }\n}\n```\n\n\n\n### 删除\n\n先利用BST性质找到这个值，再把这个节点旋转成叶子节点，最后删除\n\n```c++\nvoid del(int &k, int x)\n{\n    if (k == 0)\n        return;\n    if (treap[k].val == x)\n    {\n        if (treap[k].freq > 1)\n        {\n            treap[k].freq--;\n            treap[k].size--;\n            return; \n        }\n        if (treap[k].ls * treap[k].rs == 0)\n            k = treap[k].ls + treap[k].rs; //有一个儿子为空\n        else if (treap[treap[k].ls].rnd < treap[treap[k].rs].rnd)\n            rotate_r(k), del(k, x);\n        else\n            rotate_l(k), del(k, x);\n    }\n    else if (x > treap[k].val)\n        treap[k].size--, del(treap[k].rs, x);\n    else\n        treap[k].size--, del(treap[k].ls, x);\n}\n```\n\n\n\n### 根据值查询排名\n\n与AVL树类似\n\n```c++\nint query_rank(int k, int x)\n{\n    if (k == 0)\n        return 0;\n    if (treap[k].val == x)\n        return treap[treap[k].ls].size + 1;\n    else if (x > treap[k].val)\n        return treap[treap[k].ls].size + treap[k].freq + query_rank(treap[k].rs, x);\n    else\n        return query_rank(treap[k].ls, x);\n}\n```\n\n\n\n### 根据排名查找值\n\n同样与AVL树类似\n\n```c++\nint query_val(int k, int x)\n{\n    if (k == 0)\n        return 0;\n    if (x <= treap[treap[k].ls].size)\n        return query_val(treap[k].ls, x);\n    else if (x > treap[treap[k].ls].size + treap[k].freq)\n        return query_val(treap[k].rs, x - treap[treap[k].ls].size - treap[k].freq);\n    else\n        return treap[k].val;\n}\n```\n\n\n\n### 查询前驱/后继\n\n由于是数组中建的树，实现难度远远低于AVL树\n\n```c++\nint query_pre(int k, int x)\n{\n    int t = k, ans = 0;\n    while (t)\n    {\n        if (treap[t].val < x)\n            ans = treap[t].val, t = treap[t].rs;\n        else\n            t = treap[t].ls;\n    }\n    return ans;\n}\nint query_suf(int k, int x)\n{\n    int t = k, ans = 0;\n    while (t)\n    {\n        if (treap[t].val > x)\n            ans = treap[t].val, t = treap[t].ls;\n        else\n            t = treap[t].rs;\n    }\n    return ans;\n}\n```\n\n\n\n## 3、完整代码（以[P3369](https://www.luogu.com.cn/problem/P3369)为例）\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1e5 + 9;\nstruct node\n{\n    int ls, rs, val, size, rnd, freq;\n} treap[maxn];\nint n, cnt, root;\ninline void update(int k)\n{\n    treap[k].size = treap[treap[k].ls].size + treap[treap[k].rs].size + treap[k].freq;\n}\ninline void rotate_l(int &k)\n{\n    int t = treap[k].rs; \n    treap[k].rs = treap[t].ls;\n    treap[t].ls = k;\n    treap[t].size = treap[k].size;\n    update(k);\n    k = t;\n}\ninline void rotate_r(int &k)\n{\n    int t = treap[k].ls;\n    treap[k].ls = treap[t].rs;\n    treap[t].rs = k;\n    treap[t].size = treap[k].size;\n    update(k);\n    k = t;\n}\nvoid insert(int &k, int x)\n{\n    if (k == 0)\n    {\n        cnt++;\n        k = cnt;\n        treap[k].size = treap[k].freq = 1;\n        treap[k].val = x;\n        treap[k].rnd = rand();\n        return;\n    }\n    treap[k].size++;\n    if (treap[k].val == x)\n        treap[k].freq++;\n    else if (x > treap[k].val)\n    {\n        insert(treap[k].rs, x);\n        if (treap[treap[k].rs].rnd < treap[k].rnd)\n            rotate_l(k);\n    }\n    else\n    {\n        insert(treap[k].ls, x);\n        if (treap[treap[k].ls].rnd < treap[k].rnd)\n            rotate_r(k);\n    }\n}\nvoid del(int &k, int x)\n{\n    if (k == 0)\n        return;\n    if (treap[k].val == x)\n    {\n        if (treap[k].freq > 1)\n        {\n            treap[k].freq--;\n            treap[k].size--;\n            return;\n        }\n        if (treap[k].ls * treap[k].rs == 0)\n            k = treap[k].ls + treap[k].rs; \n        else if (treap[treap[k].ls].rnd < treap[treap[k].rs].rnd)\n            rotate_r(k), del(k, x);\n        else\n            rotate_l(k), del(k, x);\n    }\n    else if (x > treap[k].val)\n        treap[k].size--, del(treap[k].rs, x);\n    else\n        treap[k].size--, del(treap[k].ls, x);\n}\nint query_rank(int k, int x)\n{\n    if (k == 0)\n        return 0;\n    if (treap[k].val == x)\n        return treap[treap[k].ls].size + 1;\n    else if (x > treap[k].val)\n        return treap[treap[k].ls].size + treap[k].freq + query_rank(treap[k].rs, x);\n    else\n        return query_rank(treap[k].ls, x);\n}\nint query_val(int k, int x)\n{\n    if (k == 0)\n        return 0;\n    if (x <= treap[treap[k].ls].size)\n        return query_val(treap[k].ls, x);\n    else if (x > treap[treap[k].ls].size + treap[k].freq)\n        return query_val(treap[k].rs, x - treap[treap[k].ls].size - treap[k].freq);\n    else\n        return treap[k].val;\n}\nint query_pre(int k, int x)\n{\n    int t = k, ans = 0;\n    while (t)\n    {\n        if (treap[t].val < x)\n            ans = treap[t].val, t = treap[t].rs;\n        else\n            t = treap[t].ls;\n    }\n    return ans;\n}\nint query_suf(int k, int x)\n{\n    int t = k, ans = 0;\n    while (t)\n    {\n        if (treap[t].val > x)\n            ans = treap[t].val, t = treap[t].ls;\n        else\n            t = treap[t].rs;\n    }\n    return ans;\n}\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cin >> n;\n    int opt, x;\n    for (int i = 1; i <= n; i++)\n    {\n        cin >> opt >> x;\n        switch (opt)\n        {\n        case 1:\n            insert(root, x);\n            break;\n        case 2:\n            del(root, x);\n            break;\n        case 3:\n            cout << query_rank(root, x) << '\\n';\n            break;\n        case 4:\n            cout << query_val(root, x) << '\\n';\n            break;\n        case 5:\n            cout << query_pre(root, x) << '\\n';\n            break;\n        case 6:\n            cout << query_suf(root, x) << '\\n';\n            break;\n        }\n    }\n    return 0;\n}\n```\n\n这样的Treap并非代码量最少的写法，但是便于理解，即便如此也比AVL树的实现少了100多行。\n\n\n\n# 后记\n\nTreap是一种非常有趣的数据结构，它并非像AVL树那样高度平衡，但是效率也不低，而且远比AVL树、红黑树好写。由于常数比较小，普通Treap的速度比Splay快。甚至在进行一些改进后Treap可以做到可持久化、分裂合并以及序列处理操作，是一种很强大的平衡树。\n\n\n\n学了大半天的Treap那就发一张树的图片好了。\n\n![200719Treap.jpg](https://i.loli.net/2020/07/19/usAjkBcWDYa4RSe.jpg)","tags":["数据结构"]},{"title":"HTML5基础知识","url":"/2020/07/17/HTML5_first_things_first/","content":"\n\nHTML即Hyper Text Markup Language（超文本标记语言），目前主流浏览器均支持HTML5。以下是一些HTML5最基本的概念。\n\n<!--more-->\n\n常用语句：\n\n- 声明：`<!DOCTYPPE>`\n\n  - HTML5：`<!DOCTYPPE html>`\n\n- `<head>`\n\n  -  `<title>` 显示网页标签的名字\n  -  `<link rel=\"stylesheet\" type=\"text/css\" href=\"\">` 外部样式表\n  -  内部样式表：\n\n  ```html\n  <style type=\"text/css\">\n  \tp{\n  \t\tcolor: #5C3317;<!-棕色->\n  \t}\n  </style>\n  ```\n\n- `<body>` \n\n  - 标题 `<h1>` 到`<h6>`逐渐变小 \n\n  - `<p>` 段落（结束后另起一行）\n\n  - `<a>` 超链接，用法：\n\n    `<a href=\"https://phlzy.github.io/\">blog</a>`\n\n  - `<img>` 图片，用法：\n\n    `<img src=\"images/html.png\">`\n\n  - `<br/>` 空标签（间距较小）\n  \n  - 格式化：\n  \n    ```html\n    <b>加粗</b>\n    <em>着重（斜体）</em>\n    <i>斜体</i>\n    <small>变小</small>\n    <strong>强调（变粗）</strong>\n    <sub>下标</sub>\n    <sup>上标</sup>\n    <ins>下划线</ins>\n    <del>删除线</del>\n    ```\n  - 内联样式表：`<a style=\"color: aqua\">` \n    \n\n### 元素标签\n\n**块：结束后会换行**\n\n标题 `<h1>` 等，段落 `<p>` 及列表 `ul` 等均为块元素\n\n**内联元素：结束后一般不会换行**\n\n**div元素：一般配合CSS样式作为组合HTML元素的容器使用**\n\n**span元素：内联元素，文本的容器**\n\n### 布局\n\n大致如下所示：\n\n```html\n<!DOCTYPE html>\n\n<html>\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title>Index</title>\n    <style type=\"text/css\">\n        body{\n            margin: 0px;\n        }\n        #container{\n            width: 100%;\n            height: 950px;\n            background-color: antiquewhite;\n        }\n        #head{\n            width: 100%;\n            height: 10%;\n            background-color: darkgray;\n        }\n        #content_menu{\n            width: 30%;\n            height: 80%;\n            background-color: white;\n            float: right;\n        }\n        #content_body{\n            width: 70%;\n            height: 80%;\n            background-color: aqua;\n            float: left;\n        }\n        #bottom{\n            width: 100%;\n            height: 10%;\n            background-color: antiquewhite;\n            clear: both;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"container\">\n        <div id=\"head\">\n            \n        </div>\n        <div id=\"content_menu\">\n            \n        </div>\n        <div id=\"content_body\">\n\n        </div>\n        <div id=\"bottom\">\n\n        </div>\n    </div>\n\n</body>\n\n</html>\n```\n\n看完这些无聊的东西，是时候放松一下自己了\n\n![200717html.jpg](https://i.loli.net/2020/07/17/3wn4c2JAa5TRLYM.jpg)","tags":["前端"]},{"title":"最长不下降子序列（LIS）与最长公共子序列（LCS）","url":"/2020/07/16/LIS&LCS/","content":"\n\n\n总结一下线性动态规划的两个经典问题：最长不下降子序列（LIS）与最长公共子序列（LCS）。\n\n\n\n<!--more-->\n\n###  LIS回顾：（[模板题P1020](https://www.luogu.com.cn/problem/P1020)）\n\n提供一个序列，求最长不下降子序列（Longest Increasing Subsequence）：\n\n- 朴素的 $O(n^2)$ 做法：对每个元素，存储以该元素结尾的最长不下降子序列长度，从前往后递推。\n  - 思路简单，效率低下\n- $O(n\\log n)$ 做法：初始化一个空数组，将元素依次按照以下规则填入：\n  - 若数组为空或最后一个元素不大于新元素，直接将新元素push_back；\n  - 若数组最后一个元素大于新元素，查找数组中第一个大于新元素的元素并用新元素代替；\n  - 观察该流程可以发现，新数组是单调非递减的，类似于一个队列，该数组的长度就是LIS的长度，由于可以使用二分查找，时间复杂度优化到 $O(n\\log n)$。\n  - 正确性：第一类操作显然正确，不必多言。第二类操作替换数组内元素，不会改变其长度，因此对之前的结果不会产生影响，而后续如果会产生更长的子序列，接在新元素的后面也是更优的选择，也就是说被替换的元素同样不会对后续造成影响。\n- 二分查找\n  - `lower_bound(ForwardIterator beg,ForwardIterator end,const T& value,BinaryPredicate op)`（默认升序，op可以不加）：返回**第一个大于等于**value的元素位置，即**可插入元素值为value，且不破坏区间有序性**的位置。如果不存在这样的位置，返回end\n  - `upper_bound(ForwardIterator beg,ForwardIterator end,const T& value,BinaryPredicate op)`（默认升序，op可以不加）：返回**第一个大于**value的元素位置，即**可插入元素值为value，且不破坏区间有序性**的位置。如果不存在这样的位置，返回end\n  - 如果容器支持随机访问，以上两个函数的复杂度是对数的\n\n所以求LIS的核心代码大致是这样的：\n\n\n```c++\nint len = 1; \nd[1] = a[1];           \nfor (int i = 2; i <= n; ++i)\n{ \n    if (d[len] <= a[i])\n        d[++len] = a[i];\n    else\n    {\n        int p = upper_bound(d + 1, d + 1 + len, a[i]) - d;\n        d[p] = a[i];\n    }\n}\n```\n\nPS.LIS也可以用树状数组做\n\n### LCS：（[模板题P1439](https://www.luogu.com.cn/problem/P1439)）\n\n提供从1到n的两个排列 $P_1$、$P_2$，求它们的最长公共子序列（Longest Common Subsequence）：\n\n- $O(n^2)$ 的做法是直接DP，以 $i$ 表示 $P_1$ 的前 $i$ 位，以 $j$ 表示 $P_2$ 的前 $j$ 位，可以得到以下两个状态转移方程：\n  - $$dp[i][j]=\\max\\{dp[i][j],dp[i-1][j-1]+1\\}(P_1[i]=P_2[j])$$\n  - $$dp[i][j]=\\max\\{dp[i-1][j],dp[i][j-1]\\}(P_1[i]\\ne P_2[j])$$\n  - 会被卡掉\n  \n- $O(n\\log n)$ 做法：利用全排列的性质\n\n  - 由题可知，两个序列的元素种类相同，只是排列顺序不一样，因此可以以其中一个作为基准重新编号，如图所示：\n\n  | $P_1$  | B（2） | D（4） | C（3） | E（5） | A（1） |\n  | ------ | ------ | ------ | ------ | ------ | ------ |\n  | $P_2$  | C（3） | A（1） | E（5） | B（2） | D（4） |\n  | $P_1'$ | 1      | 2      | 3      | 4      | 5      |\n  | $P_2'$ | 3      | 5      | 4      | 1      | 2      |\n\n  - 这样重新标号后 $P_1'$ 序列是递增的，那么这个问题就转化为了求LIS的问题。\n\nP1439AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100009;\nint a[maxn], m[maxn], b[maxn], t[maxn], d[maxn], n;\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cin >> n;\n    for (int i = 1; i <= n; ++i)\n    {\n        cin >> a[i];\n        m[a[i]] = i;\n    }\n    for (int i = 1; i <= n; ++i)\n    {\n        cin >> b[i];\n        t[i] = m[b[i]];\n    }\n    int len = 1;\n    d[1] = t[1];\n    for (int i = 2; i <= n; ++i)\n    {\n        if (d[len] <= t[i])\n            d[++len] = t[i];\n        else\n        {\n            int p = upper_bound(d + 1, d + 1 + len, t[i]) - d;\n            d[p] = t[i];\n        }\n    }\n    cout << len << '\\n';\n    return 0;\n}\n```\n\n日常：\n\n![200716.jpg](https://i.loli.net/2020/07/16/SKHyueG5FdwRPNn.jpg)","tags":["算法","洛谷"]},{"title":"VSCode常用快捷键","url":"/2020/07/14/VSCode/","content":"\n写代码的时候不用鼠标才能达到最高的效率\n\n<!--more-->\n\n常用快捷键：\n\n\n|    快捷键    |      功能      |\n| :--------------------: | :--------------------: |\n|       Ctrl+Shift+P或F1       | 打开命令面板  |\n|       Ctrl+P       |      搜索文件      |\n|    Ctrl+Shift+W    |      关闭窗口      |\n|    Ctrl+Shift+N    |     打开新窗口     |\n|  Ctrl+X（不选中）  |      剪切本行      |\n|  Ctrl+C（不选中）  |      复制本行      |\n|    Alt+ ↑ 或 ↓ |   上移或下移本行   |\n| Shift+Alt + ↓ 或 ↑ | 向上或向下复制本行 |\n|    Ctrl+Shift+K    |      删除本行      |\n|     Ctrl+Enter     |   在下方插入一行   |\n|  Ctrl+Shift+Enter  |   在上方插入一行   |\n|  Ctrl+Shift+\\ | 移动到相匹配的括号 |\n|     Home / End     | 到本行的行首或行尾 |\n| Ctrl+Home / End |    到文件的头尾    |\n|     Ctrl+↑ / ↓     |   上下拖动滚动条   |\n| Ctrl+Shift+[或] |   折叠或展开区域   |\n|  Ctrl+K Ctrl+C |   将本行变成注释   |\n|  Ctrl+K Ctrl+U | 将本行注释变成代码 |\n|       Ctrl+M       | 通过tab移动焦点 |\n|       Ctrl+G       |     跳转到某行     |\n|         F8         |  定位到下一个错误  |\n|       Ctrl+F       |        查找        |\n|       Ctrl+H       |        替换        |\n|    （Shift+）F3    |    （上）下一个    |\n|       Ctrl+N       |        新建        |\n|       Ctrl+O       |        打开        |\n|      Ctrl+K S      |      全部保存      |\n\n[全部快捷键在此](https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf)\n\n\n\nVSC本身并不可怕，可怕的是它的主人\n\n![vsc](https://i.loli.net/2020/07/14/pGXAh7J5ZuU3vRg.jpg)","tags":["其它"]},{"title":"CF#655div2总结","url":"/2020/07/12/CF655div2/","content":"\n\n\n**几个月没打CF了，本来想拿这一场试试手感，虽然是比寒假菜了不少，但是似乎有很大的上分的希望，只可惜评测姬似乎罢工了导致Unrated。。。**\n\n\n\n<!--more-->\n\n## A. Omkar and Completion\n\n第一眼看上去不像水题的超级大水题，全部输出一个1000以内数字就好了。没啥好说的。\n\n## B. Omkar and Last Class of Math\n\n显而易见，如果 $n$ 是质数，输出 $1$ 和 $n-1$，否则输出 $n/k$ 与 $n-n/k$，其中 $k$ 是 $n$ 的最小质因数。\n\n这个规律很容易证明，考虑到 $t\\le 10$ 以及 $2\\le n \\le 10^9$，我写了个线性筛，预处理后如果是质数直接输出，如果是合数就从质数表里一个个遍历过去。虽然用bitset判断质数不会爆空间，但是由于数据范围太大，线性复杂度的预处理函数也占用了非常多的时间，最终以一次RE一次TE的失败而告终。\n\n回过头来看一下 $t$ 的大小，其实这题用最简单的 $O(\\sqrt{n})$ 的暴力法就可以完美解决。。。我裂开了\n\n## C. Omkar and Baseball\n\n又是一道看起来很难的水题。\n\n先画一些小序列找一下规律，可以发现，位置全错的一段序列重组一次就可以变为有序；如果在一段序列的中间只有一个元素的位置是对的，如果序列足够长的话至少需要两次；如果中间有多个分散的，也可以第一次将它们全部打乱，第二次直接排好。因此，对于一整段序列来说，重组次数一定不超过两次，其中0次的情况显然只有在已经有序的时候才符合，1次的情况是无序数列是连续的一段，其余情况都需要两次。\n\n## D. Omkar and Circle\n\n做完C以后说unrated了，时间也不早了，第二天还有考试，就去睡了。\n\n这个D题也不算难，画一个圈模拟一下可以发现，一圈上面取到的数一定是 $(n+1)/2$ 个，并且每个取到的元素之间都隔着一个不取的，也就是说只要把序列展开成 $[1,3,5,\\cdots ,n,2,4,6,\\cdots,n-1]$,然后用单调队列求出 $(n+1)/2$ 长度序列的最大元素和即可。\n\n最后用unsigned long long存答案。\n\n## E. Omkar and Last Floor\n\n看标签是尺取法，dp。有空仔细看一下。\n\n## F. Omkar and Modes\n\n连题解都看不明白。\n\n\n\n先放张图，E、F两题以后再补\n\n![200719CF655.jpg](https://i.loli.net/2020/07/19/LG8QrRlKepPOTFI.jpg)","tags":["CodeForces"]},{"title":"顺序表复习","url":"/2020/07/08/Linear_List/","content":"\n\n数据结构复习，顺序表及其几个成员函数。写的很丑。\n\n<!--more-->\n\n**代码：**\n\n```c++\n#include <iostream>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nconst int maxn = 1000;\ntemplate <typename T>\nvoid swap(T &_a, T &_b)\n{\n    T temp = _a;\n    _a = _b;\n    _b = temp;\n}\ntemplate <typename T>\nint bin_search(T arr[], int l, int r, T x) //ascending\n{\n    int mid;\n    while (l <= r)\n    {\n        mid = (l + r) / 2;\n        if (x == arr[mid])\n            return mid;\n        else if (x < arr[mid])\n            r = mid - 1;\n        else\n            l = mid + 1;\n    }\n}\nclass Linear_List //ascending\n{\npublic:\n    int arr[maxn + 1], elenum;\n    void insert(int x, int pos)\n    {\n        elenum++;\n        for (int i = elenum; i > pos; --i)\n            arr[i] = arr[i - 1];\n        arr[pos] = x;\n    }\n    void show()\n    {\n        for (int i = 1; i <= elenum; ++i)\n            cout << arr[i] << ' ';\n        cout << endl;\n    }\n    void reverse()\n    {\n        for (int i = 1; i <= elenum / 2; ++i)\n            swap(arr[i], arr[elenum + 1 - i]);\n    }\n    int find(int x)\n    {\n        for (int i = 1; i <= elenum; ++i)\n            if (arr[i] == x)\n                return i;\n        return 0;\n    }\n    void _push_back(int x)\n    {\n        arr[++elenum] = x;\n    }\n    /*\n    void sort(int l, int r)\n    {\n        int mid = arr[(l + r) / 2], i = l, j = r;\n        do\n        {\n            while (arr[i] < mid)\n                i++;\n            while (arr[j] > mid)\n                j--;\n            if (i <= j)\n                swap(arr[i++], arr[j++]);\n        } while (i <= j);\n        if (l < j)\n            sort(l, j);\n        if (i < r)\n            sort(i, r);\n    }\n    */\n};\n```\n\n**成员函数递归调用似乎会造成程序运行时错误**，因此暂时无法实现sort函数，函数指针也无法解决这个问题，可能是因为编译器隐式的将在类内定义的成员函数当做内联函数。以后有空再来尝试解决这一问题。\n\n\n\n![奈芙莲.jpg](https://i.loli.net/2020/07/08/gHR8SmCohAFMnvT.jpg)\n\n（奈芙莲也很可爱","tags":["大学课程"]},{"title":"记一次神奇的错误","url":"/2020/06/10/20-06-error/","content":"\n\n\n前段时间hexo博客又出了一些问题，今天终于修好了。\n\n\n\n<!--more-->\n\n先上图\n\n![1.png](https://i.loli.net/2020/06/10/LaMEJYDvVG6Udy7.png)\n\n很神奇的错误，在网上找了一些解决方法都没有成功，比如控制面板的凭据管理、修改yml文件等。\n\n后来发现是GitHub的邮箱验证出了问题，重新验证了一下以后就好了。\n\n具体原因以后有空再研究一下。\n\n放一张可怕的图：\n\n![2.jpg](https://i.loli.net/2020/06/10/kdgDu3spEbe2CQv.jpg)","tags":["随笔"]},{"title":"Dijkstra算法","url":"/2020/03/19/Dijkstra/","content":"\nDijkstra算法可以用于计算正权图的单源最短路，它同时适用于有向图和无向图，在 $n$ 个顶点，$m$ 条边的图中朴素的Dijkstra算法时间复杂度 $O(n^2)$，堆优化后可以达到 $O(m\\log n)$（稀疏图）。\n\n<!--more-->\n\n### 思路\n\n与求最小生成树的Prim算法类似，从选取的原点开始，进行以下操作：\n\n1. 将已经经过的点看作一个集合（done数组）；\n2. 将除了原点之外所有点到原点的距离设置为无穷大，把原点加入集合；\n3. 对于一个新加入集合的点，遍历这个点连接的所有边，把与这些边相连的另一个顶点的距离更新；\n4. 在集合之外的所有点中找到路径最短的一个，把它加入集合，并重复步骤3，直到所有点都加入了集合。\n\n维基上的这个动图真是很形象了：\n\n![dijkstra.gif](https://i.loli.net/2020/03/19/2BtcSNAj1yo3fJT.gif)\n\n\n\n优化也和Prim算法类似，也是用一个堆，具体想法是这样的：找出未进入集合中的距离最近的点时可以将点和距离绑定，这样就能用一个堆来维护。\n\n### 紫书代码\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 9, maxm = 2e5 + 9;\nconst int inf = 0x3f3f3f3f;\ntypedef vector<int> vi;\nstruct edge\n{\n    int from, to, dist;\n    edge(int u, int v, int d) : from(u), to(v), dist(d) {}\n};\nstruct HeapNode//适应STL的堆的排序方式\n{\n    int d, u;\n    bool operator<(const HeapNode &b) const\n    {\n        return d > b.d;\n    }\n};\nstruct dijkstra\n{\n    int n, m;\n    vector<edge> edg;\n    vi graph[maxn];\n    bool done[maxn];\n    int d[maxn], p[maxn];//p是最短路中的上一条弧\n    void init(int n)\n    {\n        this->n = n;\n        for (int i = 0; i <= n; ++i)\n            graph[i].clear();\n        edg.clear();\n    }\n    void add(int from, int to, int d)\n    {\n        edg.push_back(edge(from, to, d));\n        graph[from].push_back(edg.size() - 1);\n    }\n    void dij(int s)\n    {\n        priority_queue<HeapNode> pq;\n        for (int i = 0; i <= n; ++i)\n            d[i] = inf;\n        d[s] = 0;\n        memset(done, 0, sizeof(done));\n        pq.push((HeapNode){0, s});\n        while (!pq.empty())\n        {\n            HeapNode x = pq.top();\n            pq.pop();\n            int u = x.u;\n            if (done[u])//这个点在集合内了\n                continue;\n            done[u] = true;\n            for (int i = 0; i < graph[u].size(); ++i)\n            {\n                edge &e = edg[graph[u][i]];\n                if (d[e.to] > d[u] + e.dist)\n                {\n                    d[e.to] = d[u] + e.dist;\n                    p[e.to] = graph[u][i];\n                    pq.push((HeapNode){d[e.to], e.to});\n                }\n            }\n        }\n    }\n};\ndijkstra D;\nint main()\n{\n    int n, m, s;\n    scanf(\"%d%d%d\", &n, &m, &s);\n    D.init(n);\n    for (int i = 1; i <= m; ++i)\n    {\n        int u, v, w;\n        scanf(\"%d%d%d\", &u, &v, &w);\n        D.add(u, v, w);\n    }\n    D.dij(s);\n    for (int i = 1; i <= n; ++i)\n        printf(\"%d \", D.d[i]);\n    return 0;\n}\n```\n\n### 后记\n\n不太喜欢紫书的代码风格，还是要自己改一改模板。\n\n![dij2.jpg](https://i.loli.net/2020/03/19/4m6sByMfEv531JW.jpg)","tags":["图论"]},{"title":"快读模板","url":"/2020/03/16/fstread/","content":"\n\n### 快读\n\n据说 `cin` 大约能支持 $1,000,000$ 个数据的输入，`scanf` 的效率大约是 `cin` 的十倍，而快读大约是 `scanf` 的十倍。如果需要更快就要用 `fread`。\n\n<!--more-->\n\n### 快读\n\n```c++\ninline int read(){\n    int data = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch)){\n   \tif (ch == '-')\n   \t    f = -1;\n   \tch = getchar();\n    }\n    while (isdigit(ch)){\n   \t    data = (data << 3) + (data << 1) + ch - '0';\n   \t    ch = getchar();\n    }\n    return f * data;\n}\n```\n\n据说 `isdigit` 比判断ASCII码来得快。\n\n**fread版**\n\n 版本1：\n\n```c++\nstruct FastIO {\n    static const int S = 1e7;\n    int wpos;\n    char wbuf[S];\n    FastIO() : wpos(0) {}\n    inline int xchar() {\n        static char buf[S];\n        static int len = 0, pos = 0;\n        if (pos == len)\n            pos = 0, len = fread(buf, 1, S, stdin);\n        if (pos == len) exit(0);\n        return buf[pos++];\n    }\n    inline int xuint() {\n        int c = xchar(), x = 0;\n        while (c <= 32) c = xchar();\n        for (; '0' <= c && c <= '9'; c = xchar()) x = x * 10 + c - '0';\n        return x;\n    }\n    inline int xint()\n    {\n        int s = 1, c = xchar(), x = 0;\n        while (c <= 32) c = xchar();\n        if (c == '-') s = -1, c = xchar();\n        for (; '0' <= c && c <= '9'; c = xchar()) x = x * 10 + c - '0';\n        return x * s;\n    }\n    inline void xstring(char *s)\n    {\n        int c = xchar();\n        while (c <= 32) c = xchar();\n        for (; c > 32; c = xchar()) * s++ = c;\n        *s = 0;\n    }\n    inline void wchar(int x)\n    {\n        if (wpos == S) fwrite(wbuf, 1, S, stdout), wpos = 0;\n        wbuf[wpos++] = x;\n    }\n    inline void wint(ll x)\n    {\n        if (x < 0) wchar('-'), x = -x;\n        char s[24];\n        int n = 0;\n        while (x || !n) s[n++] = '0' + x % 10, x /= 10;\n        while (n--) wchar(s[n]);\n        wchar('\\n');\n    }\n    inline void wstring(const char *s)\n    {\n        while (*s) wchar(*s++);\n    }\n    ~FastIO()\n    {\n        if (wpos) fwrite(wbuf, 1, wpos, stdout), wpos = 0;\n    }\n} io;\n```\n\n\n\n版本2：\n\n```c++\nstruct ios {\n    inline char read(){\n        static const int IN_LEN=1<<18|1;\n        static char buf[IN_LEN],*s,*t;\n        return (s==t)&&(t=(s=buf)+fread(buf,1,IN_LEN,stdin)),s==t?-1:*s++;\n    }\n\n    template <typename _Tp> inline ios & operator >> (_Tp&x){\n        static char c11,boo;\n        for(c11=read(),boo=0;!isdigit(c11);c11=read()){\n            if(c11==-1)return *this;\n            boo|=c11=='-';\n        }\n        for(x=0;isdigit(c11);c11=read())x=x*10+(c11^'0');\n        boo&&(x=-x);\n        return *this;\n    }\n} io;\n\nint main(){\n    io>>a>>b;\n}\n```\n\n\n\n版本3？？？：\n\n```c++\n#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\nchar buf[1<<23],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;\n\ninline int rd() {\n    int x=0,f=1;char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}\n    while(isdigit(ch)) x=x*10+(ch^48),ch=getchar();\n    return x*f;\n}\nvoid print(long long x) {\n    if(x>9) print(x/10);\n    *O++=x%10+'0';\n}\nfwrite(obuf,O-obuf,1,stdout);\n```\n\n\n\n### 快输\n\n版本1（递归）：\n\n```c++\n#define G(a) putchar(a+48)\ninline void write(int s){\n    if (s<0) G(-3),s=-s;\n    if (s>9) write(s/10);\n    G(s%10);\n}\n```\n\n\n\n版本2（循环）：\n\n```c++\n#define G(a) putchar(a+48)\ninline void write(int s){\n    int t=0,a[40];\n    if (s<0) G(-3),s=-s;\n    do {\n        a[++t]=s%10;\n    } while (t/=10);\n    while(t) \n        G(a[t--]);\n    putchar('');//看题目需要，可以加入\\n进行换行或者加入空格 \n}\n```\n\n\n\n当时SM.MS上不去所以放到了CSDN上，现在好了\n\n![fstread.jpg](https://i.loli.net/2020/07/20/UAnaQSyLIRkYl26.jpg)","tags":["模板"]},{"title":"最小生成树","url":"/2020/03/13/Minimum_Spanning_Tree/","content":"\n生成树（Spanning Tree）是连通图的一个极小连通子图，而最小生成树（Minimal Spanning Tree,MST）就是权值最小的生成树。最小生成树一般可以用Prim算法、Kruskal算法或[Borůvka算法](https://www.luogu.com.cn/blog/Tweetuzki/solution-p3366)求出。这里只写了前两种算法。[模板题：洛谷P3366](https://www.luogu.com.cn/problem/P3366)\n\n<!--more-->\n\n## 1.Prim\n\nPrim算法基于一种贪心的策略，即对于连通图的任意一个顶点，从该顶点出发的所有边中最短的一条一定属于最小生成树。这个策略显然是正确的，因为这条被选中的边的长度是该顶点和这张图除去该顶点的最小生成树的最小距离。\n\n具体实现的过程是先用邻接矩阵存边，然后初始化距离为最大值。任选一个顶点作为根，找到从该顶点发出的最短边并把这条边的另一个顶点并入最小生成树。然后重复寻找连接已有的最小生成树和其它顶点的最短边，依次选取新的顶点，直到所有的顶点都被选取。\n\n如果每次查找最短边都全部遍历一遍，时间复杂度是 $O(nm)$ 级别的，但是可以使用一个堆来存储已经走过的边的权值，避免重复计算，使时间复杂度降低到 $O(m\\log n)$。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, a, b) for (i = a; i <= b; ++i)\n#define drep(i, a, b) for (i = a; i >= b; --i)\ntypedef pair<int, int> pii;\nconst int maxn = 2e5 + 9;\nint i, k, n, m, cnt, sum, dis[10005], vis[10005];\nvector<int> edg[maxn], wgt[maxn];\ninline void add(int u, int v, int w)\n{\n    edg[u].push_back(v);\n    wgt[u].push_back(w);\n}\npriority_queue<pii, vector<pii>, greater<pii> > q;\ninline void prim()\n{\n    memset(dis, 127, sizeof(dis));\n    dis[1] = 0;\n    q.push(make_pair(dis[1], 1));\n    while (!q.empty() && cnt < n)\n    {\n        int d = q.top().first, u = q.top().second;\n        q.pop();\n        if (vis[u])\n            continue;\n        cnt++;\n        sum += d;\n        vis[u] = 1;\n        rep(i, 0, edg[u].size() - 1) if (wgt[u][i] < dis[edg[u][i]])\n        {\n            dis[edg[u][i]] = wgt[u][i];\n            q.push(make_pair(dis[edg[u][i]], edg[u][i]));\n        }\n    }\n}\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    rep(i, 1, m)\n    {\n        int a, b, c;\n        scanf(\"%d%d%d\", &a, &b, &c);\n        add(a, b, c);\n        add(b, a, c);\n    }\n    prim();\n    if (cnt == n) printf(\"%d\\n\", sum);\n    else puts(\"orz\");\n    return 0;\n}\n```\n\n\n\n## 2.Kruskal\n\nKruskal算法的策略也是依次选取最短边，但是它直接对边的长度进行排序，并使用并查集来判断是否需要选取这条边，如果这条边的两个顶点已经拥有公共祖先，说明这两个顶点已经存在于当前的最小生成树，所以不选取，否则就选取并且合并公共祖先。当所有的顶点拥有共同的公共祖先时最小生成树也就产生了。该算法的时间复杂度是 $O(m\\log m)$。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, a, b) for (i = a; i <= b; ++i)\n#define drep(i, a, b) for (i = a; i >= b; --i)\ntypedef pair<int, int> pii;\nconst int maxn = 2e5 + 9;\nconst int inf = 0x3f3f3f3f;\nstruct edg\n{\n    int x, y, w;\n    bool operator<(const edg &b) const\n    {\n        return w < b.w;\n    }\n};\nint n, m, father[maxn], i, ans;\nedg e[maxn];\nint find(int x)\n{\n    int t = x;\n    while (father[t] != t)\n        t = father[t];\n    father[x] = t;\n    return t;\n}\nvoid join(int x, int y)\n{\n    int tx = find(x), ty = find(y);\n    if (tx != ty)\n        father[tx] = ty;\n}\nint kruskal()\n{\n    rep(i, 1, n) father[i] = i;\n    rep(i, 1, m)\n    {\n        edg t = e[i];\n        if (find(t.x) == find(t.y))\n            continue;\n        join(t.x, t.y);\n        ans += t.w;\n    }\n    return ans;\n}\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    rep(i, 1, m) scanf(\"%d%d%d\", &e[i].x, &e[i].y, &e[i].w);\n    sort(e + 1, e + m + 1);\n    printf(\"%d\\n\", kruskal());\n    return 0;\n}\n```\n\n\n\nPrim算法更适合求稠密图的最小生成树，而Kruskal算法则更适合求稀疏图的最小生成树。\n\n![MST.jpg](https://i.loli.net/2020/03/13/O5gJTyZhsNrR12A.jpg)","tags":["图论"]},{"title":"扩展欧几里得算法","url":"/2020/02/25/Ex_GCD/","content":"\n\n扩展欧几里得算法可以找出一对整数 $(x,y)$，使得 $ax+by=\\gcd(a,b)$。\n\n<!--more-->\n\n首先放上欧几里得算法，就是小学数学中的辗转相除法求最大公约数：\n\n```c++\nint gcd(int a,int b){\n    return !b ? a : gcd(b, a % b);\n}\n```\n\n该算法的正确性是显而易见的。利用欧几里得算法可以在 $O(\\log n)$ 的时间中算出最大公约数。\n\n由裴蜀定理，可以得知该不定方程是有解的。\n\n下面来对式子 $ax+by=\\gcd(a,b)$ 做一点变形：$ax+by=\\gcd(a,b)=\\gcd(b,a\\mod b)$，有 $bx+(a\\mod b)y=bx+(a-\\lfloor \\frac a b \\rfloor b)y=\\gcd(b,a\\mod b)$，即 $ay+b(x-\\lfloor \\frac a b \\rfloor y)=\\gcd(b,a\\mod b)$，这意味着可以递归求解 $(x,y)$。这个递归过程和欧几里得算法的递归是一样的，在递归边界 $b=0$ 处，可以发现 $\\gcd(a,0)=a$，所以 $x=1,y=0$。\n\n以上过程可以得到这样的代码：（$d$ 是最大公约数）\n\n```c++\nvoid exgcd(int a, int b, int &d, int &x, int &y){\n    if (b == 0)\n        d = a, x = 1, y = 0;\n    else{\n        exgcd(b, a % b, d, y, x);\n        y -= x * (a / b);\n    }\n}\n```\n\n这就是扩展欧几里得算法，从代码中可以看到它包含了欧几里得算法，显然复杂度也没有改变。\n\n使用该算法可以解决 $ax+by=c$ 的整数解问题，首先判断 $\\gcd(a,b)$ 能否整除 $c$，如果不能那么一定不会有整数解，如果能整除就用exgcd算。\n\n**简单的例题：[洛谷P1082](https://www.luogu.com.cn/problem/P1082)**\n\n求关于 $x$ 的同余方程 $ax\\equiv 1(\\mod b)$ 的最小正整数解。\n\n对方程稍作变形，就可以利用exgcd了。由 $ax\\equiv 1(\\mod b)$ 可得 $ax-by=1$ ，由于 $y$ 的正负并没有影响，故等价于 $ax+by=1$，那么需要使 $\\gcd(a,b)=1$，即两数互质，这就是答案存在的前提，题目也已经保证了这一点。到这一步后就可以直接用了，最后得出的 $x$ 就是一个整数解，但它不一定是最小的，甚至不一定是整数，所以还需要再取模处理一下。\n\n这样解出的 $x$ 就是 $a$ 在模 $b$ 意义下的乘法逆元。也就是说，在模 $b$ 意义下如果除以 $a$ 很麻烦，那么可以乘上 $x$ 起到同样的效果。\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nvoid exgcd(int a, int b, int &d, int &x, int &y)\n{\n    if (b == 0)\n        d = a, x = 1, y = 0;\n    else\n    {\n        exgcd(b, a % b, d, y, x);\n        y -= x * (a / b);\n    }\n}\nint main()\n{\n    int a, b, d, x, y;\n    cin >> a >> b;\n    exgcd(a, b, d, x, y);\n    cout << (x % b + b) % b;\n    return 0;\n}\n```\n\n","tags":["数论"]},{"title":"AVL树","url":"/2020/02/12/AVL_Tree/","content":"\n# 简介：\n\nAVL树是最先发明的自平衡二叉查找树。AVL树高度平衡，其任意节点左右子树的高度差不超过1。同时它也拥有普通二叉查找树的性质，即每个节点左子树上所有节点的值均小于根节点的值，右子树上所有节点的值均大于根节点的值，且不同节点的值均不同。\n\n<!--more-->\n\n# 实现过程\n**平衡因子：**每个节点左子树和右子树的高度差。若所有节点平衡因子的绝对值均不超过1则平衡。\n\n使用一个结构体保存节点的键值、频数、以该点为根的树的树高和大小以及左右子树。当树不平衡时，可以通过旋转使树平衡。\n\n```c++\nstruct AVL_node;\ntypedef AVL_node *AVL_Tree;\nstruct AVL_node\n{\n    int value, height, freq, size;\n    AVL_Tree ls, rs;\n    AVL_node() : value(0), height(1), freq(1), size(1), ls(nullptr), rs(nullptr) {}\n    AVL_node(int n) : value(n), height(1), freq(1), size(1), ls(nullptr), rs(nullptr) {}\n};\n```\n\n**不平衡情况1（左-左）：**\n\n![1](https://i.loli.net/2020/02/12/BYrixbevTfP8cR4.png)\n\n在插入1之前，树是平衡的，但是9的左子树比右子树高度大。在9的左子树的左子树插入1（或2，4，5）后，树不平衡了，这种左子树更高且向左子树的左子树插入节点的情况可以通过一次右旋来使树平衡。右旋使原来不平衡的根节点的左子树成为根节点，而原来的根节点成为新的右子树，原来左子树的右子树成为原来的根节点的左子树。容易证明，旋转后依旧具有二叉查找树的性质。\n\n![2](https://i.loli.net/2020/02/12/mz46SiMWg5lTcfJ.png)\n\n```c++\ninline void rotate_ls_ls(AVL_Tree &p)\n{\n    AVL_Tree q;\n    q = p->ls;\n    p->ls = q->rs;\n    q->rs = p;\n    update(p);\n    update(q);\n    p = q;\n}\n```\n**不平衡情况2（右-右）：**\n\n![3](https://i.loli.net/2020/02/12/f5eClWkqbJ7XywL.png)\n\n在插入13之前，树是平衡的，但是8的右子树比左子树高度大。在8的右子树的右子树插入13（或11）后，树不平衡了，这种右子树更高且向右子树的右子树插入节点的情况可以通过一次左旋来使树平衡。左旋使原来不平衡的根节点的右子树成为根节点，而原来的根节点成为新的左子树，原来右子树的左子树成为原来的根节点的右子树。同样，旋转后依旧具有二叉查找树的性质。\n\n![4](https://i.loli.net/2020/02/12/vhUgRs8SFj41HmV.png)\n```c++\ninline void rotate_rs_rs(AVL_Tree &p)\n{\n    AVL_Tree q;\n    q = p->rs;\n    p->rs = q->ls;\n    q->ls = p;\n    update(p);\n    update(q);\n    p = q;\n}\n```\n**不平衡情况3：（左-右）**\n\n![5](https://i.loli.net/2020/02/12/dRS1WHXAN7MlUhg.png)\n\n这种情况是在左子树更高的树的左子树的右子树插入节点，需要先进行一次左旋，再进行一次右旋。\n\n左旋：\n\n![6](https://i.loli.net/2020/02/12/9S1xL8N2FIvhuZA.png)\n\n右旋：\n\n![7](https://i.loli.net/2020/02/12/WgVKU1dbrEno9Ra.png)\n```c++\ninline void rotate_ls_rs(AVL_Tree &p)\n{\n    rotate_rs_rs(p->ls);\n    rotate_ls_ls(p);\n}\n```\n**不平衡情况4：（右-左）**\n\n与情况3相反，先进行一次右旋，再进行一次左旋。\n\n![8](https://i.loli.net/2020/02/12/6KXb74TNLQUO1RB.png)\n\n右旋：\n\n![9](https://i.loli.net/2020/02/12/V5JZvClKTzU8qcP.png)\n\n左旋：\n\n![10](https://i.loli.net/2020/02/12/2h8ktCgqNnZR3IW.png)\n```c++\ninline void rotate_rs_ls(AVL_Tree &p)\n{\n    rotate_ls_ls(p->rs);\n    rotate_rs_rs(p);\n}\n```\n\n**获取树的大小**\n\n```c++\ninline int get_size(AVL_Tree p)\n{\n    if (p == nullptr)\n        return 0;\n    return p->size;\n}\n```\n\n**获取树的高度**\n\n```c++\ninline int get_height(AVL_Tree p)\n{\n    if (p == nullptr)\n        return 0;\n    return p->height;\n}\n```\n\n**更新**\n\n```c++\ninline void update(AVL_Tree &p)\n{\n    p->size = get_size(p->ls) + get_size(p->rs) + p->freq;\n    p->height = max(get_height(p->ls), get_height(p->rs)) + 1;\n}\n```\n\n**插入**\n\n```c++\nvoid AVL_insert(AVL_Tree &p, int x)\n{\n    if (p == nullptr)\n    {\n        p = new AVL_node(x);\n        return;\n    }\n    if (p->value == x)//已经存在,频数+1\n    {\n        (p->freq)++;\n        update(p);\n        return;\n    }\n    if (p->value > x)\n    {\n        AVL_insert(p->ls, x);\n        update(p);\n        if (get_height(p->ls) - get_height(p->rs) == 2)//插到左边,左边更高\n        {\n            if (x < p->ls->value)\n                rotate_ls_ls(p);\n            else\n                rotate_ls_rs(p);\n        }\n    }\n    else\n    {\n        AVL_insert(p->rs, x);\n        update(p);\n        if (get_height(p->rs) - get_height(p->ls) == 2)//插到右边,右边更高\n        {\n            if (x > p->rs->value)\n                rotate_rs_rs(p);\n            else\n                rotate_rs_ls(p);\n        }\n    }\n    update(p);\n}\n```\n\n**删除数据**\n\n```c++\nvoid AVL_erase(AVL_Tree &p, int x)\n{\n    if (p == nullptr)\n        return;\n    if (p->value > x)\n    {\n        AVL_erase(p->ls, x);\n        update(p);\n        if (get_height(p->rs) - get_height(p->ls) == 2)//删左边，右边高\n        {\n            if (get_height(p->rs->rs) >= get_height(p->rs->ls))//见代码后注释\n                rotate_rs_rs(p);\n            else\n                rotate_rs_ls(p);\n        }\n    }\n    else if (p->value < x)\n    {\n        AVL_erase(p->rs, x);\n        update(p);\n        if (get_height(p->ls) - get_height(p->rs) == 2)\n        {\n            if (get_height(p->ls->ls) >= get_height(p->ls->rs))\n                rotate_ls_ls(p);\n            else\n                rotate_ls_rs(p);\n        }\n    }\n    else\n    {\n        if (p->freq > 1)\n        {\n            (p->freq)--;\n            update(p);\n            return;\n        }\n        if (p->ls && p->rs)\n        {\n            AVL_Tree q;\n            q = p->rs;\n            while (q->ls)\n                q = q->ls;\n            p->freq = q->freq;\n            p->value = q->value;\n            q->freq = 1; //删除q\n            AVL_erase(p->rs, q->value);\n            if (get_height(p->ls) - get_height(p->rs) == 2)\n            {\n                if (get_height(p->ls->ls) >= get_height(p->ls->rs))\n                    rotate_ls_ls(p);\n                else\n                    rotate_ls_rs(p);\n            }\n        }\n        else\n        {\n            AVL_Tree q;\n            q = p;\n            if (p->ls)\n                p = p->ls;\n            else if (p->rs)\n                p = p->rs;\n            else\n                p = nullptr;\n            delete q;\n            q = nullptr;\n        }\n    }\n    if (p == nullptr)\n        return;\n    update(p);\n}\n```\n\n第11行必须用$\\ge$，否则遇到如图的情况：\n\n![11](https://i.loli.net/2020/02/12/XuxmhoWtJvaCqwp.png)\n\n删去13后，先右旋再左旋，树仍然不是平衡的：\n\n![12](https://i.loli.net/2020/02/12/U4IajS9vukohHml.png)\n\n**通过值查找位次**\n\n```c++\nint get_rank(AVL_Tree p, int x)\n{\n    if (p->value == x)\n        return get_size(p->ls) + 1;\n    if (p->value > x)\n        return get_rank(p->ls, x);\n    return get_rank(p->rs, x) + get_size(p->ls) + p->freq;\n}\n```\n\n**通过位次查找值**\n\n```c++\nint get_val(AVL_Tree p, int r)\n{\n    if (get_size(p->ls) >= r)\n        return get_val(p->ls, r);\n    if (get_size(p->ls) + p->freq >= r)\n        return p->value;\n    return get_val(p->rs, r - get_size(p->ls) - p->freq);\n}\n```\n\n**查找前驱**\n\n```c++\nint get_pre(AVL_Tree p, int x)\n{\n    AVL_Tree ans = new AVL_node(-inf);\n    while (p)\n    {\n        if (p->value == x)\n        {\n            if (p->ls)\n            {\n                p = p->ls;\n                while (p->rs)\n                {\n                    p = p->rs;\n                }\n                ans = p;\n            }\n            break;\n        }\n        if (p->value < x && p->value > ans->value)\n            ans = p;\n        p = p->value < x ? p->rs : p->ls;\n    }\n    return ans->value;\n}\n```\n\n**查找后继**\n\n```c++\nint get_suf(AVL_Tree p, int x)\n{\n    AVL_Tree ans = new AVL_node(inf);\n    while (p)\n    {\n        if (p->value == x)\n        {\n            if (p->rs)\n            {\n                p = p->rs;\n                while (p->ls)\n                {\n                    p = p->ls;\n                }\n                ans = p;\n            }\n            break;\n        }\n        if (p->value > x && p->value < ans->value)\n            ans = p;\n        p = p->value < x ? p->rs : p->ls;\n    }\n    return ans->value;\n}\n```\n\n**中序遍历**\n\n```c++\nvoid output(AVL_Tree p)\n{\n    if(p==nullptr)\n        return;\n    output(p->ls);\n    for (int i = 1; i <= p->freq;i++)\n        printf(\"%d \", p->value);\n    output(p->rs);\n}\n```\n\nAVL树的插入、删除、查找都是$\\log$级别的复杂度，其中AVL树的查询和其它平衡树相比会更有优势，但是AVL树代码量比较大，总体速度也很一般，可以分裂合并，可持久化，但是比较难写。\n\n终于写完了，真是不容易。\n\n![v2-28825ec8201c53892205bfd8b41c97dd_hd.jpg](https://i.loli.net/2020/02/12/1scLYZaiKRt25N3.jpg)\n\n\n","tags":["数据结构"]},{"title":"洛谷P3369题解","url":"/2020/02/12/P3369-Solution/","content":"\n### 链接：[P3369](https://www.luogu.com.cn/problem/P3369)\n<!--more-->\n\n# 题解：\n题目要求用一个数据结构实现一些数的插入、删除、根据排名查找数、根据数值询问排名以及求前驱和后继，所以可以通过建一棵AVL树来实现。\n\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 0x7FFFFFFF;\nstruct AVL_node;\ntypedef AVL_node *AVL_Tree;\nstruct AVL_node\n{\n    int value, height, freq, size;\n    AVL_Tree ls, rs;\n    AVL_node() : value(0), height(1), freq(1), size(1), ls(nullptr), rs(nullptr) {}\n    AVL_node(int n) : value(n), height(1), freq(1), size(1), ls(nullptr), rs(nullptr) {}\n};\ninline int get_size(AVL_Tree p)\n{\n    if (p == nullptr)\n        return 0;\n    return p->size;\n}\ninline int get_height(AVL_Tree p)\n{\n    if (p == nullptr)\n        return 0;\n    return p->height;\n}\ninline void update(AVL_Tree &p)\n{\n    p->size = get_size(p->ls) + get_size(p->rs) + p->freq;\n    p->height = max(get_height(p->ls), get_height(p->rs)) + 1;\n}\ninline void rotate_ls_ls(AVL_Tree &p)\n{\n    AVL_Tree q;\n    q = p->ls;\n    p->ls = q->rs;\n    q->rs = p;\n    update(p);\n    update(q);\n    p = q;\n}\ninline void rotate_rs_rs(AVL_Tree &p)\n{\n    AVL_Tree q;\n    q = p->rs;\n    p->rs = q->ls;\n    q->ls = p;\n    update(p);\n    update(q);\n    p = q;\n}\ninline void rotate_ls_rs(AVL_Tree &p)\n{\n    rotate_rs_rs(p->ls);\n    rotate_ls_ls(p);\n}\ninline void rotate_rs_ls(AVL_Tree &p)\n{\n    rotate_ls_ls(p->rs);\n    rotate_rs_rs(p);\n}\nvoid AVL_insert(AVL_Tree &p, int x)\n{\n    if (p == nullptr)\n    {\n        p = new AVL_node(x);\n        return;\n    }\n    if (p->value == x)\n    {\n        (p->freq)++;\n        update(p);\n        return;\n    }\n    if (p->value > x)\n    {\n        AVL_insert(p->ls, x);\n        update(p);\n        if (get_height(p->ls) - get_height(p->rs) == 2)\n        {\n            if (x < p->ls->value)\n                rotate_ls_ls(p);\n            else\n                rotate_ls_rs(p);\n        }\n    }\n    else\n    {\n        AVL_insert(p->rs, x);\n        update(p);\n        if (get_height(p->rs) - get_height(p->ls) == 2)\n        {\n            if (x > p->rs->value)\n                rotate_rs_rs(p);\n            else\n                rotate_rs_ls(p);\n        }\n    }\n    update(p);\n}\nvoid AVL_erase(AVL_Tree &p, int x)\n{\n    if (p == nullptr)\n        return;\n    if (p->value > x)\n    {\n        AVL_erase(p->ls, x);\n        update(p);\n        if (get_height(p->rs) - get_height(p->ls) == 2)\n        {\n            if (get_height(p->rs->rs) >= get_height(p->rs->ls))\n                rotate_rs_rs(p);\n            else\n                rotate_rs_ls(p);\n        }\n    }\n    else if (p->value < x)\n    {\n        AVL_erase(p->rs, x);\n        update(p);\n        if (get_height(p->ls) - get_height(p->rs) == 2)\n        {\n            if (get_height(p->ls->ls) >= get_height(p->ls->rs))\n                rotate_ls_ls(p);\n            else\n                rotate_ls_rs(p);\n        }\n    }\n    else\n    {\n        if (p->freq > 1)\n        {\n            (p->freq)--;\n            update(p);\n            return;\n        }\n        if (p->ls && p->rs)\n        {\n            AVL_Tree q;\n            q = p->rs;\n            while (q->ls)\n                q = q->ls;\n            p->freq = q->freq;\n            p->value = q->value;\n            q->freq = 1; //to erase q;\n            AVL_erase(p->rs, q->value);\n            if (get_height(p->ls) - get_height(p->rs) == 2)\n            {\n                if (get_height(p->ls->ls) >= get_height(p->ls->rs))\n                    rotate_ls_ls(p);\n                else\n                    rotate_ls_rs(p);\n            }\n        }\n        else\n        {\n            AVL_Tree q;//防止内存泄漏\n            q = p;\n            if (p->ls)\n                p = p->ls;\n            else if (p->rs)\n                p = p->rs;\n            else\n                p = nullptr;\n            delete q;\n            q = nullptr;\n        }\n    }\n    if (p == nullptr)\n        return;\n    update(p);\n}\nint get_rank(AVL_Tree p, int x)\n{\n    if (p->value == x)\n        return get_size(p->ls) + 1;\n    if (p->value > x)\n        return get_rank(p->ls, x);\n    return get_rank(p->rs, x) + get_size(p->ls) + p->freq;\n}\nint get_val(AVL_Tree p, int r)\n{\n    if (get_size(p->ls) >= r)\n        return get_val(p->ls, r);\n    if (get_size(p->ls) + p->freq >= r)\n        return p->value;\n    return get_val(p->rs, r - get_size(p->ls) - p->freq);\n}\nint get_pre(AVL_Tree p, int x)\n{\n    AVL_Tree ans = new AVL_node(-inf);\n    while (p)\n    {\n        if (p->value == x)\n        {\n            if (p->ls)\n            {\n                p = p->ls;\n                while (p->rs)\n                {\n                    p = p->rs;\n                }\n                ans = p;\n            }\n            break;\n        }\n        if (p->value < x && p->value > ans->value)\n            ans = p;\n        p = p->value < x ? p->rs : p->ls;\n    }\n    return ans->value;\n}\nint get_suf(AVL_Tree p, int x)\n{\n    AVL_Tree ans = new AVL_node(inf);\n    while (p)\n    {\n        if (p->value == x)\n        {\n            if (p->rs)\n            {\n                p = p->rs;\n                while (p->ls)\n                {\n                    p = p->ls;\n                }\n                ans = p;\n            }\n            break;\n        }\n        if (p->value > x && p->value < ans->value)\n            ans = p;\n        p = p->value < x ? p->rs : p->ls;\n    }\n    return ans->value;\n}\nAVL_Tree root;\nint main()\n{\n    int n, op, x;\n    scanf(\"%d\", &n);\n    for (register int i = 1; i <= n; i++)\n    {\n        scanf(\"%d%d\", &op, &x);\n        switch (op)\n        {\n        case 1:\n            AVL_insert(root, x);\n            break;\n        case 2:\n            AVL_erase(root, x);\n            break;\n        case 3:\n            printf(\"%d\\n\", get_rank(root, x));\n            break;\n        case 4:\n            printf(\"%d\\n\", get_val(root, x));\n            break;\n        case 5:\n            printf(\"%d\\n\", get_pre(root, x));\n            break;\n        case 6:\n            printf(\"%d\\n\", get_suf(root, x));\n            break;\n        default:\n            break;\n        }\n    }\n    return 0;\n}\n```\n\n[今天才学会的AVL树](https://phlzy.github.io/2020/02/12/AVL_Tree/)","tags":["题解"]},{"title":"KMP算法","url":"/2020/02/08/KMP/","content":"\n\nKMP算法是一种字符串匹配算法。朴素的暴力匹配法应对随机数据表现很好，但是它的最坏情况的时间复杂度是$O(mn)$，而KMP算法的时间复杂度是$O(m+n)$。\n\n<!--more-->\n\n## 字符串基础\n\n对于一个字符串 $s$，我们做如下的几个定义：\n\n- 子串：原串 $s$ 中连续的一段称为子串，空串也是子串\n\n- 前缀：$\\text{pre}(s,k)$ 是原串 $s$ 的前 $k$ 个字符构成的子串\n\n- 后缀：$\\text{sub}(s,k)$ 是原串 $s$ 的后 $k$ 个字符构成的子串\n  \n  - 因此可以得到这样的推论：任何子串都是某个前缀的后缀，也是某个后缀的前缀\n  \n- 最长公共前缀：$\\text{lcp}(s,t)$，最长公共后缀：$\\text{lcs}(s,t)$：顾名思义\n\n- 一般用 $|s|$ 表示字符串 $s$ 的长度\n\n- Border：如果正整数 $r$ 满足\n\n  - $0\\lt r \\lt |s|$\n  - $\\text{pre}(s,r) = \\text{suf}(s,r)$\n\n  那么 $\\text{pre}(s,r)$ 称为 $s$ 的一个Border\n\n- 显然，Border具有传递性，如果 $r$ 是 $s$ 的Border，$s$ 是 $t$ 的Border，那么 $r$ 是 $t$ 的Border\n\n  - 记 $\\text{mb}(s)$ 表示 $s$ 的最长Border，那么 $\\text{mb}(s),\\text{mb}(\\text{mb}(s)),\\cdots$ 构成了 $s$ 的所有Border\n  - 这就是KMP算法的本质\n\n## 原理\n\n朴素的匹配算法需要两个指针 $i$，$j$，其中 $i$ 指向文本中匹配到的位置，$j$ 指向模式串中的位置。当某次匹配失败后，$i$指针可能会需要向文本头部回溯，而KMP算法在匹配失败后利用已知的信息直接将模式串移动一段距离，避免了暴力算法的回溯，从而提高了匹配的效率。\n\nKMP算法的核心在于next数组，next数组中的 $\\text{next}_i$ 就是 $\\text{mb}(\\text{pre}(s,i))$，即**模式串某个前缀的最大Border**（如果没有就记为 $0$）。\n\n得到next数组后我们就去匹配，如果失配了就跳到next数组对应的位置继续。很明显在匹配过程中不会出现回溯的情况，因此复杂度是线性的。\n\n## 预处理\n\n由于使用 `std::string` 保存字符串，下文中字符串元素下标均从 $0$ 开始。\n\n我们默认 $\\text{next}[0]=-1$，然后进行自我匹配，若 $s[\\text{next}[m]+1]=s[m+1]$，那么 $\\text{next}[m+1]=\\text{next}[m]+1$，否则就跳转到 $\\text{next}[\\text{next}[m]]$ 进行匹配直到成功为止。\n\n显然，$\\text{next}[i]\\lt i$，也就是说这是一个在线算法。该算法的时间复杂度是 $O(n)$。\n\n## 代码实现\n\n[P3375 【模板】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e6 + 9;\nint lena, lenb;\nint n[maxn];\nstring a, b;\nvoid get_next()\n{\n    int i = 0, j = -1;\n    n[0] = -1;\n    while (i < lenb)\n    {\n        if (j == -1 || b[i] == b[j])\n            n[++i] = ++j;\n        else\n            j = n[j];\n    }\n}\nvoid KMP()\n{\n    int i = 0, j = 0;\n    while (i < lena)\n    {\n        if (j == -1 || a[i] == b[j])\n            i++, j++;\n        else\n            j = n[j];\n        if (j == lenb)\n            printf(\"%d\\n\", i - lenb + 1), j = n[j];\n    }\n}\nint main()\n{\n    cin >> a >> b;\n    lena = a.length();\n    lenb = b.length();\n    get_next();\n    KMP();\n    for (int i = 1; i <= lenb; i++)\n        printf(\"%d \", n[i]);\n    return 0;\n}\n```\n\n```c++\nvoid get_next() // index from 1\n{\n    for (int i = 2, j = 0; i <= len2; ++i)\n    {\n        while (j && t[i] != t[j + 1])\n            j = nxt[j];\n        j += t[i] == t[j + 1];\n        nxt[i] = j;\n    }\n}\n```\n\n\n\n## 后记\n\n初学KMP算法的时候写了这篇博客，当时理解还不是非常透彻，一些表述也不是很清晰。大半年后回顾KMP算法，很多地方的理解都更深了，所以对这篇文章进行了大幅度的修改。或许一段时间后再回来看一次，又能完善一些内容了。通过这种方式看到自己的进步，也是比较让人欣慰的。\n\n- 84526676\n\n![84526676](https://i.loli.net/2020/09/25/XS5CiQvcOzKRwoA.jpg)","tags":["字符串"]},{"title":"Trie","url":"/2020/02/07/Trie/","content":"\nTrie（字典树、前缀树）是一棵多叉树，每条边都存储一个字符，从根到某个点的一条路径就是一个串。\n\n<!--more-->\n\n## 结点\n\nTrie的根节点是空的，因为每个单词的首字母几乎不可能全部相同。Trie的建树方式类似于数组模拟链表，先定义结构体node存放字符，node中子节点的数量由字符的种类决定，此外node中至少还需要包含一个判断单词结尾的标记。代码如下：\n\n```c++\nstruct node\n{\n    int cnt;\n    int son[26];//如果只有英文字母且不区分大小写\n    bool isword;\n    node(){}\n    node()\n    {\n        cnt = 0;\n        memset(son, 0, sizeof(son));\n        isword = false;\n    }\n};\n```\n\n## 建树/插入\n\n每次都从根开始，逐渐向下，如果后面空了就申请一个新的节点连在后面。代码如下：\n\n```c++\nint num = 0;\nvoid insert(char s[])\n{\n    int t, len = strlen(s);\n    int pos = root;\n    for (int i = 0; i < len; i++)\n    {\n        t = (int)s[i] - 'a';\n        if (!trie[pos].son[t])\n            trie[pos].son[t] = ++num;\n        pos = trie[pos].son[t];\n    }\n    trie[pos].isword = true;\n}\n```\n\n## 查询\n\n和插入非常相似，代码如下：\n\n```c++\nvoid check(char s[])\n{\n    int t, pos = root, len = strlen(s);\n    for (int i = 0; i < len; i++)\n    {\n        t = (int)s[i] - 'a';\n        if (!trie[pos].son[t])\n        {\n            printf(\"WRONG\\n\");\n            return;\n        }\n        pos = trie[pos].son[t];\n    }\n    // 查询结束，根据题意判断\n    return;\n}\n```\n## 删除\n\n字典树删除单词的要求很少见，如果需要删除的单词是其它单词的前缀，只需要更改它的判断标记即可；如果它有其它的分支，就删除最后一个分支后面的节点；如果它是一个单独的分支，就删除整个单词。\n\n## 01Trie\n\n01Trie对数的二进制位建Trie，可以实现一些平衡树的功能，也可以用于解决很多异或问题。\n\n一般从高位到低位建树，具体情况具体分析。\n\n当平衡树用的时候跑得很快，但是用处很有限，所以简单了解一下就可以了。插入和普通字典树的插入一样，删除的时候对应数字 $size-1$，查值和位次直接根据 $size$ 找，查前驱后继就转化为值和位次的查询问题。\n\n解决异或问题的时候把01Trie建出来，就转化为别的问题了。\n\n[P4551 最长异或路径](https://www.luogu.com.cn/problem/P4551)\n\n\n## 可持久化\n\n以后再学\n\n[洛谷日报](https://www.luogu.com.cn/blog/sdlang/Trie-study-text)\n\n[P4735 最大异或和](https://www.luogu.com.cn/problem/P4735)\n\n\n## 边压缩优化\n\n思路类似于后缀树，优化后支持的操作更少了，虽然比普通Trie快很多，但是并没有什么用。\n\n- 84635161\n\n![84635161](https://i.loli.net/2020/09/29/gpAieKUdhZBu7Q3.jpg)","tags":["数据结构"]},{"title":"ST表(Sparse Table)","url":"/2020/02/01/Sparse_Table/","content":"\n# 简介：\n\nST表类似于树状数组和线段树，是一种用于解决RMQ（Range Minimum/Maximum Query，区间最值查询）问题的离线算法。\n与线段树相比，ST表预处理复杂度同为  $ O(nlogn) $ ，查询时间上，ST表为  $ O(1) $，线段树为  $ O(nlogn) $。\nST表的主体是一个二维数组  $ ST{_i}{_j} $ ，表示需要查询的数组的从下标  $ i $  到下标  $ i+2^j - 1 $  的最值。\n\n<!--more-->\n\n# 模板题[(P3865)](https://www.luogu.com.cn/problem/P3865)简述：\n\n给定一个长度为 $ N $ 的数列，和 $ M $ 次询问，求出每一次询问的区间内数字的最大值。\n\n## 输入:\n第一行包含两个整数 $ N $ ， $ M $ ，分别表示数列的长度和询问的个数。\n第二行包含 $ N $ 个整数（记为 $ a_i $ ），依次表示数列的第 $ i $ 项。\n接下来 $ M $ 行，每行包含两个整数 $ l_i $ ， $ r_i $ ，表示查询的区间为 $ [l_i,r_i] $ 。\n\n## 输出:\n输出包含 $ M $ 行，每行一个整数，依次表示每一次询问的结果。\n# 题解：\n\n首先，对输入数据进行预处理： $ ST{_i}{_j} $ 表示区间上从第 $ i $ 个位置（包括自己）开始，向后数 $ 2^j $ 个数中的最值；\n显然， $ ST{_i}{_0} $ 即为输入的数组本身，而 $ j>0 $ 时， $ ST{_i}{_j} $ 取其包含的两个小区间的最（大）值。\n由于ST表需要一层一层地生成，在预处理时要将某个长度的每一段都生成后再生成更长的段，其循环部分的书写比较特殊，将 $ j $ 写在 $ i $ 的外面看起来更为直观。\n在查询时，因为区间长度都是2的幂，需要先找到不大于查询区间的2的最大次幂，并以查询的区间的左端点为起点查询一次，再以查询的区间的右端点为终点查询一次，然后进行比较。这样可以保证在最少的查询次数下获得所求的最值。\n# AC代码：\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\nint ST[100001][21];\nint query(int left, int right)\n{\n    int k = log2(right - left + 1);\n    return max(ST[left][k], ST[right - (1 << k) + 1][k]);\n}\nint main()\n{\n    int n, m, left, right;\n    scanf(\"%d%d\", &n, &m);\n    for (register int i = 1; i <= n; i++)\n        scanf(\"%d\", &ST[i][0]);\n    for (register int j = 1; j <= 21; j++)\n        for (register int i = 1; i + (1 << j) - 1 <= n; i++)\n            ST[i][j] = max(ST[i][j - 1], ST[i + (1 << (j - 1))][j - 1]);\n    for (register int i = 1; i <= m; i++)\n    {\n        scanf(\"%d%d\", &left, &right);\n        printf(\"%d\\n\", query(left, right));\n    }\n    return 0;\n}\n```\n\n","tags":["数据结构"]}]